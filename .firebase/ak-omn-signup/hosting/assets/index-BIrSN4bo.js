(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o); new MutationObserver(o => { for (const u of o) if (u.type === "childList") for (const c of u.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && r(c) }).observe(document, { childList: !0, subtree: !0 }); function i(o) { const u = {}; return o.integrity && (u.integrity = o.integrity), o.referrerPolicy && (u.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? u.credentials = "include" : o.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin", u } function r(o) { if (o.ep) return; o.ep = !0; const u = i(o); fetch(o.href, u) } })(); function jx(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Gm = { exports: {} }, Jl = {}; var l1; function Ux() { if (l1) return Jl; l1 = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment"); function i(r, o, u) { var c = null; if (u !== void 0 && (c = "" + u), o.key !== void 0 && (c = "" + o.key), "key" in o) { u = {}; for (var d in o) d !== "key" && (u[d] = o[d]) } else u = o; return o = u.ref, { $$typeof: e, type: r, key: c, ref: o !== void 0 ? o : null, props: u } } return Jl.Fragment = t, Jl.jsx = i, Jl.jsxs = i, Jl } var u1; function Bx() { return u1 || (u1 = 1, Gm.exports = Ux()), Gm.exports } var F = Bx(), Ym = { exports: {} }, Rt = {}; var c1; function Fx() { if (c1) return Rt; c1 = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), u = Symbol.for("react.consumer"), c = Symbol.for("react.context"), d = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), g = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), b = Symbol.for("react.activity"), E = Symbol.iterator; function x(N) { return N === null || typeof N != "object" ? null : (N = E && N[E] || N["@@iterator"], typeof N == "function" ? N : null) } var M = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, j = Object.assign, z = {}; function K(N, Z, ot) { this.props = N, this.context = Z, this.refs = z, this.updater = ot || M } K.prototype.isReactComponent = {}, K.prototype.setState = function (N, Z) { if (typeof N != "object" && typeof N != "function" && N != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, N, Z, "setState") }, K.prototype.forceUpdate = function (N) { this.updater.enqueueForceUpdate(this, N, "forceUpdate") }; function it() { } it.prototype = K.prototype; function X(N, Z, ot) { this.props = N, this.context = Z, this.refs = z, this.updater = ot || M } var at = X.prototype = new it; at.constructor = X, j(at, K.prototype), at.isPureReactComponent = !0; var lt = Array.isArray; function ht() { } var R = { H: null, A: null, T: null, S: null }, A = Object.prototype.hasOwnProperty; function C(N, Z, ot) { var ct = ot.ref; return { $$typeof: e, type: N, key: Z, ref: ct !== void 0 ? ct : null, props: ot } } function O(N, Z) { return C(N.type, Z, N.props) } function I(N) { return typeof N == "object" && N !== null && N.$$typeof === e } function k(N) { var Z = { "=": "=0", ":": "=2" }; return "$" + N.replace(/[=:]/g, function (ot) { return Z[ot] }) } var D = /\/+/g; function Yt(N, Z) { return typeof N == "object" && N !== null && N.key != null ? k("" + N.key) : Z.toString(36) } function Wt(N) { switch (N.status) { case "fulfilled": return N.value; case "rejected": throw N.reason; default: switch (typeof N.status == "string" ? N.then(ht, ht) : (N.status = "pending", N.then(function (Z) { N.status === "pending" && (N.status = "fulfilled", N.value = Z) }, function (Z) { N.status === "pending" && (N.status = "rejected", N.reason = Z) })), N.status) { case "fulfilled": return N.value; case "rejected": throw N.reason } }throw N } function Q(N, Z, ot, ct, Et) { var Ct = typeof N; (Ct === "undefined" || Ct === "boolean") && (N = null); var Tt = !1; if (N === null) Tt = !0; else switch (Ct) { case "bigint": case "string": case "number": Tt = !0; break; case "object": switch (N.$$typeof) { case e: case t: Tt = !0; break; case v: return Tt = N._init, Q(Tt(N._payload), Z, ot, ct, Et) } }if (Tt) return Et = Et(N), Tt = ct === "" ? "." + Yt(N, 0) : ct, lt(Et) ? (ot = "", Tt != null && (ot = Tt.replace(D, "$&/") + "/"), Q(Et, Z, ot, "", function (kn) { return kn })) : Et != null && (I(Et) && (Et = O(Et, ot + (Et.key == null || N && N.key === Et.key ? "" : ("" + Et.key).replace(D, "$&/") + "/") + Tt)), Z.push(Et)), 1; Tt = 0; var ye = ct === "" ? "." : ct + ":"; if (lt(N)) for (var $t = 0; $t < N.length; $t++)ct = N[$t], Ct = ye + Yt(ct, $t), Tt += Q(ct, Z, ot, Ct, Et); else if ($t = x(N), typeof $t == "function") for (N = $t.call(N), $t = 0; !(ct = N.next()).done;)ct = ct.value, Ct = ye + Yt(ct, $t++), Tt += Q(ct, Z, ot, Ct, Et); else if (Ct === "object") { if (typeof N.then == "function") return Q(Wt(N), Z, ot, ct, Et); throw Z = String(N), Error("Objects are not valid as a React child (found: " + (Z === "[object Object]" ? "object with keys {" + Object.keys(N).join(", ") + "}" : Z) + "). If you meant to render a collection of children, use an array instead.") } return Tt } function rt(N, Z, ot) { if (N == null) return N; var ct = [], Et = 0; return Q(N, ct, "", "", function (Ct) { return Z.call(ot, Ct, Et++) }), ct } function et(N) { if (N._status === -1) { var Z = N._result; Z = Z(), Z.then(function (ot) { (N._status === 0 || N._status === -1) && (N._status = 1, N._result = ot) }, function (ot) { (N._status === 0 || N._status === -1) && (N._status = 2, N._result = ot) }), N._status === -1 && (N._status = 0, N._result = Z) } if (N._status === 1) return N._result.default; throw N._result } var xt = typeof reportError == "function" ? reportError : function (N) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var Z = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof N == "object" && N !== null && typeof N.message == "string" ? String(N.message) : String(N), error: N }); if (!window.dispatchEvent(Z)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", N); return } console.error(N) }, Ot = { map: rt, forEach: function (N, Z, ot) { rt(N, function () { Z.apply(this, arguments) }, ot) }, count: function (N) { var Z = 0; return rt(N, function () { Z++ }), Z }, toArray: function (N) { return rt(N, function (Z) { return Z }) || [] }, only: function (N) { if (!I(N)) throw Error("React.Children.only expected to receive a single React element child."); return N } }; return Rt.Activity = b, Rt.Children = Ot, Rt.Component = K, Rt.Fragment = i, Rt.Profiler = o, Rt.PureComponent = X, Rt.StrictMode = r, Rt.Suspense = p, Rt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, Rt.__COMPILER_RUNTIME = { __proto__: null, c: function (N) { return R.H.useMemoCache(N) } }, Rt.cache = function (N) { return function () { return N.apply(null, arguments) } }, Rt.cacheSignal = function () { return null }, Rt.cloneElement = function (N, Z, ot) { if (N == null) throw Error("The argument must be a React element, but you passed " + N + "."); var ct = j({}, N.props), Et = N.key; if (Z != null) for (Ct in Z.key !== void 0 && (Et = "" + Z.key), Z) !A.call(Z, Ct) || Ct === "key" || Ct === "__self" || Ct === "__source" || Ct === "ref" && Z.ref === void 0 || (ct[Ct] = Z[Ct]); var Ct = arguments.length - 2; if (Ct === 1) ct.children = ot; else if (1 < Ct) { for (var Tt = Array(Ct), ye = 0; ye < Ct; ye++)Tt[ye] = arguments[ye + 2]; ct.children = Tt } return C(N.type, Et, ct) }, Rt.createContext = function (N) { return N = { $$typeof: c, _currentValue: N, _currentValue2: N, _threadCount: 0, Provider: null, Consumer: null }, N.Provider = N, N.Consumer = { $$typeof: u, _context: N }, N }, Rt.createElement = function (N, Z, ot) { var ct, Et = {}, Ct = null; if (Z != null) for (ct in Z.key !== void 0 && (Ct = "" + Z.key), Z) A.call(Z, ct) && ct !== "key" && ct !== "__self" && ct !== "__source" && (Et[ct] = Z[ct]); var Tt = arguments.length - 2; if (Tt === 1) Et.children = ot; else if (1 < Tt) { for (var ye = Array(Tt), $t = 0; $t < Tt; $t++)ye[$t] = arguments[$t + 2]; Et.children = ye } if (N && N.defaultProps) for (ct in Tt = N.defaultProps, Tt) Et[ct] === void 0 && (Et[ct] = Tt[ct]); return C(N, Ct, Et) }, Rt.createRef = function () { return { current: null } }, Rt.forwardRef = function (N) { return { $$typeof: d, render: N } }, Rt.isValidElement = I, Rt.lazy = function (N) { return { $$typeof: v, _payload: { _status: -1, _result: N }, _init: et } }, Rt.memo = function (N, Z) { return { $$typeof: g, type: N, compare: Z === void 0 ? null : Z } }, Rt.startTransition = function (N) { var Z = R.T, ot = {}; R.T = ot; try { var ct = N(), Et = R.S; Et !== null && Et(ot, ct), typeof ct == "object" && ct !== null && typeof ct.then == "function" && ct.then(ht, xt) } catch (Ct) { xt(Ct) } finally { Z !== null && ot.types !== null && (Z.types = ot.types), R.T = Z } }, Rt.unstable_useCacheRefresh = function () { return R.H.useCacheRefresh() }, Rt.use = function (N) { return R.H.use(N) }, Rt.useActionState = function (N, Z, ot) { return R.H.useActionState(N, Z, ot) }, Rt.useCallback = function (N, Z) { return R.H.useCallback(N, Z) }, Rt.useContext = function (N) { return R.H.useContext(N) }, Rt.useDebugValue = function () { }, Rt.useDeferredValue = function (N, Z) { return R.H.useDeferredValue(N, Z) }, Rt.useEffect = function (N, Z) { return R.H.useEffect(N, Z) }, Rt.useEffectEvent = function (N) { return R.H.useEffectEvent(N) }, Rt.useId = function () { return R.H.useId() }, Rt.useImperativeHandle = function (N, Z, ot) { return R.H.useImperativeHandle(N, Z, ot) }, Rt.useInsertionEffect = function (N, Z) { return R.H.useInsertionEffect(N, Z) }, Rt.useLayoutEffect = function (N, Z) { return R.H.useLayoutEffect(N, Z) }, Rt.useMemo = function (N, Z) { return R.H.useMemo(N, Z) }, Rt.useOptimistic = function (N, Z) { return R.H.useOptimistic(N, Z) }, Rt.useReducer = function (N, Z, ot) { return R.H.useReducer(N, Z, ot) }, Rt.useRef = function (N) { return R.H.useRef(N) }, Rt.useState = function (N) { return R.H.useState(N) }, Rt.useSyncExternalStore = function (N, Z, ot) { return R.H.useSyncExternalStore(N, Z, ot) }, Rt.useTransition = function () { return R.H.useTransition() }, Rt.version = "19.2.4", Rt } var h1; function Tg() { return h1 || (h1 = 1, Ym.exports = Fx()), Ym.exports } var J = Tg(); const fr = jx(J); var Km = { exports: {} }, tu = {}, Qm = { exports: {} }, Xm = {}; var f1; function qx() { return f1 || (f1 = 1, (function (e) { function t(Q, rt) { var et = Q.length; Q.push(rt); t: for (; 0 < et;) { var xt = et - 1 >>> 1, Ot = Q[xt]; if (0 < o(Ot, rt)) Q[xt] = rt, Q[et] = Ot, et = xt; else break t } } function i(Q) { return Q.length === 0 ? null : Q[0] } function r(Q) { if (Q.length === 0) return null; var rt = Q[0], et = Q.pop(); if (et !== rt) { Q[0] = et; t: for (var xt = 0, Ot = Q.length, N = Ot >>> 1; xt < N;) { var Z = 2 * (xt + 1) - 1, ot = Q[Z], ct = Z + 1, Et = Q[ct]; if (0 > o(ot, et)) ct < Ot && 0 > o(Et, ot) ? (Q[xt] = Et, Q[ct] = et, xt = ct) : (Q[xt] = ot, Q[Z] = et, xt = Z); else if (ct < Ot && 0 > o(Et, et)) Q[xt] = Et, Q[ct] = et, xt = ct; else break t } } return rt } function o(Q, rt) { var et = Q.sortIndex - rt.sortIndex; return et !== 0 ? et : Q.id - rt.id } if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var u = performance; e.unstable_now = function () { return u.now() } } else { var c = Date, d = c.now(); e.unstable_now = function () { return c.now() - d } } var p = [], g = [], v = 1, b = null, E = 3, x = !1, M = !1, j = !1, z = !1, K = typeof setTimeout == "function" ? setTimeout : null, it = typeof clearTimeout == "function" ? clearTimeout : null, X = typeof setImmediate < "u" ? setImmediate : null; function at(Q) { for (var rt = i(g); rt !== null;) { if (rt.callback === null) r(g); else if (rt.startTime <= Q) r(g), rt.sortIndex = rt.expirationTime, t(p, rt); else break; rt = i(g) } } function lt(Q) { if (j = !1, at(Q), !M) if (i(p) !== null) M = !0, ht || (ht = !0, k()); else { var rt = i(g); rt !== null && Wt(lt, rt.startTime - Q) } } var ht = !1, R = -1, A = 5, C = -1; function O() { return z ? !0 : !(e.unstable_now() - C < A) } function I() { if (z = !1, ht) { var Q = e.unstable_now(); C = Q; var rt = !0; try { t: { M = !1, j && (j = !1, it(R), R = -1), x = !0; var et = E; try { e: { for (at(Q), b = i(p); b !== null && !(b.expirationTime > Q && O());) { var xt = b.callback; if (typeof xt == "function") { b.callback = null, E = b.priorityLevel; var Ot = xt(b.expirationTime <= Q); if (Q = e.unstable_now(), typeof Ot == "function") { b.callback = Ot, at(Q), rt = !0; break e } b === i(p) && r(p), at(Q) } else r(p); b = i(p) } if (b !== null) rt = !0; else { var N = i(g); N !== null && Wt(lt, N.startTime - Q), rt = !1 } } break t } finally { b = null, E = et, x = !1 } rt = void 0 } } finally { rt ? k() : ht = !1 } } } var k; if (typeof X == "function") k = function () { X(I) }; else if (typeof MessageChannel < "u") { var D = new MessageChannel, Yt = D.port2; D.port1.onmessage = I, k = function () { Yt.postMessage(null) } } else k = function () { K(I, 0) }; function Wt(Q, rt) { R = K(function () { Q(e.unstable_now()) }, rt) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (Q) { Q.callback = null }, e.unstable_forceFrameRate = function (Q) { 0 > Q || 125 < Q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : A = 0 < Q ? Math.floor(1e3 / Q) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return E }, e.unstable_next = function (Q) { switch (E) { case 1: case 2: case 3: var rt = 3; break; default: rt = E }var et = E; E = rt; try { return Q() } finally { E = et } }, e.unstable_requestPaint = function () { z = !0 }, e.unstable_runWithPriority = function (Q, rt) { switch (Q) { case 1: case 2: case 3: case 4: case 5: break; default: Q = 3 }var et = E; E = Q; try { return rt() } finally { E = et } }, e.unstable_scheduleCallback = function (Q, rt, et) { var xt = e.unstable_now(); switch (typeof et == "object" && et !== null ? (et = et.delay, et = typeof et == "number" && 0 < et ? xt + et : xt) : et = xt, Q) { case 1: var Ot = -1; break; case 2: Ot = 250; break; case 5: Ot = 1073741823; break; case 4: Ot = 1e4; break; default: Ot = 5e3 }return Ot = et + Ot, Q = { id: v++, callback: rt, priorityLevel: Q, startTime: et, expirationTime: Ot, sortIndex: -1 }, et > xt ? (Q.sortIndex = et, t(g, Q), i(p) === null && Q === i(g) && (j ? (it(R), R = -1) : j = !0, Wt(lt, et - xt))) : (Q.sortIndex = Ot, t(p, Q), M || x || (M = !0, ht || (ht = !0, k()))), Q }, e.unstable_shouldYield = O, e.unstable_wrapCallback = function (Q) { var rt = E; return function () { var et = E; E = rt; try { return Q.apply(this, arguments) } finally { E = et } } } })(Xm)), Xm } var d1; function Hx() { return d1 || (d1 = 1, Qm.exports = qx()), Qm.exports } var Wm = { exports: {} }, on = {}; var m1; function Gx() { if (m1) return on; m1 = 1; var e = Tg(); function t(p) { var g = "https://react.dev/errors/" + p; if (1 < arguments.length) { g += "?args[]=" + encodeURIComponent(arguments[1]); for (var v = 2; v < arguments.length; v++)g += "&args[]=" + encodeURIComponent(arguments[v]) } return "Minified React error #" + p + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function i() { } var r = { d: { f: i, r: function () { throw Error(t(522)) }, D: i, C: i, L: i, m: i, X: i, S: i, M: i }, p: 0, findDOMNode: null }, o = Symbol.for("react.portal"); function u(p, g, v) { var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: o, key: b == null ? null : "" + b, children: p, containerInfo: g, implementation: v } } var c = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function d(p, g) { if (p === "font") return ""; if (typeof g == "string") return g === "use-credentials" ? g : "" } return on.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, on.createPortal = function (p, g) { var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!g || g.nodeType !== 1 && g.nodeType !== 9 && g.nodeType !== 11) throw Error(t(299)); return u(p, g, null, v) }, on.flushSync = function (p) { var g = c.T, v = r.p; try { if (c.T = null, r.p = 2, p) return p() } finally { c.T = g, r.p = v, r.d.f() } }, on.preconnect = function (p, g) { typeof p == "string" && (g ? (g = g.crossOrigin, g = typeof g == "string" ? g === "use-credentials" ? g : "" : void 0) : g = null, r.d.C(p, g)) }, on.prefetchDNS = function (p) { typeof p == "string" && r.d.D(p) }, on.preinit = function (p, g) { if (typeof p == "string" && g && typeof g.as == "string") { var v = g.as, b = d(v, g.crossOrigin), E = typeof g.integrity == "string" ? g.integrity : void 0, x = typeof g.fetchPriority == "string" ? g.fetchPriority : void 0; v === "style" ? r.d.S(p, typeof g.precedence == "string" ? g.precedence : void 0, { crossOrigin: b, integrity: E, fetchPriority: x }) : v === "script" && r.d.X(p, { crossOrigin: b, integrity: E, fetchPriority: x, nonce: typeof g.nonce == "string" ? g.nonce : void 0 }) } }, on.preinitModule = function (p, g) { if (typeof p == "string") if (typeof g == "object" && g !== null) { if (g.as == null || g.as === "script") { var v = d(g.as, g.crossOrigin); r.d.M(p, { crossOrigin: v, integrity: typeof g.integrity == "string" ? g.integrity : void 0, nonce: typeof g.nonce == "string" ? g.nonce : void 0 }) } } else g == null && r.d.M(p) }, on.preload = function (p, g) { if (typeof p == "string" && typeof g == "object" && g !== null && typeof g.as == "string") { var v = g.as, b = d(v, g.crossOrigin); r.d.L(p, v, { crossOrigin: b, integrity: typeof g.integrity == "string" ? g.integrity : void 0, nonce: typeof g.nonce == "string" ? g.nonce : void 0, type: typeof g.type == "string" ? g.type : void 0, fetchPriority: typeof g.fetchPriority == "string" ? g.fetchPriority : void 0, referrerPolicy: typeof g.referrerPolicy == "string" ? g.referrerPolicy : void 0, imageSrcSet: typeof g.imageSrcSet == "string" ? g.imageSrcSet : void 0, imageSizes: typeof g.imageSizes == "string" ? g.imageSizes : void 0, media: typeof g.media == "string" ? g.media : void 0 }) } }, on.preloadModule = function (p, g) { if (typeof p == "string") if (g) { var v = d(g.as, g.crossOrigin); r.d.m(p, { as: typeof g.as == "string" && g.as !== "script" ? g.as : void 0, crossOrigin: v, integrity: typeof g.integrity == "string" ? g.integrity : void 0 }) } else r.d.m(p) }, on.requestFormReset = function (p) { r.d.r(p) }, on.unstable_batchedUpdates = function (p, g) { return p(g) }, on.useFormState = function (p, g, v) { return c.H.useFormState(p, g, v) }, on.useFormStatus = function () { return c.H.useHostTransitionStatus() }, on.version = "19.2.4", on } var p1; function Yx() { if (p1) return Wm.exports; p1 = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), Wm.exports = Gx(), Wm.exports } var g1; function Kx() {
  if (g1) return tu; g1 = 1; var e = Hx(), t = Tg(), i = Yx(); function r(n) { var s = "https://react.dev/errors/" + n; if (1 < arguments.length) { s += "?args[]=" + encodeURIComponent(arguments[1]); for (var a = 2; a < arguments.length; a++)s += "&args[]=" + encodeURIComponent(arguments[a]) } return "Minified React error #" + n + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function o(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function u(n) { var s = n, a = n; if (n.alternate) for (; s.return;)s = s.return; else { n = s; do s = n, (s.flags & 4098) !== 0 && (a = s.return), n = s.return; while (n) } return s.tag === 3 ? a : null } function c(n) { if (n.tag === 13) { var s = n.memoizedState; if (s === null && (n = n.alternate, n !== null && (s = n.memoizedState)), s !== null) return s.dehydrated } return null } function d(n) { if (n.tag === 31) { var s = n.memoizedState; if (s === null && (n = n.alternate, n !== null && (s = n.memoizedState)), s !== null) return s.dehydrated } return null } function p(n) { if (u(n) !== n) throw Error(r(188)) } function g(n) { var s = n.alternate; if (!s) { if (s = u(n), s === null) throw Error(r(188)); return s !== n ? null : n } for (var a = n, l = s; ;) { var f = a.return; if (f === null) break; var m = f.alternate; if (m === null) { if (l = f.return, l !== null) { a = l; continue } break } if (f.child === m.child) { for (m = f.child; m;) { if (m === a) return p(f), n; if (m === l) return p(f), s; m = m.sibling } throw Error(r(188)) } if (a.return !== l.return) a = f, l = m; else { for (var _ = !1, S = f.child; S;) { if (S === a) { _ = !0, a = f, l = m; break } if (S === l) { _ = !0, l = f, a = m; break } S = S.sibling } if (!_) { for (S = m.child; S;) { if (S === a) { _ = !0, a = m, l = f; break } if (S === l) { _ = !0, l = m, a = f; break } S = S.sibling } if (!_) throw Error(r(189)) } } if (a.alternate !== l) throw Error(r(190)) } if (a.tag !== 3) throw Error(r(188)); return a.stateNode.current === a ? n : s } function v(n) { var s = n.tag; if (s === 5 || s === 26 || s === 27 || s === 6) return n; for (n = n.child; n !== null;) { if (s = v(n), s !== null) return s; n = n.sibling } return null } var b = Object.assign, E = Symbol.for("react.element"), x = Symbol.for("react.transitional.element"), M = Symbol.for("react.portal"), j = Symbol.for("react.fragment"), z = Symbol.for("react.strict_mode"), K = Symbol.for("react.profiler"), it = Symbol.for("react.consumer"), X = Symbol.for("react.context"), at = Symbol.for("react.forward_ref"), lt = Symbol.for("react.suspense"), ht = Symbol.for("react.suspense_list"), R = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), C = Symbol.for("react.activity"), O = Symbol.for("react.memo_cache_sentinel"), I = Symbol.iterator; function k(n) { return n === null || typeof n != "object" ? null : (n = I && n[I] || n["@@iterator"], typeof n == "function" ? n : null) } var D = Symbol.for("react.client.reference"); function Yt(n) { if (n == null) return null; if (typeof n == "function") return n.$$typeof === D ? null : n.displayName || n.name || null; if (typeof n == "string") return n; switch (n) { case j: return "Fragment"; case K: return "Profiler"; case z: return "StrictMode"; case lt: return "Suspense"; case ht: return "SuspenseList"; case C: return "Activity" }if (typeof n == "object") switch (n.$$typeof) { case M: return "Portal"; case X: return n.displayName || "Context"; case it: return (n._context.displayName || "Context") + ".Consumer"; case at: var s = n.render; return n = n.displayName, n || (n = s.displayName || s.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case R: return s = n.displayName || null, s !== null ? s : Yt(n.type) || "Memo"; case A: s = n._payload, n = n._init; try { return Yt(n(s)) } catch { } }return null } var Wt = Array.isArray, Q = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, rt = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, et = { pending: !1, data: null, method: null, action: null }, xt = [], Ot = -1; function N(n) { return { current: n } } function Z(n) { 0 > Ot || (n.current = xt[Ot], xt[Ot] = null, Ot--) } function ot(n, s) { Ot++, xt[Ot] = n.current, n.current = s } var ct = N(null), Et = N(null), Ct = N(null), Tt = N(null); function ye(n, s) { switch (ot(Ct, s), ot(Et, n), ot(ct, null), s.nodeType) { case 9: case 11: n = (n = s.documentElement) && (n = n.namespaceURI) ? M_(n) : 0; break; default: if (n = s.tagName, s = s.namespaceURI) s = M_(s), n = I_(s, n); else switch (n) { case "svg": n = 1; break; case "math": n = 2; break; default: n = 0 } }Z(ct), ot(ct, n) } function $t() { Z(ct), Z(Et), Z(Ct) } function kn(n) { n.memoizedState !== null && ot(Tt, n); var s = ct.current, a = I_(s, n.type); s !== a && (ot(Et, n), ot(ct, a)) } function yi(n) { Et.current === n && (Z(ct), Z(Et)), Tt.current === n && (Z(Tt), Xl._currentValue = et) } var Jn, Aa; function vi(n) {
    if (Jn === void 0) try { throw Error() } catch (a) {
      var s = a.stack.trim().match(/\n( *(at )?)/); Jn = s && s[1] || "", Aa = -1 < a.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < a.stack.indexOf("@") ? "@unknown:0:0" : ""
    } return `
`+ Jn + n + Aa
  } var Xo = !1; function Ir(n, s) {
    if (!n || Xo) return ""; Xo = !0; var a = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
      var l = { DetermineComponentFrameRoot: function () { try { if (s) { var tt = function () { throw Error() }; if (Object.defineProperty(tt.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(tt, []) } catch (Y) { var H = Y } Reflect.construct(n, [], tt) } else { try { tt.call() } catch (Y) { H = Y } n.call(tt.prototype) } } else { try { throw Error() } catch (Y) { H = Y } (tt = n()) && typeof tt.catch == "function" && tt.catch(function () { }) } } catch (Y) { if (Y && H && typeof Y.stack == "string") return [Y.stack, H.stack] } return [null, null] } }; l.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var f = Object.getOwnPropertyDescriptor(l.DetermineComponentFrameRoot, "name"); f && f.configurable && Object.defineProperty(l.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var m = l.DetermineComponentFrameRoot(), _ = m[0], S = m[1]; if (_ && S) {
        var V = _.split(`
`), q = S.split(`
`); for (f = l = 0; l < V.length && !V[l].includes("DetermineComponentFrameRoot");)l++; for (; f < q.length && !q[f].includes("DetermineComponentFrameRoot");)f++; if (l === V.length || f === q.length) for (l = V.length - 1, f = q.length - 1; 1 <= l && 0 <= f && V[l] !== q[f];)f--; for (; 1 <= l && 0 <= f; l--, f--)if (V[l] !== q[f]) {
          if (l !== 1 || f !== 1) do if (l--, f--, 0 > f || V[l] !== q[f]) {
            var W = `
`+ V[l].replace(" at new ", " at "); return n.displayName && W.includes("<anonymous>") && (W = W.replace("<anonymous>", n.displayName)), W
          } while (1 <= l && 0 <= f); break
        }
      }
    } finally { Xo = !1, Error.prepareStackTrace = a } return (a = n ? n.displayName || n.name : "") ? vi(a) : ""
  } function Wo(n, s) { switch (n.tag) { case 26: case 27: case 5: return vi(n.type); case 16: return vi("Lazy"); case 13: return n.child !== s && s !== null ? vi("Suspense Fallback") : vi("Suspense"); case 19: return vi("SuspenseList"); case 0: case 15: return Ir(n.type, !1); case 11: return Ir(n.type.render, !1); case 1: return Ir(n.type, !0); case 31: return vi("Activity"); default: return "" } } function $o(n) {
    try { var s = "", a = null; do s += Wo(n, a), a = n, n = n.return; while (n); return s } catch (l) {
      return `
Error generating stack: `+ l.message + `
`+ l.stack
    }
  } var Ce = Object.prototype.hasOwnProperty, Ue = e.unstable_scheduleCallback, Cs = e.unstable_cancelCallback, Kf = e.unstable_shouldYield, Ku = e.unstable_requestPaint, fn = e.unstable_now, Or = e.unstable_getCurrentPriorityLevel, Zo = e.unstable_ImmediatePriority, Jo = e.unstable_UserBlockingPriority, Rs = e.unstable_NormalPriority, Qf = e.unstable_LowPriority, Qu = e.unstable_IdlePriority, Xu = e.log, Wu = e.unstable_setDisableYieldValue, ti = null, Xe = null; function Ln(n) { if (typeof Xu == "function" && Wu(n), Xe && typeof Xe.setStrictMode == "function") try { Xe.setStrictMode(ti, n) } catch { } } var Te = Math.clz32 ? Math.clz32 : Zu, $u = Math.log, wa = Math.LN2; function Zu(n) { return n >>>= 0, n === 0 ? 32 : 31 - ($u(n) / wa | 0) | 0 } var _i = 256, Nr = 262144, Re = 4194304; function bi(n) { var s = n & 42; if (s !== 0) return s; switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: return n & 261888; case 262144: case 524288: case 1048576: case 2097152: return n & 3932160; case 4194304: case 8388608: case 16777216: case 33554432: return n & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return n } } function Ti(n, s, a) { var l = n.pendingLanes; if (l === 0) return 0; var f = 0, m = n.suspendedLanes, _ = n.pingedLanes; n = n.warmLanes; var S = l & 134217727; return S !== 0 ? (l = S & ~m, l !== 0 ? f = bi(l) : (_ &= S, _ !== 0 ? f = bi(_) : a || (a = S & ~n, a !== 0 && (f = bi(a))))) : (S = l & ~m, S !== 0 ? f = bi(S) : _ !== 0 ? f = bi(_) : a || (a = l & ~n, a !== 0 && (f = bi(a)))), f === 0 ? 0 : s !== 0 && s !== f && (s & m) === 0 && (m = f & -f, a = s & -s, m >= a || m === 32 && (a & 4194048) !== 0) ? s : f } function ei(n, s) { return (n.pendingLanes & ~(n.suspendedLanes & ~n.pingedLanes) & s) === 0 } function Xf(n, s) { switch (n) { case 1: case 2: case 4: case 8: case 64: return s + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return s + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Ju() { var n = Re; return Re <<= 1, (Re & 62914560) === 0 && (Re = 4194304), n } function Ei(n) { for (var s = [], a = 0; 31 > a; a++)s.push(n); return s } function Pr(n, s) { n.pendingLanes |= s, s !== 268435456 && (n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0) } function Wf(n, s, a, l, f, m) { var _ = n.pendingLanes; n.pendingLanes = a, n.suspendedLanes = 0, n.pingedLanes = 0, n.warmLanes = 0, n.expiredLanes &= a, n.entangledLanes &= a, n.errorRecoveryDisabledLanes &= a, n.shellSuspendCounter = 0; var S = n.entanglements, V = n.expirationTimes, q = n.hiddenUpdates; for (a = _ & ~a; 0 < a;) { var W = 31 - Te(a), tt = 1 << W; S[W] = 0, V[W] = -1; var H = q[W]; if (H !== null) for (q[W] = null, W = 0; W < H.length; W++) { var Y = H[W]; Y !== null && (Y.lane &= -536870913) } a &= ~tt } l !== 0 && kr(n, l, 0), m !== 0 && f === 0 && n.tag !== 0 && (n.suspendedLanes |= m & ~(_ & ~s)) } function kr(n, s, a) { n.pendingLanes |= s, n.suspendedLanes &= ~s; var l = 31 - Te(s); n.entangledLanes |= s, n.entanglements[l] = n.entanglements[l] | 1073741824 | a & 261930 } function tl(n, s) { var a = n.entangledLanes |= s; for (n = n.entanglements; a;) { var l = 31 - Te(a), f = 1 << l; f & s | n[l] & s && (n[l] |= s), a &= ~f } } function el(n, s) { var a = s & -s; return a = (a & 42) !== 0 ? 1 : Lr(a), (a & (n.suspendedLanes | s)) !== 0 ? 0 : a } function Lr(n) { switch (n) { case 2: n = 1; break; case 8: n = 4; break; case 32: n = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: n = 128; break; case 268435456: n = 134217728; break; default: n = 0 }return n } function Ji(n) { return n &= -n, 2 < n ? 8 < n ? (n & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function tc() { var n = rt.p; return n !== 0 ? n : (n = window.event, n === void 0 ? 32 : e1(n.type)) } function ni(n, s) { var a = rt.p; try { return rt.p = n, s() } finally { rt.p = a } } var ii = Math.random().toString(36).slice(2), De = "__reactFiber$" + ii, Ge = "__reactProps$" + ii, Si = "__reactContainer$" + ii, xa = "__reactEvents$" + ii, $f = "__reactListeners$" + ii, ec = "__reactHandles$" + ii, nc = "__reactResources$" + ii, Ai = "__reactMarker$" + ii; function Ca(n) { delete n[De], delete n[Ge], delete n[xa], delete n[$f], delete n[ec] } function wi(n) { var s = n[De]; if (s) return s; for (var a = n.parentNode; a;) { if (s = a[Si] || a[De]) { if (a = s.alternate, s.child !== null || a !== null && a.child !== null) for (n = j_(n); n !== null;) { if (a = n[De]) return a; n = j_(n) } return s } n = a, a = n.parentNode } return null } function zn(n) { if (n = n[De] || n[Si]) { var s = n.tag; if (s === 5 || s === 6 || s === 13 || s === 31 || s === 26 || s === 27 || s === 3) return n } return null } function xn(n) { var s = n.tag; if (s === 5 || s === 26 || s === 27 || s === 6) return n.stateNode; throw Error(r(33)) } function xi(n) { var s = n[nc]; return s || (s = n[nc] = { hoistableStyles: new Map, hoistableScripts: new Map }), s } function Ve(n) { n[Ai] = !0 } var nl = new Set, il = {}; function Ci(n, s) { Ri(n, s), Ri(n + "Capture", s) } function Ri(n, s) { for (il[n] = s, n = 0; n < s.length; n++)nl.add(s[n]) } var sl = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rl = {}, al = {}; function ic(n) { return Ce.call(al, n) ? !0 : Ce.call(rl, n) ? !1 : sl.test(n) ? al[n] = !0 : (rl[n] = !0, !1) } function Ra(n, s, a) { if (ic(s)) if (a === null) n.removeAttribute(s); else { switch (typeof a) { case "undefined": case "function": case "symbol": n.removeAttribute(s); return; case "boolean": var l = s.toLowerCase().slice(0, 5); if (l !== "data-" && l !== "aria-") { n.removeAttribute(s); return } }n.setAttribute(s, "" + a) } } function Cn(n, s, a) { if (a === null) n.removeAttribute(s); else { switch (typeof a) { case "undefined": case "function": case "symbol": case "boolean": n.removeAttribute(s); return }n.setAttribute(s, "" + a) } } function Me(n, s, a, l) { if (l === null) n.removeAttribute(a); else { switch (typeof l) { case "undefined": case "function": case "symbol": case "boolean": n.removeAttribute(a); return }n.setAttributeNS(s, a, "" + l) } } function Ye(n) { switch (typeof n) { case "bigint": case "boolean": case "number": case "string": case "undefined": return n; case "object": return n; default: return "" } } function Ds(n) { var s = n.type; return (n = n.nodeName) && n.toLowerCase() === "input" && (s === "checkbox" || s === "radio") } function ol(n, s, a) { var l = Object.getOwnPropertyDescriptor(n.constructor.prototype, s); if (!n.hasOwnProperty(s) && typeof l < "u" && typeof l.get == "function" && typeof l.set == "function") { var f = l.get, m = l.set; return Object.defineProperty(n, s, { configurable: !0, get: function () { return f.call(this) }, set: function (_) { a = "" + _, m.call(this, _) } }), Object.defineProperty(n, s, { enumerable: l.enumerable }), { getValue: function () { return a }, setValue: function (_) { a = "" + _ }, stopTracking: function () { n._valueTracker = null, delete n[s] } } } } function Zt(n) { if (!n._valueTracker) { var s = Ds(n) ? "checked" : "value"; n._valueTracker = ol(n, s, "" + n[s]) } } function zr(n) { if (!n) return !1; var s = n._valueTracker; if (!s) return !0; var a = s.getValue(), l = ""; return n && (l = Ds(n) ? n.checked ? "true" : "false" : n.value), n = l, n !== a ? (s.setValue(n), !0) : !1 } function Di(n) { if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null; try { return n.activeElement || n.body } catch { return n.body } } var jr = /[\n"\\]/g; function yn(n) { return n.replace(jr, function (s) { return "\\" + s.charCodeAt(0).toString(16) + " " }) } function Da(n, s, a, l, f, m, _, S) { n.name = "", _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" ? n.type = _ : n.removeAttribute("type"), s != null ? _ === "number" ? (s === 0 && n.value === "" || n.value != s) && (n.value = "" + Ye(s)) : n.value !== "" + Ye(s) && (n.value = "" + Ye(s)) : _ !== "submit" && _ !== "reset" || n.removeAttribute("value"), s != null ? ll(n, _, Ye(s)) : a != null ? ll(n, _, Ye(a)) : l != null && n.removeAttribute("value"), f == null && m != null && (n.defaultChecked = !!m), f != null && (n.checked = f && typeof f != "function" && typeof f != "symbol"), S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" ? n.name = "" + Ye(S) : n.removeAttribute("name") } function sc(n, s, a, l, f, m, _, S) { if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (n.type = m), s != null || a != null) { if (!(m !== "submit" && m !== "reset" || s != null)) { Zt(n); return } a = a != null ? "" + Ye(a) : "", s = s != null ? "" + Ye(s) : a, S || s === n.value || (n.value = s), n.defaultValue = s } l = l ?? f, l = typeof l != "function" && typeof l != "symbol" && !!l, n.checked = S ? n.checked : !!l, n.defaultChecked = !!l, _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" && (n.name = _), Zt(n) } function ll(n, s, a) { s === "number" && Di(n.ownerDocument) === n || n.defaultValue === "" + a || (n.defaultValue = "" + a) } function Vs(n, s, a, l) { if (n = n.options, s) { s = {}; for (var f = 0; f < a.length; f++)s["$" + a[f]] = !0; for (a = 0; a < n.length; a++)f = s.hasOwnProperty("$" + n[a].value), n[a].selected !== f && (n[a].selected = f), f && l && (n[a].defaultSelected = !0) } else { for (a = "" + Ye(a), s = null, f = 0; f < n.length; f++) { if (n[f].value === a) { n[f].selected = !0, l && (n[f].defaultSelected = !0); return } s !== null || n[f].disabled || (s = n[f]) } s !== null && (s.selected = !0) } } function rc(n, s, a) { if (s != null && (s = "" + Ye(s), s !== n.value && (n.value = s), a == null)) { n.defaultValue !== s && (n.defaultValue = s); return } n.defaultValue = a != null ? "" + Ye(a) : "" } function Ms(n, s, a, l) { if (s == null) { if (l != null) { if (a != null) throw Error(r(92)); if (Wt(l)) { if (1 < l.length) throw Error(r(93)); l = l[0] } a = l } a == null && (a = ""), s = a } a = Ye(s), n.defaultValue = a, l = n.textContent, l === a && l !== "" && l !== null && (n.value = l), Zt(n) } function vn(n, s) { if (s) { var a = n.firstChild; if (a && a === n.lastChild && a.nodeType === 3) { a.nodeValue = s; return } } n.textContent = s } var ac = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function ul(n, s, a) { var l = s.indexOf("--") === 0; a == null || typeof a == "boolean" || a === "" ? l ? n.setProperty(s, "") : s === "float" ? n.cssFloat = "" : n[s] = "" : l ? n.setProperty(s, a) : typeof a != "number" || a === 0 || ac.has(s) ? s === "float" ? n.cssFloat = a : n[s] = ("" + a).trim() : n[s] = a + "px" } function cl(n, s, a) { if (s != null && typeof s != "object") throw Error(r(62)); if (n = n.style, a != null) { for (var l in a) !a.hasOwnProperty(l) || s != null && s.hasOwnProperty(l) || (l.indexOf("--") === 0 ? n.setProperty(l, "") : l === "float" ? n.cssFloat = "" : n[l] = ""); for (var f in s) l = s[f], s.hasOwnProperty(f) && a[f] !== l && ul(n, f, l) } else for (var m in s) s.hasOwnProperty(m) && ul(n, m, s[m]) } function Va(n) { if (n.indexOf("-") === -1) return !1; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var oc = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), Is = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function Ma(n) { return Is.test("" + n) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : n } function si() { } var hl = null; function jn(n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } var Os = null, Vi = null; function Ur(n) { var s = zn(n); if (s && (n = s.stateNode)) { var a = n[Ge] || null; t: switch (n = s.stateNode, s.type) { case "input": if (Da(n, a.value, a.defaultValue, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name), s = a.name, a.type === "radio" && s != null) { for (a = n; a.parentNode;)a = a.parentNode; for (a = a.querySelectorAll('input[name="' + yn("" + s) + '"][type="radio"]'), s = 0; s < a.length; s++) { var l = a[s]; if (l !== n && l.form === n.form) { var f = l[Ge] || null; if (!f) throw Error(r(90)); Da(l, f.value, f.defaultValue, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name) } } for (s = 0; s < a.length; s++)l = a[s], l.form === n.form && zr(l) } break t; case "textarea": rc(n, a.value, a.defaultValue); break t; case "select": s = a.value, s != null && Vs(n, !!a.multiple, s, !1) } } } var Ia = !1; function Ns(n, s, a) { if (Ia) return n(s, a); Ia = !0; try { var l = n(s); return l } finally { if (Ia = !1, (Os !== null || Vi !== null) && (th(), Os && (s = Os, n = Vi, Vi = Os = null, Ur(s), n))) for (s = 0; s < n.length; s++)Ur(n[s]) } } function ri(n, s) { var a = n.stateNode; if (a === null) return null; var l = a[Ge] || null; if (l === null) return null; a = l[s]; t: switch (s) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (l = !l.disabled) || (n = n.type, l = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !l; break t; default: n = !1 }if (n) return null; if (a && typeof a != "function") throw Error(r(231, s, typeof a)); return a } var Un = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Br = !1; if (Un) try { var ne = {}; Object.defineProperty(ne, "passive", { get: function () { Br = !0 } }), window.addEventListener("test", ne, ne), window.removeEventListener("test", ne, ne) } catch { Br = !1 } var Mi = null, fl = null, Fr = null; function dl() { if (Fr) return Fr; var n, s = fl, a = s.length, l, f = "value" in Mi ? Mi.value : Mi.textContent, m = f.length; for (n = 0; n < a && s[n] === f[n]; n++); var _ = a - n; for (l = 1; l <= _ && s[a - l] === f[m - l]; l++); return Fr = f.slice(n, 1 < l ? 1 - l : void 0) } function qr(n) { var s = n.keyCode; return "charCode" in n ? (n = n.charCode, n === 0 && s === 13 && (n = 13)) : n = s, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0 } function ts() { return !0 } function ai() { return !1 } function We(n) { function s(a, l, f, m, _) { this._reactName = a, this._targetInst = f, this.type = l, this.nativeEvent = m, this.target = _, this.currentTarget = null; for (var S in n) n.hasOwnProperty(S) && (a = n[S], this[S] = a ? a(m) : m[S]); return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? ts : ai, this.isPropagationStopped = ai, this } return b(s.prototype, { preventDefault: function () { this.defaultPrevented = !0; var a = this.nativeEvent; a && (a.preventDefault ? a.preventDefault() : typeof a.returnValue != "unknown" && (a.returnValue = !1), this.isDefaultPrevented = ts) }, stopPropagation: function () { var a = this.nativeEvent; a && (a.stopPropagation ? a.stopPropagation() : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0), this.isPropagationStopped = ts) }, persist: function () { }, isPersistent: ts }), s } var es = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Ii = We(es), Ps = b({}, es, { view: 0, detail: 0 }), ml = We(Ps), ks, Oa, Oi, Na = b({}, Ps, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ls, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== Oi && (Oi && n.type === "mousemove" ? (ks = n.screenX - Oi.screenX, Oa = n.screenY - Oi.screenY) : Oa = ks = 0, Oi = n), ks) }, movementY: function (n) { return "movementY" in n ? n.movementY : Oa } }), pl = We(Na), Hr = b({}, Na, { dataTransfer: 0 }), lc = We(Hr), uc = b({}, Ps, { relatedTarget: 0 }), Gr = We(uc), gl = b({}, es, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), cc = We(gl), Pa = b({}, es, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } }), hc = We(Pa), fc = b({}, es, { data: 0 }), Ni = We(fc), dc = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, mc = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, pc = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function gc(n) { var s = this.nativeEvent; return s.getModifierState ? s.getModifierState(n) : (n = pc[n]) ? !!s[n] : !1 } function Ls() { return gc } var dn = b({}, Ps, { key: function (n) { if (n.key) { var s = dc[n.key] || n.key; if (s !== "Unidentified") return s } return n.type === "keypress" ? (n = qr(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? mc[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ls, charCode: function (n) { return n.type === "keypress" ? qr(n) : 0 }, keyCode: function (n) { return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 }, which: function (n) { return n.type === "keypress" ? qr(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 } }), yc = We(dn), vc = b({}, Na, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), ns = We(vc), h = b({}, Ps, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ls }), y = We(h), T = b({}, es, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), w = We(T), U = b({}, Na, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), G = We(U), ut = b({}, es, { newState: 0, oldState: 0 }), Vt = We(ut), Ee = [9, 13, 27, 32], Kt = Un && "CompositionEvent" in window, fe = null; Un && "documentMode" in document && (fe = document.documentMode); var Bn = Un && "TextEvent" in window && !fe, Pi = Un && (!Kt || fe && 8 < fe && 11 >= fe), oi = " ", li = !1; function Yr(n, s) { switch (n) { case "keyup": return Ee.indexOf(s.keyCode) !== -1; case "keydown": return s.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function ka(n) { return n = n.detail, typeof n == "object" && "data" in n ? n.data : null } var La = !1; function u2(n, s) { switch (n) { case "compositionend": return ka(s); case "keypress": return s.which !== 32 ? null : (li = !0, oi); case "textInput": return n = s.data, n === oi && li ? null : n; default: return null } } function c2(n, s) { if (La) return n === "compositionend" || !Kt && Yr(n, s) ? (n = dl(), Fr = fl = Mi = null, La = !1, n) : null; switch (n) { case "paste": return null; case "keypress": if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) { if (s.char && 1 < s.char.length) return s.char; if (s.which) return String.fromCharCode(s.which) } return null; case "compositionend": return Pi && s.locale !== "ko" ? null : s.data; default: return null } } var h2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Fy(n) { var s = n && n.nodeName && n.nodeName.toLowerCase(); return s === "input" ? !!h2[n.type] : s === "textarea" } function qy(n, s, a, l) { Os ? Vi ? Vi.push(l) : Vi = [l] : Os = l, s = oh(s, "onChange"), 0 < s.length && (a = new Ii("onChange", "change", null, a, l), n.push({ event: a, listeners: s })) } var yl = null, vl = null; function f2(n) { w_(n, 0) } function _c(n) { var s = xn(n); if (zr(s)) return n } function Hy(n, s) { if (n === "change") return s } var Gy = !1; if (Un) { var Zf; if (Un) { var Jf = "oninput" in document; if (!Jf) { var Yy = document.createElement("div"); Yy.setAttribute("oninput", "return;"), Jf = typeof Yy.oninput == "function" } Zf = Jf } else Zf = !1; Gy = Zf && (!document.documentMode || 9 < document.documentMode) } function Ky() { yl && (yl.detachEvent("onpropertychange", Qy), vl = yl = null) } function Qy(n) { if (n.propertyName === "value" && _c(vl)) { var s = []; qy(s, vl, n, jn(n)), Ns(f2, s) } } function d2(n, s, a) { n === "focusin" ? (Ky(), yl = s, vl = a, yl.attachEvent("onpropertychange", Qy)) : n === "focusout" && Ky() } function m2(n) { if (n === "selectionchange" || n === "keyup" || n === "keydown") return _c(vl) } function p2(n, s) { if (n === "click") return _c(s) } function g2(n, s) { if (n === "input" || n === "change") return _c(s) } function y2(n, s) { return n === s && (n !== 0 || 1 / n === 1 / s) || n !== n && s !== s } var Rn = typeof Object.is == "function" ? Object.is : y2; function _l(n, s) { if (Rn(n, s)) return !0; if (typeof n != "object" || n === null || typeof s != "object" || s === null) return !1; var a = Object.keys(n), l = Object.keys(s); if (a.length !== l.length) return !1; for (l = 0; l < a.length; l++) { var f = a[l]; if (!Ce.call(s, f) || !Rn(n[f], s[f])) return !1 } return !0 } function Xy(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function Wy(n, s) { var a = Xy(n); n = 0; for (var l; a;) { if (a.nodeType === 3) { if (l = n + a.textContent.length, n <= s && l >= s) return { node: a, offset: s - n }; n = l } t: { for (; a;) { if (a.nextSibling) { a = a.nextSibling; break t } a = a.parentNode } a = void 0 } a = Xy(a) } } function $y(n, s) { return n && s ? n === s ? !0 : n && n.nodeType === 3 ? !1 : s && s.nodeType === 3 ? $y(n, s.parentNode) : "contains" in n ? n.contains(s) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(s) & 16) : !1 : !1 } function Zy(n) { n = n != null && n.ownerDocument != null && n.ownerDocument.defaultView != null ? n.ownerDocument.defaultView : window; for (var s = Di(n.document); s instanceof n.HTMLIFrameElement;) { try { var a = typeof s.contentWindow.location.href == "string" } catch { a = !1 } if (a) n = s.contentWindow; else break; s = Di(n.document) } return s } function td(n) { var s = n && n.nodeName && n.nodeName.toLowerCase(); return s && (s === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || s === "textarea" || n.contentEditable === "true") } var v2 = Un && "documentMode" in document && 11 >= document.documentMode, za = null, ed = null, bl = null, nd = !1; function Jy(n, s, a) { var l = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument; nd || za == null || za !== Di(l) || (l = za, "selectionStart" in l && td(l) ? l = { start: l.selectionStart, end: l.selectionEnd } : (l = (l.ownerDocument && l.ownerDocument.defaultView || window).getSelection(), l = { anchorNode: l.anchorNode, anchorOffset: l.anchorOffset, focusNode: l.focusNode, focusOffset: l.focusOffset }), bl && _l(bl, l) || (bl = l, l = oh(ed, "onSelect"), 0 < l.length && (s = new Ii("onSelect", "select", null, s, a), n.push({ event: s, listeners: l }), s.target = za))) } function Kr(n, s) { var a = {}; return a[n.toLowerCase()] = s.toLowerCase(), a["Webkit" + n] = "webkit" + s, a["Moz" + n] = "moz" + s, a } var ja = { animationend: Kr("Animation", "AnimationEnd"), animationiteration: Kr("Animation", "AnimationIteration"), animationstart: Kr("Animation", "AnimationStart"), transitionrun: Kr("Transition", "TransitionRun"), transitionstart: Kr("Transition", "TransitionStart"), transitioncancel: Kr("Transition", "TransitionCancel"), transitionend: Kr("Transition", "TransitionEnd") }, id = {}, t0 = {}; Un && (t0 = document.createElement("div").style, "AnimationEvent" in window || (delete ja.animationend.animation, delete ja.animationiteration.animation, delete ja.animationstart.animation), "TransitionEvent" in window || delete ja.transitionend.transition); function Qr(n) { if (id[n]) return id[n]; if (!ja[n]) return n; var s = ja[n], a; for (a in s) if (s.hasOwnProperty(a) && a in t0) return id[n] = s[a]; return n } var e0 = Qr("animationend"), n0 = Qr("animationiteration"), i0 = Qr("animationstart"), _2 = Qr("transitionrun"), b2 = Qr("transitionstart"), T2 = Qr("transitioncancel"), s0 = Qr("transitionend"), r0 = new Map, sd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); sd.push("scrollEnd"); function ui(n, s) { r0.set(n, s), Ci(s, [n]) } var bc = typeof reportError == "function" ? reportError : function (n) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var s = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof n == "object" && n !== null && typeof n.message == "string" ? String(n.message) : String(n), error: n }); if (!window.dispatchEvent(s)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", n); return } console.error(n) }, Fn = [], Ua = 0, rd = 0; function Tc() { for (var n = Ua, s = rd = Ua = 0; s < n;) { var a = Fn[s]; Fn[s++] = null; var l = Fn[s]; Fn[s++] = null; var f = Fn[s]; Fn[s++] = null; var m = Fn[s]; if (Fn[s++] = null, l !== null && f !== null) { var _ = l.pending; _ === null ? f.next = f : (f.next = _.next, _.next = f), l.pending = f } m !== 0 && a0(a, f, m) } } function Ec(n, s, a, l) { Fn[Ua++] = n, Fn[Ua++] = s, Fn[Ua++] = a, Fn[Ua++] = l, rd |= l, n.lanes |= l, n = n.alternate, n !== null && (n.lanes |= l) } function ad(n, s, a, l) { return Ec(n, s, a, l), Sc(n) } function Xr(n, s) { return Ec(n, null, null, s), Sc(n) } function a0(n, s, a) { n.lanes |= a; var l = n.alternate; l !== null && (l.lanes |= a); for (var f = !1, m = n.return; m !== null;)m.childLanes |= a, l = m.alternate, l !== null && (l.childLanes |= a), m.tag === 22 && (n = m.stateNode, n === null || n._visibility & 1 || (f = !0)), n = m, m = m.return; return n.tag === 3 ? (m = n.stateNode, f && s !== null && (f = 31 - Te(a), n = m.hiddenUpdates, l = n[f], l === null ? n[f] = [s] : l.push(s), s.lane = a | 536870912), m) : null } function Sc(n) { if (50 < Fl) throw Fl = 0, pm = null, Error(r(185)); for (var s = n.return; s !== null;)n = s, s = n.return; return n.tag === 3 ? n.stateNode : null } var Ba = {}; function E2(n, s, a, l) { this.tag = n, this.key = a, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = s, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = l, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Dn(n, s, a, l) { return new E2(n, s, a, l) } function od(n) { return n = n.prototype, !(!n || !n.isReactComponent) } function is(n, s) { var a = n.alternate; return a === null ? (a = Dn(n.tag, s, n.key, n.mode), a.elementType = n.elementType, a.type = n.type, a.stateNode = n.stateNode, a.alternate = n, n.alternate = a) : (a.pendingProps = s, a.type = n.type, a.flags = 0, a.subtreeFlags = 0, a.deletions = null), a.flags = n.flags & 65011712, a.childLanes = n.childLanes, a.lanes = n.lanes, a.child = n.child, a.memoizedProps = n.memoizedProps, a.memoizedState = n.memoizedState, a.updateQueue = n.updateQueue, s = n.dependencies, a.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }, a.sibling = n.sibling, a.index = n.index, a.ref = n.ref, a.refCleanup = n.refCleanup, a } function o0(n, s) { n.flags &= 65011714; var a = n.alternate; return a === null ? (n.childLanes = 0, n.lanes = s, n.child = null, n.subtreeFlags = 0, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null) : (n.childLanes = a.childLanes, n.lanes = a.lanes, n.child = a.child, n.subtreeFlags = 0, n.deletions = null, n.memoizedProps = a.memoizedProps, n.memoizedState = a.memoizedState, n.updateQueue = a.updateQueue, n.type = a.type, s = a.dependencies, n.dependencies = s === null ? null : { lanes: s.lanes, firstContext: s.firstContext }), n } function Ac(n, s, a, l, f, m) { var _ = 0; if (l = n, typeof n == "function") od(n) && (_ = 1); else if (typeof n == "string") _ = Cx(n, a, ct.current) ? 26 : n === "html" || n === "head" || n === "body" ? 27 : 5; else t: switch (n) { case C: return n = Dn(31, a, s, f), n.elementType = C, n.lanes = m, n; case j: return Wr(a.children, f, m, s); case z: _ = 8, f |= 24; break; case K: return n = Dn(12, a, s, f | 2), n.elementType = K, n.lanes = m, n; case lt: return n = Dn(13, a, s, f), n.elementType = lt, n.lanes = m, n; case ht: return n = Dn(19, a, s, f), n.elementType = ht, n.lanes = m, n; default: if (typeof n == "object" && n !== null) switch (n.$$typeof) { case X: _ = 10; break t; case it: _ = 9; break t; case at: _ = 11; break t; case R: _ = 14; break t; case A: _ = 16, l = null; break t }_ = 29, a = Error(r(130, n === null ? "null" : typeof n, "")), l = null }return s = Dn(_, a, s, f), s.elementType = n, s.type = l, s.lanes = m, s } function Wr(n, s, a, l) { return n = Dn(7, n, l, s), n.lanes = a, n } function ld(n, s, a) { return n = Dn(6, n, null, s), n.lanes = a, n } function l0(n) { var s = Dn(18, null, null, 0); return s.stateNode = n, s } function ud(n, s, a) { return s = Dn(4, n.children !== null ? n.children : [], n.key, s), s.lanes = a, s.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, s } var u0 = new WeakMap; function qn(n, s) { if (typeof n == "object" && n !== null) { var a = u0.get(n); return a !== void 0 ? a : (s = { value: n, source: s, stack: $o(s) }, u0.set(n, s), s) } return { value: n, source: s, stack: $o(s) } } var Fa = [], qa = 0, wc = null, Tl = 0, Hn = [], Gn = 0, zs = null, ki = 1, Li = ""; function ss(n, s) { Fa[qa++] = Tl, Fa[qa++] = wc, wc = n, Tl = s } function c0(n, s, a) { Hn[Gn++] = ki, Hn[Gn++] = Li, Hn[Gn++] = zs, zs = n; var l = ki; n = Li; var f = 32 - Te(l) - 1; l &= ~(1 << f), a += 1; var m = 32 - Te(s) + f; if (30 < m) { var _ = f - f % 5; m = (l & (1 << _) - 1).toString(32), l >>= _, f -= _, ki = 1 << 32 - Te(s) + f | a << f | l, Li = m + n } else ki = 1 << m | a << f | l, Li = n } function cd(n) { n.return !== null && (ss(n, 1), c0(n, 1, 0)) } function hd(n) { for (; n === wc;)wc = Fa[--qa], Fa[qa] = null, Tl = Fa[--qa], Fa[qa] = null; for (; n === zs;)zs = Hn[--Gn], Hn[Gn] = null, Li = Hn[--Gn], Hn[Gn] = null, ki = Hn[--Gn], Hn[Gn] = null } function h0(n, s) { Hn[Gn++] = ki, Hn[Gn++] = Li, Hn[Gn++] = zs, ki = s.id, Li = s.overflow, zs = n } var $e = null, ue = null, Bt = !1, js = null, Yn = !1, fd = Error(r(519)); function Us(n) { var s = Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", "")); throw El(qn(s, n)), fd } function f0(n) { var s = n.stateNode, a = n.type, l = n.memoizedProps; switch (s[De] = n, s[Ge] = l, a) { case "dialog": kt("cancel", s), kt("close", s); break; case "iframe": case "object": case "embed": kt("load", s); break; case "video": case "audio": for (a = 0; a < Hl.length; a++)kt(Hl[a], s); break; case "source": kt("error", s); break; case "img": case "image": case "link": kt("error", s), kt("load", s); break; case "details": kt("toggle", s); break; case "input": kt("invalid", s), sc(s, l.value, l.defaultValue, l.checked, l.defaultChecked, l.type, l.name, !0); break; case "select": kt("invalid", s); break; case "textarea": kt("invalid", s), Ms(s, l.value, l.defaultValue, l.children) }a = l.children, typeof a != "string" && typeof a != "number" && typeof a != "bigint" || s.textContent === "" + a || l.suppressHydrationWarning === !0 || D_(s.textContent, a) ? (l.popover != null && (kt("beforetoggle", s), kt("toggle", s)), l.onScroll != null && kt("scroll", s), l.onScrollEnd != null && kt("scrollend", s), l.onClick != null && (s.onclick = si), s = !0) : s = !1, s || Us(n, !0) } function d0(n) { for ($e = n.return; $e;)switch ($e.tag) { case 5: case 31: case 13: Yn = !1; return; case 27: case 3: Yn = !0; return; default: $e = $e.return } } function Ha(n) { if (n !== $e) return !1; if (!Bt) return d0(n), Bt = !0, !1; var s = n.tag, a; if ((a = s !== 3 && s !== 27) && ((a = s === 5) && (a = n.type, a = !(a !== "form" && a !== "button") || Vm(n.type, n.memoizedProps)), a = !a), a && ue && Us(n), d0(n), s === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(r(317)); ue = z_(n) } else if (s === 31) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(r(317)); ue = z_(n) } else s === 27 ? (s = ue, tr(n.type) ? (n = Pm, Pm = null, ue = n) : ue = s) : ue = $e ? Qn(n.stateNode.nextSibling) : null; return !0 } function $r() { ue = $e = null, Bt = !1 } function dd() { var n = js; return n !== null && (En === null ? En = n : En.push.apply(En, n), js = null), n } function El(n) { js === null ? js = [n] : js.push(n) } var md = N(null), Zr = null, rs = null; function Bs(n, s, a) { ot(md, s._currentValue), s._currentValue = a } function as(n) { n._currentValue = md.current, Z(md) } function pd(n, s, a) { for (; n !== null;) { var l = n.alternate; if ((n.childLanes & s) !== s ? (n.childLanes |= s, l !== null && (l.childLanes |= s)) : l !== null && (l.childLanes & s) !== s && (l.childLanes |= s), n === a) break; n = n.return } } function gd(n, s, a, l) { var f = n.child; for (f !== null && (f.return = n); f !== null;) { var m = f.dependencies; if (m !== null) { var _ = f.child; m = m.firstContext; t: for (; m !== null;) { var S = m; m = f; for (var V = 0; V < s.length; V++)if (S.context === s[V]) { m.lanes |= a, S = m.alternate, S !== null && (S.lanes |= a), pd(m.return, a, n), l || (_ = null); break t } m = S.next } } else if (f.tag === 18) { if (_ = f.return, _ === null) throw Error(r(341)); _.lanes |= a, m = _.alternate, m !== null && (m.lanes |= a), pd(_, a, n), _ = null } else _ = f.child; if (_ !== null) _.return = f; else for (_ = f; _ !== null;) { if (_ === n) { _ = null; break } if (f = _.sibling, f !== null) { f.return = _.return, _ = f; break } _ = _.return } f = _ } } function Ga(n, s, a, l) { n = null; for (var f = s, m = !1; f !== null;) { if (!m) { if ((f.flags & 524288) !== 0) m = !0; else if ((f.flags & 262144) !== 0) break } if (f.tag === 10) { var _ = f.alternate; if (_ === null) throw Error(r(387)); if (_ = _.memoizedProps, _ !== null) { var S = f.type; Rn(f.pendingProps.value, _.value) || (n !== null ? n.push(S) : n = [S]) } } else if (f === Tt.current) { if (_ = f.alternate, _ === null) throw Error(r(387)); _.memoizedState.memoizedState !== f.memoizedState.memoizedState && (n !== null ? n.push(Xl) : n = [Xl]) } f = f.return } n !== null && gd(s, n, a, l), s.flags |= 262144 } function xc(n) { for (n = n.firstContext; n !== null;) { if (!Rn(n.context._currentValue, n.memoizedValue)) return !0; n = n.next } return !1 } function Jr(n) { Zr = n, rs = null, n = n.dependencies, n !== null && (n.firstContext = null) } function Ze(n) { return m0(Zr, n) } function Cc(n, s) { return Zr === null && Jr(n), m0(n, s) } function m0(n, s) { var a = s._currentValue; if (s = { context: s, memoizedValue: a, next: null }, rs === null) { if (n === null) throw Error(r(308)); rs = s, n.dependencies = { lanes: 0, firstContext: s }, n.flags |= 524288 } else rs = rs.next = s; return a } var S2 = typeof AbortController < "u" ? AbortController : function () { var n = [], s = this.signal = { aborted: !1, addEventListener: function (a, l) { n.push(l) } }; this.abort = function () { s.aborted = !0, n.forEach(function (a) { return a() }) } }, A2 = e.unstable_scheduleCallback, w2 = e.unstable_NormalPriority, Ie = { $$typeof: X, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function yd() { return { controller: new S2, data: new Map, refCount: 0 } } function Sl(n) { n.refCount--, n.refCount === 0 && A2(w2, function () { n.controller.abort() }) } var Al = null, vd = 0, Ya = 0, Ka = null; function x2(n, s) { if (Al === null) { var a = Al = []; vd = 0, Ya = Tm(), Ka = { status: "pending", value: void 0, then: function (l) { a.push(l) } } } return vd++, s.then(p0, p0), s } function p0() { if (--vd === 0 && Al !== null) { Ka !== null && (Ka.status = "fulfilled"); var n = Al; Al = null, Ya = 0, Ka = null; for (var s = 0; s < n.length; s++)(0, n[s])() } } function C2(n, s) { var a = [], l = { status: "pending", value: null, reason: null, then: function (f) { a.push(f) } }; return n.then(function () { l.status = "fulfilled", l.value = s; for (var f = 0; f < a.length; f++)(0, a[f])(s) }, function (f) { for (l.status = "rejected", l.reason = f, f = 0; f < a.length; f++)(0, a[f])(void 0) }), l } var g0 = Q.S; Q.S = function (n, s) { Jv = fn(), typeof s == "object" && s !== null && typeof s.then == "function" && x2(n, s), g0 !== null && g0(n, s) }; var ta = N(null); function _d() { var n = ta.current; return n !== null ? n : ae.pooledCache } function Rc(n, s) { s === null ? ot(ta, ta.current) : ot(ta, s.pool) } function y0() { var n = _d(); return n === null ? null : { parent: Ie._currentValue, pool: n } } var Qa = Error(r(460)), bd = Error(r(474)), Dc = Error(r(542)), Vc = { then: function () { } }; function v0(n) { return n = n.status, n === "fulfilled" || n === "rejected" } function _0(n, s, a) { switch (a = n[a], a === void 0 ? n.push(s) : a !== s && (s.then(si, si), s = a), s.status) { case "fulfilled": return s.value; case "rejected": throw n = s.reason, T0(n), n; default: if (typeof s.status == "string") s.then(si, si); else { if (n = ae, n !== null && 100 < n.shellSuspendCounter) throw Error(r(482)); n = s, n.status = "pending", n.then(function (l) { if (s.status === "pending") { var f = s; f.status = "fulfilled", f.value = l } }, function (l) { if (s.status === "pending") { var f = s; f.status = "rejected", f.reason = l } }) } switch (s.status) { case "fulfilled": return s.value; case "rejected": throw n = s.reason, T0(n), n }throw na = s, Qa } } function ea(n) { try { var s = n._init; return s(n._payload) } catch (a) { throw a !== null && typeof a == "object" && typeof a.then == "function" ? (na = a, Qa) : a } } var na = null; function b0() { if (na === null) throw Error(r(459)); var n = na; return na = null, n } function T0(n) { if (n === Qa || n === Dc) throw Error(r(483)) } var Xa = null, wl = 0; function Mc(n) { var s = wl; return wl += 1, Xa === null && (Xa = []), _0(Xa, n, s) } function xl(n, s) { s = s.props.ref, n.ref = s !== void 0 ? s : null } function Ic(n, s) { throw s.$$typeof === E ? Error(r(525)) : (n = Object.prototype.toString.call(s), Error(r(31, n === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : n))) } function E0(n) { function s(L, P) { if (n) { var B = L.deletions; B === null ? (L.deletions = [P], L.flags |= 16) : B.push(P) } } function a(L, P) { if (!n) return null; for (; P !== null;)s(L, P), P = P.sibling; return null } function l(L) { for (var P = new Map; L !== null;)L.key !== null ? P.set(L.key, L) : P.set(L.index, L), L = L.sibling; return P } function f(L, P) { return L = is(L, P), L.index = 0, L.sibling = null, L } function m(L, P, B) { return L.index = B, n ? (B = L.alternate, B !== null ? (B = B.index, B < P ? (L.flags |= 67108866, P) : B) : (L.flags |= 67108866, P)) : (L.flags |= 1048576, P) } function _(L) { return n && L.alternate === null && (L.flags |= 67108866), L } function S(L, P, B, $) { return P === null || P.tag !== 6 ? (P = ld(B, L.mode, $), P.return = L, P) : (P = f(P, B), P.return = L, P) } function V(L, P, B, $) { var _t = B.type; return _t === j ? W(L, P, B.props.children, $, B.key) : P !== null && (P.elementType === _t || typeof _t == "object" && _t !== null && _t.$$typeof === A && ea(_t) === P.type) ? (P = f(P, B.props), xl(P, B), P.return = L, P) : (P = Ac(B.type, B.key, B.props, null, L.mode, $), xl(P, B), P.return = L, P) } function q(L, P, B, $) { return P === null || P.tag !== 4 || P.stateNode.containerInfo !== B.containerInfo || P.stateNode.implementation !== B.implementation ? (P = ud(B, L.mode, $), P.return = L, P) : (P = f(P, B.children || []), P.return = L, P) } function W(L, P, B, $, _t) { return P === null || P.tag !== 7 ? (P = Wr(B, L.mode, $, _t), P.return = L, P) : (P = f(P, B), P.return = L, P) } function tt(L, P, B) { if (typeof P == "string" && P !== "" || typeof P == "number" || typeof P == "bigint") return P = ld("" + P, L.mode, B), P.return = L, P; if (typeof P == "object" && P !== null) { switch (P.$$typeof) { case x: return B = Ac(P.type, P.key, P.props, null, L.mode, B), xl(B, P), B.return = L, B; case M: return P = ud(P, L.mode, B), P.return = L, P; case A: return P = ea(P), tt(L, P, B) }if (Wt(P) || k(P)) return P = Wr(P, L.mode, B, null), P.return = L, P; if (typeof P.then == "function") return tt(L, Mc(P), B); if (P.$$typeof === X) return tt(L, Cc(L, P), B); Ic(L, P) } return null } function H(L, P, B, $) { var _t = P !== null ? P.key : null; if (typeof B == "string" && B !== "" || typeof B == "number" || typeof B == "bigint") return _t !== null ? null : S(L, P, "" + B, $); if (typeof B == "object" && B !== null) { switch (B.$$typeof) { case x: return B.key === _t ? V(L, P, B, $) : null; case M: return B.key === _t ? q(L, P, B, $) : null; case A: return B = ea(B), H(L, P, B, $) }if (Wt(B) || k(B)) return _t !== null ? null : W(L, P, B, $, null); if (typeof B.then == "function") return H(L, P, Mc(B), $); if (B.$$typeof === X) return H(L, P, Cc(L, B), $); Ic(L, B) } return null } function Y(L, P, B, $, _t) { if (typeof $ == "string" && $ !== "" || typeof $ == "number" || typeof $ == "bigint") return L = L.get(B) || null, S(P, L, "" + $, _t); if (typeof $ == "object" && $ !== null) { switch ($.$$typeof) { case x: return L = L.get($.key === null ? B : $.key) || null, V(P, L, $, _t); case M: return L = L.get($.key === null ? B : $.key) || null, q(P, L, $, _t); case A: return $ = ea($), Y(L, P, B, $, _t) }if (Wt($) || k($)) return L = L.get(B) || null, W(P, L, $, _t, null); if (typeof $.then == "function") return Y(L, P, B, Mc($), _t); if ($.$$typeof === X) return Y(L, P, B, Cc(P, $), _t); Ic(P, $) } return null } function mt(L, P, B, $) { for (var _t = null, Ht = null, vt = P, It = P = 0, zt = null; vt !== null && It < B.length; It++) { vt.index > It ? (zt = vt, vt = null) : zt = vt.sibling; var Gt = H(L, vt, B[It], $); if (Gt === null) { vt === null && (vt = zt); break } n && vt && Gt.alternate === null && s(L, vt), P = m(Gt, P, It), Ht === null ? _t = Gt : Ht.sibling = Gt, Ht = Gt, vt = zt } if (It === B.length) return a(L, vt), Bt && ss(L, It), _t; if (vt === null) { for (; It < B.length; It++)vt = tt(L, B[It], $), vt !== null && (P = m(vt, P, It), Ht === null ? _t = vt : Ht.sibling = vt, Ht = vt); return Bt && ss(L, It), _t } for (vt = l(vt); It < B.length; It++)zt = Y(vt, L, It, B[It], $), zt !== null && (n && zt.alternate !== null && vt.delete(zt.key === null ? It : zt.key), P = m(zt, P, It), Ht === null ? _t = zt : Ht.sibling = zt, Ht = zt); return n && vt.forEach(function (rr) { return s(L, rr) }), Bt && ss(L, It), _t } function St(L, P, B, $) { if (B == null) throw Error(r(151)); for (var _t = null, Ht = null, vt = P, It = P = 0, zt = null, Gt = B.next(); vt !== null && !Gt.done; It++, Gt = B.next()) { vt.index > It ? (zt = vt, vt = null) : zt = vt.sibling; var rr = H(L, vt, Gt.value, $); if (rr === null) { vt === null && (vt = zt); break } n && vt && rr.alternate === null && s(L, vt), P = m(rr, P, It), Ht === null ? _t = rr : Ht.sibling = rr, Ht = rr, vt = zt } if (Gt.done) return a(L, vt), Bt && ss(L, It), _t; if (vt === null) { for (; !Gt.done; It++, Gt = B.next())Gt = tt(L, Gt.value, $), Gt !== null && (P = m(Gt, P, It), Ht === null ? _t = Gt : Ht.sibling = Gt, Ht = Gt); return Bt && ss(L, It), _t } for (vt = l(vt); !Gt.done; It++, Gt = B.next())Gt = Y(vt, L, It, Gt.value, $), Gt !== null && (n && Gt.alternate !== null && vt.delete(Gt.key === null ? It : Gt.key), P = m(Gt, P, It), Ht === null ? _t = Gt : Ht.sibling = Gt, Ht = Gt); return n && vt.forEach(function (zx) { return s(L, zx) }), Bt && ss(L, It), _t } function re(L, P, B, $) { if (typeof B == "object" && B !== null && B.type === j && B.key === null && (B = B.props.children), typeof B == "object" && B !== null) { switch (B.$$typeof) { case x: t: { for (var _t = B.key; P !== null;) { if (P.key === _t) { if (_t = B.type, _t === j) { if (P.tag === 7) { a(L, P.sibling), $ = f(P, B.props.children), $.return = L, L = $; break t } } else if (P.elementType === _t || typeof _t == "object" && _t !== null && _t.$$typeof === A && ea(_t) === P.type) { a(L, P.sibling), $ = f(P, B.props), xl($, B), $.return = L, L = $; break t } a(L, P); break } else s(L, P); P = P.sibling } B.type === j ? ($ = Wr(B.props.children, L.mode, $, B.key), $.return = L, L = $) : ($ = Ac(B.type, B.key, B.props, null, L.mode, $), xl($, B), $.return = L, L = $) } return _(L); case M: t: { for (_t = B.key; P !== null;) { if (P.key === _t) if (P.tag === 4 && P.stateNode.containerInfo === B.containerInfo && P.stateNode.implementation === B.implementation) { a(L, P.sibling), $ = f(P, B.children || []), $.return = L, L = $; break t } else { a(L, P); break } else s(L, P); P = P.sibling } $ = ud(B, L.mode, $), $.return = L, L = $ } return _(L); case A: return B = ea(B), re(L, P, B, $) }if (Wt(B)) return mt(L, P, B, $); if (k(B)) { if (_t = k(B), typeof _t != "function") throw Error(r(150)); return B = _t.call(B), St(L, P, B, $) } if (typeof B.then == "function") return re(L, P, Mc(B), $); if (B.$$typeof === X) return re(L, P, Cc(L, B), $); Ic(L, B) } return typeof B == "string" && B !== "" || typeof B == "number" || typeof B == "bigint" ? (B = "" + B, P !== null && P.tag === 6 ? (a(L, P.sibling), $ = f(P, B), $.return = L, L = $) : (a(L, P), $ = ld(B, L.mode, $), $.return = L, L = $), _(L)) : a(L, P) } return function (L, P, B, $) { try { wl = 0; var _t = re(L, P, B, $); return Xa = null, _t } catch (vt) { if (vt === Qa || vt === Dc) throw vt; var Ht = Dn(29, vt, null, L.mode); return Ht.lanes = $, Ht.return = L, Ht } } } var ia = E0(!0), S0 = E0(!1), Fs = !1; function Td(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function Ed(n, s) { n = n.updateQueue, s.updateQueue === n && (s.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, callbacks: null }) } function qs(n) { return { lane: n, tag: 0, payload: null, callback: null, next: null } } function Hs(n, s, a) { var l = n.updateQueue; if (l === null) return null; if (l = l.shared, (Qt & 2) !== 0) { var f = l.pending; return f === null ? s.next = s : (s.next = f.next, f.next = s), l.pending = s, s = Sc(n), a0(n, null, a), s } return Ec(n, l, s, a), Sc(n) } function Cl(n, s, a) { if (s = s.updateQueue, s !== null && (s = s.shared, (a & 4194048) !== 0)) { var l = s.lanes; l &= n.pendingLanes, a |= l, s.lanes = a, tl(n, a) } } function Sd(n, s) { var a = n.updateQueue, l = n.alternate; if (l !== null && (l = l.updateQueue, a === l)) { var f = null, m = null; if (a = a.firstBaseUpdate, a !== null) { do { var _ = { lane: a.lane, tag: a.tag, payload: a.payload, callback: null, next: null }; m === null ? f = m = _ : m = m.next = _, a = a.next } while (a !== null); m === null ? f = m = s : m = m.next = s } else f = m = s; a = { baseState: l.baseState, firstBaseUpdate: f, lastBaseUpdate: m, shared: l.shared, callbacks: l.callbacks }, n.updateQueue = a; return } n = a.lastBaseUpdate, n === null ? a.firstBaseUpdate = s : n.next = s, a.lastBaseUpdate = s } var Ad = !1; function Rl() { if (Ad) { var n = Ka; if (n !== null) throw n } } function Dl(n, s, a, l) { Ad = !1; var f = n.updateQueue; Fs = !1; var m = f.firstBaseUpdate, _ = f.lastBaseUpdate, S = f.shared.pending; if (S !== null) { f.shared.pending = null; var V = S, q = V.next; V.next = null, _ === null ? m = q : _.next = q, _ = V; var W = n.alternate; W !== null && (W = W.updateQueue, S = W.lastBaseUpdate, S !== _ && (S === null ? W.firstBaseUpdate = q : S.next = q, W.lastBaseUpdate = V)) } if (m !== null) { var tt = f.baseState; _ = 0, W = q = V = null, S = m; do { var H = S.lane & -536870913, Y = H !== S.lane; if (Y ? (Lt & H) === H : (l & H) === H) { H !== 0 && H === Ya && (Ad = !0), W !== null && (W = W.next = { lane: 0, tag: S.tag, payload: S.payload, callback: null, next: null }); t: { var mt = n, St = S; H = s; var re = a; switch (St.tag) { case 1: if (mt = St.payload, typeof mt == "function") { tt = mt.call(re, tt, H); break t } tt = mt; break t; case 3: mt.flags = mt.flags & -65537 | 128; case 0: if (mt = St.payload, H = typeof mt == "function" ? mt.call(re, tt, H) : mt, H == null) break t; tt = b({}, tt, H); break t; case 2: Fs = !0 } } H = S.callback, H !== null && (n.flags |= 64, Y && (n.flags |= 8192), Y = f.callbacks, Y === null ? f.callbacks = [H] : Y.push(H)) } else Y = { lane: H, tag: S.tag, payload: S.payload, callback: S.callback, next: null }, W === null ? (q = W = Y, V = tt) : W = W.next = Y, _ |= H; if (S = S.next, S === null) { if (S = f.shared.pending, S === null) break; Y = S, S = Y.next, Y.next = null, f.lastBaseUpdate = Y, f.shared.pending = null } } while (!0); W === null && (V = tt), f.baseState = V, f.firstBaseUpdate = q, f.lastBaseUpdate = W, m === null && (f.shared.lanes = 0), Xs |= _, n.lanes = _, n.memoizedState = tt } } function A0(n, s) { if (typeof n != "function") throw Error(r(191, n)); n.call(s) } function w0(n, s) { var a = n.callbacks; if (a !== null) for (n.callbacks = null, n = 0; n < a.length; n++)A0(a[n], s) } var Wa = N(null), Oc = N(0); function x0(n, s) { n = ps, ot(Oc, n), ot(Wa, s), ps = n | s.baseLanes } function wd() { ot(Oc, ps), ot(Wa, Wa.current) } function xd() { ps = Oc.current, Z(Wa), Z(Oc) } var Vn = N(null), Kn = null; function Gs(n) { var s = n.alternate; ot(Se, Se.current & 1), ot(Vn, n), Kn === null && (s === null || Wa.current !== null || s.memoizedState !== null) && (Kn = n) } function Cd(n) { ot(Se, Se.current), ot(Vn, n), Kn === null && (Kn = n) } function C0(n) { n.tag === 22 ? (ot(Se, Se.current), ot(Vn, n), Kn === null && (Kn = n)) : Ys() } function Ys() { ot(Se, Se.current), ot(Vn, Vn.current) } function Mn(n) { Z(Vn), Kn === n && (Kn = null), Z(Se) } var Se = N(0); function Nc(n) { for (var s = n; s !== null;) { if (s.tag === 13) { var a = s.memoizedState; if (a !== null && (a = a.dehydrated, a === null || Om(a) || Nm(a))) return s } else if (s.tag === 19 && (s.memoizedProps.revealOrder === "forwards" || s.memoizedProps.revealOrder === "backwards" || s.memoizedProps.revealOrder === "unstable_legacy-backwards" || s.memoizedProps.revealOrder === "together")) { if ((s.flags & 128) !== 0) return s } else if (s.child !== null) { s.child.return = s, s = s.child; continue } if (s === n) break; for (; s.sibling === null;) { if (s.return === null || s.return === n) return null; s = s.return } s.sibling.return = s.return, s = s.sibling } return null } var os = 0, Mt = null, ie = null, Oe = null, Pc = !1, $a = !1, sa = !1, kc = 0, Vl = 0, Za = null, R2 = 0; function ve() { throw Error(r(321)) } function Rd(n, s) { if (s === null) return !1; for (var a = 0; a < s.length && a < n.length; a++)if (!Rn(n[a], s[a])) return !1; return !0 } function Dd(n, s, a, l, f, m) { return os = m, Mt = s, s.memoizedState = null, s.updateQueue = null, s.lanes = 0, Q.H = n === null || n.memoizedState === null ? cv : Hd, sa = !1, m = a(l, f), sa = !1, $a && (m = D0(s, a, l, f)), R0(n), m } function R0(n) { Q.H = Ol; var s = ie !== null && ie.next !== null; if (os = 0, Oe = ie = Mt = null, Pc = !1, Vl = 0, Za = null, s) throw Error(r(300)); n === null || Ne || (n = n.dependencies, n !== null && xc(n) && (Ne = !0)) } function D0(n, s, a, l) { Mt = n; var f = 0; do { if ($a && (Za = null), Vl = 0, $a = !1, 25 <= f) throw Error(r(301)); if (f += 1, Oe = ie = null, n.updateQueue != null) { var m = n.updateQueue; m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0) } Q.H = hv, m = s(a, l) } while ($a); return m } function D2() { var n = Q.H, s = n.useState()[0]; return s = typeof s.then == "function" ? Ml(s) : s, n = n.useState()[0], (ie !== null ? ie.memoizedState : null) !== n && (Mt.flags |= 1024), s } function Vd() { var n = kc !== 0; return kc = 0, n } function Md(n, s, a) { s.updateQueue = n.updateQueue, s.flags &= -2053, n.lanes &= ~a } function Id(n) { if (Pc) { for (n = n.memoizedState; n !== null;) { var s = n.queue; s !== null && (s.pending = null), n = n.next } Pc = !1 } os = 0, Oe = ie = Mt = null, $a = !1, Vl = kc = 0, Za = null } function mn() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Oe === null ? Mt.memoizedState = Oe = n : Oe = Oe.next = n, Oe } function Ae() { if (ie === null) { var n = Mt.alternate; n = n !== null ? n.memoizedState : null } else n = ie.next; var s = Oe === null ? Mt.memoizedState : Oe.next; if (s !== null) Oe = s, ie = n; else { if (n === null) throw Mt.alternate === null ? Error(r(467)) : Error(r(310)); ie = n, n = { memoizedState: ie.memoizedState, baseState: ie.baseState, baseQueue: ie.baseQueue, queue: ie.queue, next: null }, Oe === null ? Mt.memoizedState = Oe = n : Oe = Oe.next = n } return Oe } function Lc() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function Ml(n) { var s = Vl; return Vl += 1, Za === null && (Za = []), n = _0(Za, n, s), s = Mt, (Oe === null ? s.memoizedState : Oe.next) === null && (s = s.alternate, Q.H = s === null || s.memoizedState === null ? cv : Hd), n } function zc(n) { if (n !== null && typeof n == "object") { if (typeof n.then == "function") return Ml(n); if (n.$$typeof === X) return Ze(n) } throw Error(r(438, String(n))) } function Od(n) { var s = null, a = Mt.updateQueue; if (a !== null && (s = a.memoCache), s == null) { var l = Mt.alternate; l !== null && (l = l.updateQueue, l !== null && (l = l.memoCache, l != null && (s = { data: l.data.map(function (f) { return f.slice() }), index: 0 }))) } if (s == null && (s = { data: [], index: 0 }), a === null && (a = Lc(), Mt.updateQueue = a), a.memoCache = s, a = s.data[s.index], a === void 0) for (a = s.data[s.index] = Array(n), l = 0; l < n; l++)a[l] = O; return s.index++, a } function ls(n, s) { return typeof s == "function" ? s(n) : s } function jc(n) { var s = Ae(); return Nd(s, ie, n) } function Nd(n, s, a) { var l = n.queue; if (l === null) throw Error(r(311)); l.lastRenderedReducer = a; var f = n.baseQueue, m = l.pending; if (m !== null) { if (f !== null) { var _ = f.next; f.next = m.next, m.next = _ } s.baseQueue = f = m, l.pending = null } if (m = n.baseState, f === null) n.memoizedState = m; else { s = f.next; var S = _ = null, V = null, q = s, W = !1; do { var tt = q.lane & -536870913; if (tt !== q.lane ? (Lt & tt) === tt : (os & tt) === tt) { var H = q.revertLane; if (H === 0) V !== null && (V = V.next = { lane: 0, revertLane: 0, gesture: null, action: q.action, hasEagerState: q.hasEagerState, eagerState: q.eagerState, next: null }), tt === Ya && (W = !0); else if ((os & H) === H) { q = q.next, H === Ya && (W = !0); continue } else tt = { lane: 0, revertLane: q.revertLane, gesture: null, action: q.action, hasEagerState: q.hasEagerState, eagerState: q.eagerState, next: null }, V === null ? (S = V = tt, _ = m) : V = V.next = tt, Mt.lanes |= H, Xs |= H; tt = q.action, sa && a(m, tt), m = q.hasEagerState ? q.eagerState : a(m, tt) } else H = { lane: tt, revertLane: q.revertLane, gesture: q.gesture, action: q.action, hasEagerState: q.hasEagerState, eagerState: q.eagerState, next: null }, V === null ? (S = V = H, _ = m) : V = V.next = H, Mt.lanes |= tt, Xs |= tt; q = q.next } while (q !== null && q !== s); if (V === null ? _ = m : V.next = S, !Rn(m, n.memoizedState) && (Ne = !0, W && (a = Ka, a !== null))) throw a; n.memoizedState = m, n.baseState = _, n.baseQueue = V, l.lastRenderedState = m } return f === null && (l.lanes = 0), [n.memoizedState, l.dispatch] } function Pd(n) { var s = Ae(), a = s.queue; if (a === null) throw Error(r(311)); a.lastRenderedReducer = n; var l = a.dispatch, f = a.pending, m = s.memoizedState; if (f !== null) { a.pending = null; var _ = f = f.next; do m = n(m, _.action), _ = _.next; while (_ !== f); Rn(m, s.memoizedState) || (Ne = !0), s.memoizedState = m, s.baseQueue === null && (s.baseState = m), a.lastRenderedState = m } return [m, l] } function V0(n, s, a) { var l = Mt, f = Ae(), m = Bt; if (m) { if (a === void 0) throw Error(r(407)); a = a() } else a = s(); var _ = !Rn((ie || f).memoizedState, a); if (_ && (f.memoizedState = a, Ne = !0), f = f.queue, zd(O0.bind(null, l, f, n), [n]), f.getSnapshot !== s || _ || Oe !== null && Oe.memoizedState.tag & 1) { if (l.flags |= 2048, Ja(9, { destroy: void 0 }, I0.bind(null, l, f, a, s), null), ae === null) throw Error(r(349)); m || (os & 127) !== 0 || M0(l, s, a) } return a } function M0(n, s, a) { n.flags |= 16384, n = { getSnapshot: s, value: a }, s = Mt.updateQueue, s === null ? (s = Lc(), Mt.updateQueue = s, s.stores = [n]) : (a = s.stores, a === null ? s.stores = [n] : a.push(n)) } function I0(n, s, a, l) { s.value = a, s.getSnapshot = l, N0(s) && P0(n) } function O0(n, s, a) { return a(function () { N0(s) && P0(n) }) } function N0(n) { var s = n.getSnapshot; n = n.value; try { var a = s(); return !Rn(n, a) } catch { return !0 } } function P0(n) { var s = Xr(n, 2); s !== null && Sn(s, n, 2) } function kd(n) { var s = mn(); if (typeof n == "function") { var a = n; if (n = a(), sa) { Ln(!0); try { a() } finally { Ln(!1) } } } return s.memoizedState = s.baseState = n, s.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ls, lastRenderedState: n }, s } function k0(n, s, a, l) { return n.baseState = a, Nd(n, ie, typeof l == "function" ? l : ls) } function V2(n, s, a, l, f) { if (Fc(n)) throw Error(r(485)); if (n = s.action, n !== null) { var m = { payload: f, action: n, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (_) { m.listeners.push(_) } }; Q.T !== null ? a(!0) : m.isTransition = !1, l(m), a = s.pending, a === null ? (m.next = s.pending = m, L0(s, m)) : (m.next = a.next, s.pending = a.next = m) } } function L0(n, s) { var a = s.action, l = s.payload, f = n.state; if (s.isTransition) { var m = Q.T, _ = {}; Q.T = _; try { var S = a(f, l), V = Q.S; V !== null && V(_, S), z0(n, s, S) } catch (q) { Ld(n, s, q) } finally { m !== null && _.types !== null && (m.types = _.types), Q.T = m } } else try { m = a(f, l), z0(n, s, m) } catch (q) { Ld(n, s, q) } } function z0(n, s, a) { a !== null && typeof a == "object" && typeof a.then == "function" ? a.then(function (l) { j0(n, s, l) }, function (l) { return Ld(n, s, l) }) : j0(n, s, a) } function j0(n, s, a) { s.status = "fulfilled", s.value = a, U0(s), n.state = a, s = n.pending, s !== null && (a = s.next, a === s ? n.pending = null : (a = a.next, s.next = a, L0(n, a))) } function Ld(n, s, a) { var l = n.pending; if (n.pending = null, l !== null) { l = l.next; do s.status = "rejected", s.reason = a, U0(s), s = s.next; while (s !== l) } n.action = null } function U0(n) { n = n.listeners; for (var s = 0; s < n.length; s++)(0, n[s])() } function B0(n, s) { return s } function F0(n, s) { if (Bt) { var a = ae.formState; if (a !== null) { t: { var l = Mt; if (Bt) { if (ue) { e: { for (var f = ue, m = Yn; f.nodeType !== 8;) { if (!m) { f = null; break e } if (f = Qn(f.nextSibling), f === null) { f = null; break e } } m = f.data, f = m === "F!" || m === "F" ? f : null } if (f) { ue = Qn(f.nextSibling), l = f.data === "F!"; break t } } Us(l) } l = !1 } l && (s = a[0]) } } return a = mn(), a.memoizedState = a.baseState = s, l = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: B0, lastRenderedState: s }, a.queue = l, a = ov.bind(null, Mt, l), l.dispatch = a, l = kd(!1), m = qd.bind(null, Mt, !1, l.queue), l = mn(), f = { state: s, dispatch: null, action: n, pending: null }, l.queue = f, a = V2.bind(null, Mt, f, m, a), f.dispatch = a, l.memoizedState = n, [s, a, !1] } function q0(n) { var s = Ae(); return H0(s, ie, n) } function H0(n, s, a) { if (s = Nd(n, s, B0)[0], n = jc(ls)[0], typeof s == "object" && s !== null && typeof s.then == "function") try { var l = Ml(s) } catch (_) { throw _ === Qa ? Dc : _ } else l = s; s = Ae(); var f = s.queue, m = f.dispatch; return a !== s.memoizedState && (Mt.flags |= 2048, Ja(9, { destroy: void 0 }, M2.bind(null, f, a), null)), [l, m, n] } function M2(n, s) { n.action = s } function G0(n) { var s = Ae(), a = ie; if (a !== null) return H0(s, a, n); Ae(), s = s.memoizedState, a = Ae(); var l = a.queue.dispatch; return a.memoizedState = n, [s, l, !1] } function Ja(n, s, a, l) { return n = { tag: n, create: a, deps: l, inst: s, next: null }, s = Mt.updateQueue, s === null && (s = Lc(), Mt.updateQueue = s), a = s.lastEffect, a === null ? s.lastEffect = n.next = n : (l = a.next, a.next = n, n.next = l, s.lastEffect = n), n } function Y0() { return Ae().memoizedState } function Uc(n, s, a, l) { var f = mn(); Mt.flags |= n, f.memoizedState = Ja(1 | s, { destroy: void 0 }, a, l === void 0 ? null : l) } function Bc(n, s, a, l) { var f = Ae(); l = l === void 0 ? null : l; var m = f.memoizedState.inst; ie !== null && l !== null && Rd(l, ie.memoizedState.deps) ? f.memoizedState = Ja(s, m, a, l) : (Mt.flags |= n, f.memoizedState = Ja(1 | s, m, a, l)) } function K0(n, s) { Uc(8390656, 8, n, s) } function zd(n, s) { Bc(2048, 8, n, s) } function I2(n) { Mt.flags |= 4; var s = Mt.updateQueue; if (s === null) s = Lc(), Mt.updateQueue = s, s.events = [n]; else { var a = s.events; a === null ? s.events = [n] : a.push(n) } } function Q0(n) { var s = Ae().memoizedState; return I2({ ref: s, nextImpl: n }), function () { if ((Qt & 2) !== 0) throw Error(r(440)); return s.impl.apply(void 0, arguments) } } function X0(n, s) { return Bc(4, 2, n, s) } function W0(n, s) { return Bc(4, 4, n, s) } function $0(n, s) { if (typeof s == "function") { n = n(); var a = s(n); return function () { typeof a == "function" ? a() : s(null) } } if (s != null) return n = n(), s.current = n, function () { s.current = null } } function Z0(n, s, a) { a = a != null ? a.concat([n]) : null, Bc(4, 4, $0.bind(null, s, n), a) } function jd() { } function J0(n, s) { var a = Ae(); s = s === void 0 ? null : s; var l = a.memoizedState; return s !== null && Rd(s, l[1]) ? l[0] : (a.memoizedState = [n, s], n) } function tv(n, s) { var a = Ae(); s = s === void 0 ? null : s; var l = a.memoizedState; if (s !== null && Rd(s, l[1])) return l[0]; if (l = n(), sa) { Ln(!0); try { n() } finally { Ln(!1) } } return a.memoizedState = [l, s], l } function Ud(n, s, a) { return a === void 0 || (os & 1073741824) !== 0 && (Lt & 261930) === 0 ? n.memoizedState = s : (n.memoizedState = a, n = e_(), Mt.lanes |= n, Xs |= n, a) } function ev(n, s, a, l) { return Rn(a, s) ? a : Wa.current !== null ? (n = Ud(n, a, l), Rn(n, s) || (Ne = !0), n) : (os & 42) === 0 || (os & 1073741824) !== 0 && (Lt & 261930) === 0 ? (Ne = !0, n.memoizedState = a) : (n = e_(), Mt.lanes |= n, Xs |= n, s) } function nv(n, s, a, l, f) { var m = rt.p; rt.p = m !== 0 && 8 > m ? m : 8; var _ = Q.T, S = {}; Q.T = S, qd(n, !1, s, a); try { var V = f(), q = Q.S; if (q !== null && q(S, V), V !== null && typeof V == "object" && typeof V.then == "function") { var W = C2(V, l); Il(n, s, W, Nn(n)) } else Il(n, s, l, Nn(n)) } catch (tt) { Il(n, s, { then: function () { }, status: "rejected", reason: tt }, Nn()) } finally { rt.p = m, _ !== null && S.types !== null && (_.types = S.types), Q.T = _ } } function O2() { } function Bd(n, s, a, l) { if (n.tag !== 5) throw Error(r(476)); var f = iv(n).queue; nv(n, f, s, et, a === null ? O2 : function () { return sv(n), a(l) }) } function iv(n) { var s = n.memoizedState; if (s !== null) return s; s = { memoizedState: et, baseState: et, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ls, lastRenderedState: et }, next: null }; var a = {}; return s.next = { memoizedState: a, baseState: a, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: ls, lastRenderedState: a }, next: null }, n.memoizedState = s, n = n.alternate, n !== null && (n.memoizedState = s), s } function sv(n) { var s = iv(n); s.next === null && (s = n.alternate.memoizedState), Il(n, s.next.queue, {}, Nn()) } function Fd() { return Ze(Xl) } function rv() { return Ae().memoizedState } function av() { return Ae().memoizedState } function N2(n) { for (var s = n.return; s !== null;) { switch (s.tag) { case 24: case 3: var a = Nn(); n = qs(a); var l = Hs(s, n, a); l !== null && (Sn(l, s, a), Cl(l, s, a)), s = { cache: yd() }, n.payload = s; return }s = s.return } } function P2(n, s, a) { var l = Nn(); a = { lane: l, revertLane: 0, gesture: null, action: a, hasEagerState: !1, eagerState: null, next: null }, Fc(n) ? lv(s, a) : (a = ad(n, s, a, l), a !== null && (Sn(a, n, l), uv(a, s, l))) } function ov(n, s, a) { var l = Nn(); Il(n, s, a, l) } function Il(n, s, a, l) { var f = { lane: l, revertLane: 0, gesture: null, action: a, hasEagerState: !1, eagerState: null, next: null }; if (Fc(n)) lv(s, f); else { var m = n.alternate; if (n.lanes === 0 && (m === null || m.lanes === 0) && (m = s.lastRenderedReducer, m !== null)) try { var _ = s.lastRenderedState, S = m(_, a); if (f.hasEagerState = !0, f.eagerState = S, Rn(S, _)) return Ec(n, s, f, 0), ae === null && Tc(), !1 } catch { } if (a = ad(n, s, f, l), a !== null) return Sn(a, n, l), uv(a, s, l), !0 } return !1 } function qd(n, s, a, l) { if (l = { lane: 2, revertLane: Tm(), gesture: null, action: l, hasEagerState: !1, eagerState: null, next: null }, Fc(n)) { if (s) throw Error(r(479)) } else s = ad(n, a, l, 2), s !== null && Sn(s, n, 2) } function Fc(n) { var s = n.alternate; return n === Mt || s !== null && s === Mt } function lv(n, s) { $a = Pc = !0; var a = n.pending; a === null ? s.next = s : (s.next = a.next, a.next = s), n.pending = s } function uv(n, s, a) { if ((a & 4194048) !== 0) { var l = s.lanes; l &= n.pendingLanes, a |= l, s.lanes = a, tl(n, a) } } var Ol = { readContext: Ze, use: zc, useCallback: ve, useContext: ve, useEffect: ve, useImperativeHandle: ve, useLayoutEffect: ve, useInsertionEffect: ve, useMemo: ve, useReducer: ve, useRef: ve, useState: ve, useDebugValue: ve, useDeferredValue: ve, useTransition: ve, useSyncExternalStore: ve, useId: ve, useHostTransitionStatus: ve, useFormState: ve, useActionState: ve, useOptimistic: ve, useMemoCache: ve, useCacheRefresh: ve }; Ol.useEffectEvent = ve; var cv = { readContext: Ze, use: zc, useCallback: function (n, s) { return mn().memoizedState = [n, s === void 0 ? null : s], n }, useContext: Ze, useEffect: K0, useImperativeHandle: function (n, s, a) { a = a != null ? a.concat([n]) : null, Uc(4194308, 4, $0.bind(null, s, n), a) }, useLayoutEffect: function (n, s) { return Uc(4194308, 4, n, s) }, useInsertionEffect: function (n, s) { Uc(4, 2, n, s) }, useMemo: function (n, s) { var a = mn(); s = s === void 0 ? null : s; var l = n(); if (sa) { Ln(!0); try { n() } finally { Ln(!1) } } return a.memoizedState = [l, s], l }, useReducer: function (n, s, a) { var l = mn(); if (a !== void 0) { var f = a(s); if (sa) { Ln(!0); try { a(s) } finally { Ln(!1) } } } else f = s; return l.memoizedState = l.baseState = f, n = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: f }, l.queue = n, n = n.dispatch = P2.bind(null, Mt, n), [l.memoizedState, n] }, useRef: function (n) { var s = mn(); return n = { current: n }, s.memoizedState = n }, useState: function (n) { n = kd(n); var s = n.queue, a = ov.bind(null, Mt, s); return s.dispatch = a, [n.memoizedState, a] }, useDebugValue: jd, useDeferredValue: function (n, s) { var a = mn(); return Ud(a, n, s) }, useTransition: function () { var n = kd(!1); return n = nv.bind(null, Mt, n.queue, !0, !1), mn().memoizedState = n, [!1, n] }, useSyncExternalStore: function (n, s, a) { var l = Mt, f = mn(); if (Bt) { if (a === void 0) throw Error(r(407)); a = a() } else { if (a = s(), ae === null) throw Error(r(349)); (Lt & 127) !== 0 || M0(l, s, a) } f.memoizedState = a; var m = { value: a, getSnapshot: s }; return f.queue = m, K0(O0.bind(null, l, m, n), [n]), l.flags |= 2048, Ja(9, { destroy: void 0 }, I0.bind(null, l, m, a, s), null), a }, useId: function () { var n = mn(), s = ae.identifierPrefix; if (Bt) { var a = Li, l = ki; a = (l & ~(1 << 32 - Te(l) - 1)).toString(32) + a, s = "_" + s + "R_" + a, a = kc++, 0 < a && (s += "H" + a.toString(32)), s += "_" } else a = R2++, s = "_" + s + "r_" + a.toString(32) + "_"; return n.memoizedState = s }, useHostTransitionStatus: Fd, useFormState: F0, useActionState: F0, useOptimistic: function (n) { var s = mn(); s.memoizedState = s.baseState = n; var a = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return s.queue = a, s = qd.bind(null, Mt, !0, a), a.dispatch = s, [n, s] }, useMemoCache: Od, useCacheRefresh: function () { return mn().memoizedState = N2.bind(null, Mt) }, useEffectEvent: function (n) { var s = mn(), a = { impl: n }; return s.memoizedState = a, function () { if ((Qt & 2) !== 0) throw Error(r(440)); return a.impl.apply(void 0, arguments) } } }, Hd = { readContext: Ze, use: zc, useCallback: J0, useContext: Ze, useEffect: zd, useImperativeHandle: Z0, useInsertionEffect: X0, useLayoutEffect: W0, useMemo: tv, useReducer: jc, useRef: Y0, useState: function () { return jc(ls) }, useDebugValue: jd, useDeferredValue: function (n, s) { var a = Ae(); return ev(a, ie.memoizedState, n, s) }, useTransition: function () { var n = jc(ls)[0], s = Ae().memoizedState; return [typeof n == "boolean" ? n : Ml(n), s] }, useSyncExternalStore: V0, useId: rv, useHostTransitionStatus: Fd, useFormState: q0, useActionState: q0, useOptimistic: function (n, s) { var a = Ae(); return k0(a, ie, n, s) }, useMemoCache: Od, useCacheRefresh: av }; Hd.useEffectEvent = Q0; var hv = { readContext: Ze, use: zc, useCallback: J0, useContext: Ze, useEffect: zd, useImperativeHandle: Z0, useInsertionEffect: X0, useLayoutEffect: W0, useMemo: tv, useReducer: Pd, useRef: Y0, useState: function () { return Pd(ls) }, useDebugValue: jd, useDeferredValue: function (n, s) { var a = Ae(); return ie === null ? Ud(a, n, s) : ev(a, ie.memoizedState, n, s) }, useTransition: function () { var n = Pd(ls)[0], s = Ae().memoizedState; return [typeof n == "boolean" ? n : Ml(n), s] }, useSyncExternalStore: V0, useId: rv, useHostTransitionStatus: Fd, useFormState: G0, useActionState: G0, useOptimistic: function (n, s) { var a = Ae(); return ie !== null ? k0(a, ie, n, s) : (a.baseState = n, [n, a.queue.dispatch]) }, useMemoCache: Od, useCacheRefresh: av }; hv.useEffectEvent = Q0; function Gd(n, s, a, l) { s = n.memoizedState, a = a(l, s), a = a == null ? s : b({}, s, a), n.memoizedState = a, n.lanes === 0 && (n.updateQueue.baseState = a) } var Yd = { enqueueSetState: function (n, s, a) { n = n._reactInternals; var l = Nn(), f = qs(l); f.payload = s, a != null && (f.callback = a), s = Hs(n, f, l), s !== null && (Sn(s, n, l), Cl(s, n, l)) }, enqueueReplaceState: function (n, s, a) { n = n._reactInternals; var l = Nn(), f = qs(l); f.tag = 1, f.payload = s, a != null && (f.callback = a), s = Hs(n, f, l), s !== null && (Sn(s, n, l), Cl(s, n, l)) }, enqueueForceUpdate: function (n, s) { n = n._reactInternals; var a = Nn(), l = qs(a); l.tag = 2, s != null && (l.callback = s), s = Hs(n, l, a), s !== null && (Sn(s, n, a), Cl(s, n, a)) } }; function fv(n, s, a, l, f, m, _) { return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(l, m, _) : s.prototype && s.prototype.isPureReactComponent ? !_l(a, l) || !_l(f, m) : !0 } function dv(n, s, a, l) { n = s.state, typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(a, l), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(a, l), s.state !== n && Yd.enqueueReplaceState(s, s.state, null) } function ra(n, s) { var a = s; if ("ref" in s) { a = {}; for (var l in s) l !== "ref" && (a[l] = s[l]) } if (n = n.defaultProps) { a === s && (a = b({}, a)); for (var f in n) a[f] === void 0 && (a[f] = n[f]) } return a } function mv(n) { bc(n) } function pv(n) { console.error(n) } function gv(n) { bc(n) } function qc(n, s) { try { var a = n.onUncaughtError; a(s.value, { componentStack: s.stack }) } catch (l) { setTimeout(function () { throw l }) } } function yv(n, s, a) { try { var l = n.onCaughtError; l(a.value, { componentStack: a.stack, errorBoundary: s.tag === 1 ? s.stateNode : null }) } catch (f) { setTimeout(function () { throw f }) } } function Kd(n, s, a) { return a = qs(a), a.tag = 3, a.payload = { element: null }, a.callback = function () { qc(n, s) }, a } function vv(n) { return n = qs(n), n.tag = 3, n } function _v(n, s, a, l) { var f = a.type.getDerivedStateFromError; if (typeof f == "function") { var m = l.value; n.payload = function () { return f(m) }, n.callback = function () { yv(s, a, l) } } var _ = a.stateNode; _ !== null && typeof _.componentDidCatch == "function" && (n.callback = function () { yv(s, a, l), typeof f != "function" && (Ws === null ? Ws = new Set([this]) : Ws.add(this)); var S = l.stack; this.componentDidCatch(l.value, { componentStack: S !== null ? S : "" }) }) } function k2(n, s, a, l, f) { if (a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { if (s = a.alternate, s !== null && Ga(s, a, f, !0), a = Vn.current, a !== null) { switch (a.tag) { case 31: case 13: return Kn === null ? eh() : a.alternate === null && _e === 0 && (_e = 3), a.flags &= -257, a.flags |= 65536, a.lanes = f, l === Vc ? a.flags |= 16384 : (s = a.updateQueue, s === null ? a.updateQueue = new Set([l]) : s.add(l), vm(n, l, f)), !1; case 22: return a.flags |= 65536, l === Vc ? a.flags |= 16384 : (s = a.updateQueue, s === null ? (s = { transitions: null, markerInstances: null, retryQueue: new Set([l]) }, a.updateQueue = s) : (a = s.retryQueue, a === null ? s.retryQueue = new Set([l]) : a.add(l)), vm(n, l, f)), !1 }throw Error(r(435, a.tag)) } return vm(n, l, f), eh(), !1 } if (Bt) return s = Vn.current, s !== null ? ((s.flags & 65536) === 0 && (s.flags |= 256), s.flags |= 65536, s.lanes = f, l !== fd && (n = Error(r(422), { cause: l }), El(qn(n, a)))) : (l !== fd && (s = Error(r(423), { cause: l }), El(qn(s, a))), n = n.current.alternate, n.flags |= 65536, f &= -f, n.lanes |= f, l = qn(l, a), f = Kd(n.stateNode, l, f), Sd(n, f), _e !== 4 && (_e = 2)), !1; var m = Error(r(520), { cause: l }); if (m = qn(m, a), Bl === null ? Bl = [m] : Bl.push(m), _e !== 4 && (_e = 2), s === null) return !0; l = qn(l, a), a = s; do { switch (a.tag) { case 3: return a.flags |= 65536, n = f & -f, a.lanes |= n, n = Kd(a.stateNode, l, n), Sd(a, n), !1; case 1: if (s = a.type, m = a.stateNode, (a.flags & 128) === 0 && (typeof s.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (Ws === null || !Ws.has(m)))) return a.flags |= 65536, f &= -f, a.lanes |= f, f = vv(f), _v(f, n, a, l), Sd(a, f), !1 }a = a.return } while (a !== null); return !1 } var Qd = Error(r(461)), Ne = !1; function Je(n, s, a, l) { s.child = n === null ? S0(s, null, a, l) : ia(s, n.child, a, l) } function bv(n, s, a, l, f) { a = a.render; var m = s.ref; if ("ref" in l) { var _ = {}; for (var S in l) S !== "ref" && (_[S] = l[S]) } else _ = l; return Jr(s), l = Dd(n, s, a, _, m, f), S = Vd(), n !== null && !Ne ? (Md(n, s, f), us(n, s, f)) : (Bt && S && cd(s), s.flags |= 1, Je(n, s, l, f), s.child) } function Tv(n, s, a, l, f) { if (n === null) { var m = a.type; return typeof m == "function" && !od(m) && m.defaultProps === void 0 && a.compare === null ? (s.tag = 15, s.type = m, Ev(n, s, m, l, f)) : (n = Ac(a.type, null, l, s, s.mode, f), n.ref = s.ref, n.return = s, s.child = n) } if (m = n.child, !nm(n, f)) { var _ = m.memoizedProps; if (a = a.compare, a = a !== null ? a : _l, a(_, l) && n.ref === s.ref) return us(n, s, f) } return s.flags |= 1, n = is(m, l), n.ref = s.ref, n.return = s, s.child = n } function Ev(n, s, a, l, f) { if (n !== null) { var m = n.memoizedProps; if (_l(m, l) && n.ref === s.ref) if (Ne = !1, s.pendingProps = l = m, nm(n, f)) (n.flags & 131072) !== 0 && (Ne = !0); else return s.lanes = n.lanes, us(n, s, f) } return Xd(n, s, a, l, f) } function Sv(n, s, a, l) { var f = l.children, m = n !== null ? n.memoizedState : null; if (n === null && s.stateNode === null && (s.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), l.mode === "hidden") { if ((s.flags & 128) !== 0) { if (m = m !== null ? m.baseLanes | a : a, n !== null) { for (l = s.child = n.child, f = 0; l !== null;)f = f | l.lanes | l.childLanes, l = l.sibling; l = f & ~m } else l = 0, s.child = null; return Av(n, s, m, a, l) } if ((a & 536870912) !== 0) s.memoizedState = { baseLanes: 0, cachePool: null }, n !== null && Rc(s, m !== null ? m.cachePool : null), m !== null ? x0(s, m) : wd(), C0(s); else return l = s.lanes = 536870912, Av(n, s, m !== null ? m.baseLanes | a : a, a, l) } else m !== null ? (Rc(s, m.cachePool), x0(s, m), Ys(), s.memoizedState = null) : (n !== null && Rc(s, null), wd(), Ys()); return Je(n, s, f, a), s.child } function Nl(n, s) { return n !== null && n.tag === 22 || s.stateNode !== null || (s.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }), s.sibling } function Av(n, s, a, l, f) { var m = _d(); return m = m === null ? null : { parent: Ie._currentValue, pool: m }, s.memoizedState = { baseLanes: a, cachePool: m }, n !== null && Rc(s, null), wd(), C0(s), n !== null && Ga(n, s, l, !0), s.childLanes = f, null } function Hc(n, s) { return s = Yc({ mode: s.mode, children: s.children }, n.mode), s.ref = n.ref, n.child = s, s.return = n, s } function wv(n, s, a) { return ia(s, n.child, null, a), n = Hc(s, s.pendingProps), n.flags |= 2, Mn(s), s.memoizedState = null, n } function L2(n, s, a) { var l = s.pendingProps, f = (s.flags & 128) !== 0; if (s.flags &= -129, n === null) { if (Bt) { if (l.mode === "hidden") return n = Hc(s, l), s.lanes = 536870912, Nl(null, n); if (Cd(s), (n = ue) ? (n = L_(n, Yn), n = n !== null && n.data === "&" ? n : null, n !== null && (s.memoizedState = { dehydrated: n, treeContext: zs !== null ? { id: ki, overflow: Li } : null, retryLane: 536870912, hydrationErrors: null }, a = l0(n), a.return = s, s.child = a, $e = s, ue = null)) : n = null, n === null) throw Us(s); return s.lanes = 536870912, null } return Hc(s, l) } var m = n.memoizedState; if (m !== null) { var _ = m.dehydrated; if (Cd(s), f) if (s.flags & 256) s.flags &= -257, s = wv(n, s, a); else if (s.memoizedState !== null) s.child = n.child, s.flags |= 128, s = null; else throw Error(r(558)); else if (Ne || Ga(n, s, a, !1), f = (a & n.childLanes) !== 0, Ne || f) { if (l = ae, l !== null && (_ = el(l, a), _ !== 0 && _ !== m.retryLane)) throw m.retryLane = _, Xr(n, _), Sn(l, n, _), Qd; eh(), s = wv(n, s, a) } else n = m.treeContext, ue = Qn(_.nextSibling), $e = s, Bt = !0, js = null, Yn = !1, n !== null && h0(s, n), s = Hc(s, l), s.flags |= 4096; return s } return n = is(n.child, { mode: l.mode, children: l.children }), n.ref = s.ref, s.child = n, n.return = s, n } function Gc(n, s) { var a = s.ref; if (a === null) n !== null && n.ref !== null && (s.flags |= 4194816); else { if (typeof a != "function" && typeof a != "object") throw Error(r(284)); (n === null || n.ref !== a) && (s.flags |= 4194816) } } function Xd(n, s, a, l, f) { return Jr(s), a = Dd(n, s, a, l, void 0, f), l = Vd(), n !== null && !Ne ? (Md(n, s, f), us(n, s, f)) : (Bt && l && cd(s), s.flags |= 1, Je(n, s, a, f), s.child) } function xv(n, s, a, l, f, m) { return Jr(s), s.updateQueue = null, a = D0(s, l, a, f), R0(n), l = Vd(), n !== null && !Ne ? (Md(n, s, m), us(n, s, m)) : (Bt && l && cd(s), s.flags |= 1, Je(n, s, a, m), s.child) } function Cv(n, s, a, l, f) { if (Jr(s), s.stateNode === null) { var m = Ba, _ = a.contextType; typeof _ == "object" && _ !== null && (m = Ze(_)), m = new a(l, m), s.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = Yd, s.stateNode = m, m._reactInternals = s, m = s.stateNode, m.props = l, m.state = s.memoizedState, m.refs = {}, Td(s), _ = a.contextType, m.context = typeof _ == "object" && _ !== null ? Ze(_) : Ba, m.state = s.memoizedState, _ = a.getDerivedStateFromProps, typeof _ == "function" && (Gd(s, a, _, l), m.state = s.memoizedState), typeof a.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (_ = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), _ !== m.state && Yd.enqueueReplaceState(m, m.state, null), Dl(s, l, m, f), Rl(), m.state = s.memoizedState), typeof m.componentDidMount == "function" && (s.flags |= 4194308), l = !0 } else if (n === null) { m = s.stateNode; var S = s.memoizedProps, V = ra(a, S); m.props = V; var q = m.context, W = a.contextType; _ = Ba, typeof W == "object" && W !== null && (_ = Ze(W)); var tt = a.getDerivedStateFromProps; W = typeof tt == "function" || typeof m.getSnapshotBeforeUpdate == "function", S = s.pendingProps !== S, W || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (S || q !== _) && dv(s, m, l, _), Fs = !1; var H = s.memoizedState; m.state = H, Dl(s, l, m, f), Rl(), q = s.memoizedState, S || H !== q || Fs ? (typeof tt == "function" && (Gd(s, a, tt, l), q = s.memoizedState), (V = Fs || fv(s, a, V, l, H, q, _)) ? (W || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (s.flags |= 4194308), s.memoizedProps = l, s.memoizedState = q), m.props = l, m.state = q, m.context = _, l = V) : (typeof m.componentDidMount == "function" && (s.flags |= 4194308), l = !1) } else { m = s.stateNode, Ed(n, s), _ = s.memoizedProps, W = ra(a, _), m.props = W, tt = s.pendingProps, H = m.context, q = a.contextType, V = Ba, typeof q == "object" && q !== null && (V = Ze(q)), S = a.getDerivedStateFromProps, (q = typeof S == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (_ !== tt || H !== V) && dv(s, m, l, V), Fs = !1, H = s.memoizedState, m.state = H, Dl(s, l, m, f), Rl(); var Y = s.memoizedState; _ !== tt || H !== Y || Fs || n !== null && n.dependencies !== null && xc(n.dependencies) ? (typeof S == "function" && (Gd(s, a, S, l), Y = s.memoizedState), (W = Fs || fv(s, a, W, l, H, Y, V) || n !== null && n.dependencies !== null && xc(n.dependencies)) ? (q || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(l, Y, V), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(l, Y, V)), typeof m.componentDidUpdate == "function" && (s.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || _ === n.memoizedProps && H === n.memoizedState || (s.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || _ === n.memoizedProps && H === n.memoizedState || (s.flags |= 1024), s.memoizedProps = l, s.memoizedState = Y), m.props = l, m.state = Y, m.context = V, l = W) : (typeof m.componentDidUpdate != "function" || _ === n.memoizedProps && H === n.memoizedState || (s.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || _ === n.memoizedProps && H === n.memoizedState || (s.flags |= 1024), l = !1) } return m = l, Gc(n, s), l = (s.flags & 128) !== 0, m || l ? (m = s.stateNode, a = l && typeof a.getDerivedStateFromError != "function" ? null : m.render(), s.flags |= 1, n !== null && l ? (s.child = ia(s, n.child, null, f), s.child = ia(s, null, a, f)) : Je(n, s, a, f), s.memoizedState = m.state, n = s.child) : n = us(n, s, f), n } function Rv(n, s, a, l) { return $r(), s.flags |= 256, Je(n, s, a, l), s.child } var Wd = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function $d(n) { return { baseLanes: n, cachePool: y0() } } function Zd(n, s, a) { return n = n !== null ? n.childLanes & ~a : 0, s && (n |= On), n } function Dv(n, s, a) { var l = s.pendingProps, f = !1, m = (s.flags & 128) !== 0, _; if ((_ = m) || (_ = n !== null && n.memoizedState === null ? !1 : (Se.current & 2) !== 0), _ && (f = !0, s.flags &= -129), _ = (s.flags & 32) !== 0, s.flags &= -33, n === null) { if (Bt) { if (f ? Gs(s) : Ys(), (n = ue) ? (n = L_(n, Yn), n = n !== null && n.data !== "&" ? n : null, n !== null && (s.memoizedState = { dehydrated: n, treeContext: zs !== null ? { id: ki, overflow: Li } : null, retryLane: 536870912, hydrationErrors: null }, a = l0(n), a.return = s, s.child = a, $e = s, ue = null)) : n = null, n === null) throw Us(s); return Nm(n) ? s.lanes = 32 : s.lanes = 536870912, null } var S = l.children; return l = l.fallback, f ? (Ys(), f = s.mode, S = Yc({ mode: "hidden", children: S }, f), l = Wr(l, f, a, null), S.return = s, l.return = s, S.sibling = l, s.child = S, l = s.child, l.memoizedState = $d(a), l.childLanes = Zd(n, _, a), s.memoizedState = Wd, Nl(null, l)) : (Gs(s), Jd(s, S)) } var V = n.memoizedState; if (V !== null && (S = V.dehydrated, S !== null)) { if (m) s.flags & 256 ? (Gs(s), s.flags &= -257, s = tm(n, s, a)) : s.memoizedState !== null ? (Ys(), s.child = n.child, s.flags |= 128, s = null) : (Ys(), S = l.fallback, f = s.mode, l = Yc({ mode: "visible", children: l.children }, f), S = Wr(S, f, a, null), S.flags |= 2, l.return = s, S.return = s, l.sibling = S, s.child = l, ia(s, n.child, null, a), l = s.child, l.memoizedState = $d(a), l.childLanes = Zd(n, _, a), s.memoizedState = Wd, s = Nl(null, l)); else if (Gs(s), Nm(S)) { if (_ = S.nextSibling && S.nextSibling.dataset, _) var q = _.dgst; _ = q, l = Error(r(419)), l.stack = "", l.digest = _, El({ value: l, source: null, stack: null }), s = tm(n, s, a) } else if (Ne || Ga(n, s, a, !1), _ = (a & n.childLanes) !== 0, Ne || _) { if (_ = ae, _ !== null && (l = el(_, a), l !== 0 && l !== V.retryLane)) throw V.retryLane = l, Xr(n, l), Sn(_, n, l), Qd; Om(S) || eh(), s = tm(n, s, a) } else Om(S) ? (s.flags |= 192, s.child = n.child, s = null) : (n = V.treeContext, ue = Qn(S.nextSibling), $e = s, Bt = !0, js = null, Yn = !1, n !== null && h0(s, n), s = Jd(s, l.children), s.flags |= 4096); return s } return f ? (Ys(), S = l.fallback, f = s.mode, V = n.child, q = V.sibling, l = is(V, { mode: "hidden", children: l.children }), l.subtreeFlags = V.subtreeFlags & 65011712, q !== null ? S = is(q, S) : (S = Wr(S, f, a, null), S.flags |= 2), S.return = s, l.return = s, l.sibling = S, s.child = l, Nl(null, l), l = s.child, S = n.child.memoizedState, S === null ? S = $d(a) : (f = S.cachePool, f !== null ? (V = Ie._currentValue, f = f.parent !== V ? { parent: V, pool: V } : f) : f = y0(), S = { baseLanes: S.baseLanes | a, cachePool: f }), l.memoizedState = S, l.childLanes = Zd(n, _, a), s.memoizedState = Wd, Nl(n.child, l)) : (Gs(s), a = n.child, n = a.sibling, a = is(a, { mode: "visible", children: l.children }), a.return = s, a.sibling = null, n !== null && (_ = s.deletions, _ === null ? (s.deletions = [n], s.flags |= 16) : _.push(n)), s.child = a, s.memoizedState = null, a) } function Jd(n, s) { return s = Yc({ mode: "visible", children: s }, n.mode), s.return = n, n.child = s } function Yc(n, s) { return n = Dn(22, n, null, s), n.lanes = 0, n } function tm(n, s, a) { return ia(s, n.child, null, a), n = Jd(s, s.pendingProps.children), n.flags |= 2, s.memoizedState = null, n } function Vv(n, s, a) { n.lanes |= s; var l = n.alternate; l !== null && (l.lanes |= s), pd(n.return, s, a) } function em(n, s, a, l, f, m) { var _ = n.memoizedState; _ === null ? n.memoizedState = { isBackwards: s, rendering: null, renderingStartTime: 0, last: l, tail: a, tailMode: f, treeForkCount: m } : (_.isBackwards = s, _.rendering = null, _.renderingStartTime = 0, _.last = l, _.tail = a, _.tailMode = f, _.treeForkCount = m) } function Mv(n, s, a) { var l = s.pendingProps, f = l.revealOrder, m = l.tail; l = l.children; var _ = Se.current, S = (_ & 2) !== 0; if (S ? (_ = _ & 1 | 2, s.flags |= 128) : _ &= 1, ot(Se, _), Je(n, s, l, a), l = Bt ? Tl : 0, !S && n !== null && (n.flags & 128) !== 0) t: for (n = s.child; n !== null;) { if (n.tag === 13) n.memoizedState !== null && Vv(n, a, s); else if (n.tag === 19) Vv(n, a, s); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === s) break t; for (; n.sibling === null;) { if (n.return === null || n.return === s) break t; n = n.return } n.sibling.return = n.return, n = n.sibling } switch (f) { case "forwards": for (a = s.child, f = null; a !== null;)n = a.alternate, n !== null && Nc(n) === null && (f = a), a = a.sibling; a = f, a === null ? (f = s.child, s.child = null) : (f = a.sibling, a.sibling = null), em(s, !1, f, a, m, l); break; case "backwards": case "unstable_legacy-backwards": for (a = null, f = s.child, s.child = null; f !== null;) { if (n = f.alternate, n !== null && Nc(n) === null) { s.child = f; break } n = f.sibling, f.sibling = a, a = f, f = n } em(s, !0, a, null, m, l); break; case "together": em(s, !1, null, null, void 0, l); break; default: s.memoizedState = null }return s.child } function us(n, s, a) { if (n !== null && (s.dependencies = n.dependencies), Xs |= s.lanes, (a & s.childLanes) === 0) if (n !== null) { if (Ga(n, s, a, !1), (a & s.childLanes) === 0) return null } else return null; if (n !== null && s.child !== n.child) throw Error(r(153)); if (s.child !== null) { for (n = s.child, a = is(n, n.pendingProps), s.child = a, a.return = s; n.sibling !== null;)n = n.sibling, a = a.sibling = is(n, n.pendingProps), a.return = s; a.sibling = null } return s.child } function nm(n, s) { return (n.lanes & s) !== 0 ? !0 : (n = n.dependencies, !!(n !== null && xc(n))) } function z2(n, s, a) { switch (s.tag) { case 3: ye(s, s.stateNode.containerInfo), Bs(s, Ie, n.memoizedState.cache), $r(); break; case 27: case 5: kn(s); break; case 4: ye(s, s.stateNode.containerInfo); break; case 10: Bs(s, s.type, s.memoizedProps.value); break; case 31: if (s.memoizedState !== null) return s.flags |= 128, Cd(s), null; break; case 13: var l = s.memoizedState; if (l !== null) return l.dehydrated !== null ? (Gs(s), s.flags |= 128, null) : (a & s.child.childLanes) !== 0 ? Dv(n, s, a) : (Gs(s), n = us(n, s, a), n !== null ? n.sibling : null); Gs(s); break; case 19: var f = (n.flags & 128) !== 0; if (l = (a & s.childLanes) !== 0, l || (Ga(n, s, a, !1), l = (a & s.childLanes) !== 0), f) { if (l) return Mv(n, s, a); s.flags |= 128 } if (f = s.memoizedState, f !== null && (f.rendering = null, f.tail = null, f.lastEffect = null), ot(Se, Se.current), l) break; return null; case 22: return s.lanes = 0, Sv(n, s, a, s.pendingProps); case 24: Bs(s, Ie, n.memoizedState.cache) }return us(n, s, a) } function Iv(n, s, a) { if (n !== null) if (n.memoizedProps !== s.pendingProps) Ne = !0; else { if (!nm(n, a) && (s.flags & 128) === 0) return Ne = !1, z2(n, s, a); Ne = (n.flags & 131072) !== 0 } else Ne = !1, Bt && (s.flags & 1048576) !== 0 && c0(s, Tl, s.index); switch (s.lanes = 0, s.tag) { case 16: t: { var l = s.pendingProps; if (n = ea(s.elementType), s.type = n, typeof n == "function") od(n) ? (l = ra(n, l), s.tag = 1, s = Cv(null, s, n, l, a)) : (s.tag = 0, s = Xd(null, s, n, l, a)); else { if (n != null) { var f = n.$$typeof; if (f === at) { s.tag = 11, s = bv(null, s, n, l, a); break t } else if (f === R) { s.tag = 14, s = Tv(null, s, n, l, a); break t } } throw s = Yt(n) || n, Error(r(306, s, "")) } } return s; case 0: return Xd(n, s, s.type, s.pendingProps, a); case 1: return l = s.type, f = ra(l, s.pendingProps), Cv(n, s, l, f, a); case 3: t: { if (ye(s, s.stateNode.containerInfo), n === null) throw Error(r(387)); l = s.pendingProps; var m = s.memoizedState; f = m.element, Ed(n, s), Dl(s, l, null, a); var _ = s.memoizedState; if (l = _.cache, Bs(s, Ie, l), l !== m.cache && gd(s, [Ie], a, !0), Rl(), l = _.element, m.isDehydrated) if (m = { element: l, isDehydrated: !1, cache: _.cache }, s.updateQueue.baseState = m, s.memoizedState = m, s.flags & 256) { s = Rv(n, s, l, a); break t } else if (l !== f) { f = qn(Error(r(424)), s), El(f), s = Rv(n, s, l, a); break t } else for (n = s.stateNode.containerInfo, n.nodeType === 9 ? n = n.body : n = n.nodeName === "HTML" ? n.ownerDocument.body : n, ue = Qn(n.firstChild), $e = s, Bt = !0, js = null, Yn = !0, a = S0(s, null, l, a), s.child = a; a;)a.flags = a.flags & -3 | 4096, a = a.sibling; else { if ($r(), l === f) { s = us(n, s, a); break t } Je(n, s, l, a) } s = s.child } return s; case 26: return Gc(n, s), n === null ? (a = q_(s.type, null, s.pendingProps, null)) ? s.memoizedState = a : Bt || (a = s.type, n = s.pendingProps, l = lh(Ct.current).createElement(a), l[De] = s, l[Ge] = n, tn(l, a, n), Ve(l), s.stateNode = l) : s.memoizedState = q_(s.type, n.memoizedProps, s.pendingProps, n.memoizedState), null; case 27: return kn(s), n === null && Bt && (l = s.stateNode = U_(s.type, s.pendingProps, Ct.current), $e = s, Yn = !0, f = ue, tr(s.type) ? (Pm = f, ue = Qn(l.firstChild)) : ue = f), Je(n, s, s.pendingProps.children, a), Gc(n, s), n === null && (s.flags |= 4194304), s.child; case 5: return n === null && Bt && ((f = l = ue) && (l = mx(l, s.type, s.pendingProps, Yn), l !== null ? (s.stateNode = l, $e = s, ue = Qn(l.firstChild), Yn = !1, f = !0) : f = !1), f || Us(s)), kn(s), f = s.type, m = s.pendingProps, _ = n !== null ? n.memoizedProps : null, l = m.children, Vm(f, m) ? l = null : _ !== null && Vm(f, _) && (s.flags |= 32), s.memoizedState !== null && (f = Dd(n, s, D2, null, null, a), Xl._currentValue = f), Gc(n, s), Je(n, s, l, a), s.child; case 6: return n === null && Bt && ((n = a = ue) && (a = px(a, s.pendingProps, Yn), a !== null ? (s.stateNode = a, $e = s, ue = null, n = !0) : n = !1), n || Us(s)), null; case 13: return Dv(n, s, a); case 4: return ye(s, s.stateNode.containerInfo), l = s.pendingProps, n === null ? s.child = ia(s, null, l, a) : Je(n, s, l, a), s.child; case 11: return bv(n, s, s.type, s.pendingProps, a); case 7: return Je(n, s, s.pendingProps, a), s.child; case 8: return Je(n, s, s.pendingProps.children, a), s.child; case 12: return Je(n, s, s.pendingProps.children, a), s.child; case 10: return l = s.pendingProps, Bs(s, s.type, l.value), Je(n, s, l.children, a), s.child; case 9: return f = s.type._context, l = s.pendingProps.children, Jr(s), f = Ze(f), l = l(f), s.flags |= 1, Je(n, s, l, a), s.child; case 14: return Tv(n, s, s.type, s.pendingProps, a); case 15: return Ev(n, s, s.type, s.pendingProps, a); case 19: return Mv(n, s, a); case 31: return L2(n, s, a); case 22: return Sv(n, s, a, s.pendingProps); case 24: return Jr(s), l = Ze(Ie), n === null ? (f = _d(), f === null && (f = ae, m = yd(), f.pooledCache = m, m.refCount++, m !== null && (f.pooledCacheLanes |= a), f = m), s.memoizedState = { parent: l, cache: f }, Td(s), Bs(s, Ie, f)) : ((n.lanes & a) !== 0 && (Ed(n, s), Dl(s, null, null, a), Rl()), f = n.memoizedState, m = s.memoizedState, f.parent !== l ? (f = { parent: l, cache: l }, s.memoizedState = f, s.lanes === 0 && (s.memoizedState = s.updateQueue.baseState = f), Bs(s, Ie, l)) : (l = m.cache, Bs(s, Ie, l), l !== f.cache && gd(s, [Ie], a, !0))), Je(n, s, s.pendingProps.children, a), s.child; case 29: throw s.pendingProps }throw Error(r(156, s.tag)) } function cs(n) { n.flags |= 4 } function im(n, s, a, l, f) { if ((s = (n.mode & 32) !== 0) && (s = !1), s) { if (n.flags |= 16777216, (f & 335544128) === f) if (n.stateNode.complete) n.flags |= 8192; else if (r_()) n.flags |= 8192; else throw na = Vc, bd } else n.flags &= -16777217 } function Ov(n, s) { if (s.type !== "stylesheet" || (s.state.loading & 4) !== 0) n.flags &= -16777217; else if (n.flags |= 16777216, !Q_(s)) if (r_()) n.flags |= 8192; else throw na = Vc, bd } function Kc(n, s) { s !== null && (n.flags |= 4), n.flags & 16384 && (s = n.tag !== 22 ? Ju() : 536870912, n.lanes |= s, io |= s) } function Pl(n, s) { if (!Bt) switch (n.tailMode) { case "hidden": s = n.tail; for (var a = null; s !== null;)s.alternate !== null && (a = s), s = s.sibling; a === null ? n.tail = null : a.sibling = null; break; case "collapsed": a = n.tail; for (var l = null; a !== null;)a.alternate !== null && (l = a), a = a.sibling; l === null ? s || n.tail === null ? n.tail = null : n.tail.sibling = null : l.sibling = null } } function ce(n) { var s = n.alternate !== null && n.alternate.child === n.child, a = 0, l = 0; if (s) for (var f = n.child; f !== null;)a |= f.lanes | f.childLanes, l |= f.subtreeFlags & 65011712, l |= f.flags & 65011712, f.return = n, f = f.sibling; else for (f = n.child; f !== null;)a |= f.lanes | f.childLanes, l |= f.subtreeFlags, l |= f.flags, f.return = n, f = f.sibling; return n.subtreeFlags |= l, n.childLanes = a, s } function j2(n, s, a) { var l = s.pendingProps; switch (hd(s), s.tag) { case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ce(s), null; case 1: return ce(s), null; case 3: return a = s.stateNode, l = null, n !== null && (l = n.memoizedState.cache), s.memoizedState.cache !== l && (s.flags |= 2048), as(Ie), $t(), a.pendingContext && (a.context = a.pendingContext, a.pendingContext = null), (n === null || n.child === null) && (Ha(s) ? cs(s) : n === null || n.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024, dd())), ce(s), null; case 26: var f = s.type, m = s.memoizedState; return n === null ? (cs(s), m !== null ? (ce(s), Ov(s, m)) : (ce(s), im(s, f, null, l, a))) : m ? m !== n.memoizedState ? (cs(s), ce(s), Ov(s, m)) : (ce(s), s.flags &= -16777217) : (n = n.memoizedProps, n !== l && cs(s), ce(s), im(s, f, n, l, a)), null; case 27: if (yi(s), a = Ct.current, f = s.type, n !== null && s.stateNode != null) n.memoizedProps !== l && cs(s); else { if (!l) { if (s.stateNode === null) throw Error(r(166)); return ce(s), null } n = ct.current, Ha(s) ? f0(s) : (n = U_(f, l, a), s.stateNode = n, cs(s)) } return ce(s), null; case 5: if (yi(s), f = s.type, n !== null && s.stateNode != null) n.memoizedProps !== l && cs(s); else { if (!l) { if (s.stateNode === null) throw Error(r(166)); return ce(s), null } if (m = ct.current, Ha(s)) f0(s); else { var _ = lh(Ct.current); switch (m) { case 1: m = _.createElementNS("http://www.w3.org/2000/svg", f); break; case 2: m = _.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; default: switch (f) { case "svg": m = _.createElementNS("http://www.w3.org/2000/svg", f); break; case "math": m = _.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; case "script": m = _.createElement("div"), m.innerHTML = "<script><\/script>", m = m.removeChild(m.firstChild); break; case "select": m = typeof l.is == "string" ? _.createElement("select", { is: l.is }) : _.createElement("select"), l.multiple ? m.multiple = !0 : l.size && (m.size = l.size); break; default: m = typeof l.is == "string" ? _.createElement(f, { is: l.is }) : _.createElement(f) } }m[De] = s, m[Ge] = l; t: for (_ = s.child; _ !== null;) { if (_.tag === 5 || _.tag === 6) m.appendChild(_.stateNode); else if (_.tag !== 4 && _.tag !== 27 && _.child !== null) { _.child.return = _, _ = _.child; continue } if (_ === s) break t; for (; _.sibling === null;) { if (_.return === null || _.return === s) break t; _ = _.return } _.sibling.return = _.return, _ = _.sibling } s.stateNode = m; t: switch (tn(m, f, l), f) { case "button": case "input": case "select": case "textarea": l = !!l.autoFocus; break t; case "img": l = !0; break t; default: l = !1 }l && cs(s) } } return ce(s), im(s, s.type, n === null ? null : n.memoizedProps, s.pendingProps, a), null; case 6: if (n && s.stateNode != null) n.memoizedProps !== l && cs(s); else { if (typeof l != "string" && s.stateNode === null) throw Error(r(166)); if (n = Ct.current, Ha(s)) { if (n = s.stateNode, a = s.memoizedProps, l = null, f = $e, f !== null) switch (f.tag) { case 27: case 5: l = f.memoizedProps }n[De] = s, n = !!(n.nodeValue === a || l !== null && l.suppressHydrationWarning === !0 || D_(n.nodeValue, a)), n || Us(s, !0) } else n = lh(n).createTextNode(l), n[De] = s, s.stateNode = n } return ce(s), null; case 31: if (a = s.memoizedState, n === null || n.memoizedState !== null) { if (l = Ha(s), a !== null) { if (n === null) { if (!l) throw Error(r(318)); if (n = s.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(r(557)); n[De] = s } else $r(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4; ce(s), n = !1 } else a = dd(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = a), n = !0; if (!n) return s.flags & 256 ? (Mn(s), s) : (Mn(s), null); if ((s.flags & 128) !== 0) throw Error(r(558)) } return ce(s), null; case 13: if (l = s.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (f = Ha(s), l !== null && l.dehydrated !== null) { if (n === null) { if (!f) throw Error(r(318)); if (f = s.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(r(317)); f[De] = s } else $r(), (s.flags & 128) === 0 && (s.memoizedState = null), s.flags |= 4; ce(s), f = !1 } else f = dd(), n !== null && n.memoizedState !== null && (n.memoizedState.hydrationErrors = f), f = !0; if (!f) return s.flags & 256 ? (Mn(s), s) : (Mn(s), null) } return Mn(s), (s.flags & 128) !== 0 ? (s.lanes = a, s) : (a = l !== null, n = n !== null && n.memoizedState !== null, a && (l = s.child, f = null, l.alternate !== null && l.alternate.memoizedState !== null && l.alternate.memoizedState.cachePool !== null && (f = l.alternate.memoizedState.cachePool.pool), m = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), m !== f && (l.flags |= 2048)), a !== n && a && (s.child.flags |= 8192), Kc(s, s.updateQueue), ce(s), null); case 4: return $t(), n === null && wm(s.stateNode.containerInfo), ce(s), null; case 10: return as(s.type), ce(s), null; case 19: if (Z(Se), l = s.memoizedState, l === null) return ce(s), null; if (f = (s.flags & 128) !== 0, m = l.rendering, m === null) if (f) Pl(l, !1); else { if (_e !== 0 || n !== null && (n.flags & 128) !== 0) for (n = s.child; n !== null;) { if (m = Nc(n), m !== null) { for (s.flags |= 128, Pl(l, !1), n = m.updateQueue, s.updateQueue = n, Kc(s, n), s.subtreeFlags = 0, n = a, a = s.child; a !== null;)o0(a, n), a = a.sibling; return ot(Se, Se.current & 1 | 2), Bt && ss(s, l.treeForkCount), s.child } n = n.sibling } l.tail !== null && fn() > Zc && (s.flags |= 128, f = !0, Pl(l, !1), s.lanes = 4194304) } else { if (!f) if (n = Nc(m), n !== null) { if (s.flags |= 128, f = !0, n = n.updateQueue, s.updateQueue = n, Kc(s, n), Pl(l, !0), l.tail === null && l.tailMode === "hidden" && !m.alternate && !Bt) return ce(s), null } else 2 * fn() - l.renderingStartTime > Zc && a !== 536870912 && (s.flags |= 128, f = !0, Pl(l, !1), s.lanes = 4194304); l.isBackwards ? (m.sibling = s.child, s.child = m) : (n = l.last, n !== null ? n.sibling = m : s.child = m, l.last = m) } return l.tail !== null ? (n = l.tail, l.rendering = n, l.tail = n.sibling, l.renderingStartTime = fn(), n.sibling = null, a = Se.current, ot(Se, f ? a & 1 | 2 : a & 1), Bt && ss(s, l.treeForkCount), n) : (ce(s), null); case 22: case 23: return Mn(s), xd(), l = s.memoizedState !== null, n !== null ? n.memoizedState !== null !== l && (s.flags |= 8192) : l && (s.flags |= 8192), l ? (a & 536870912) !== 0 && (s.flags & 128) === 0 && (ce(s), s.subtreeFlags & 6 && (s.flags |= 8192)) : ce(s), a = s.updateQueue, a !== null && Kc(s, a.retryQueue), a = null, n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (a = n.memoizedState.cachePool.pool), l = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (l = s.memoizedState.cachePool.pool), l !== a && (s.flags |= 2048), n !== null && Z(ta), null; case 24: return a = null, n !== null && (a = n.memoizedState.cache), s.memoizedState.cache !== a && (s.flags |= 2048), as(Ie), ce(s), null; case 25: return null; case 30: return null }throw Error(r(156, s.tag)) } function U2(n, s) { switch (hd(s), s.tag) { case 1: return n = s.flags, n & 65536 ? (s.flags = n & -65537 | 128, s) : null; case 3: return as(Ie), $t(), n = s.flags, (n & 65536) !== 0 && (n & 128) === 0 ? (s.flags = n & -65537 | 128, s) : null; case 26: case 27: case 5: return yi(s), null; case 31: if (s.memoizedState !== null) { if (Mn(s), s.alternate === null) throw Error(r(340)); $r() } return n = s.flags, n & 65536 ? (s.flags = n & -65537 | 128, s) : null; case 13: if (Mn(s), n = s.memoizedState, n !== null && n.dehydrated !== null) { if (s.alternate === null) throw Error(r(340)); $r() } return n = s.flags, n & 65536 ? (s.flags = n & -65537 | 128, s) : null; case 19: return Z(Se), null; case 4: return $t(), null; case 10: return as(s.type), null; case 22: case 23: return Mn(s), xd(), n !== null && Z(ta), n = s.flags, n & 65536 ? (s.flags = n & -65537 | 128, s) : null; case 24: return as(Ie), null; case 25: return null; default: return null } } function Nv(n, s) { switch (hd(s), s.tag) { case 3: as(Ie), $t(); break; case 26: case 27: case 5: yi(s); break; case 4: $t(); break; case 31: s.memoizedState !== null && Mn(s); break; case 13: Mn(s); break; case 19: Z(Se); break; case 10: as(s.type); break; case 22: case 23: Mn(s), xd(), n !== null && Z(ta); break; case 24: as(Ie) } } function kl(n, s) { try { var a = s.updateQueue, l = a !== null ? a.lastEffect : null; if (l !== null) { var f = l.next; a = f; do { if ((a.tag & n) === n) { l = void 0; var m = a.create, _ = a.inst; l = m(), _.destroy = l } a = a.next } while (a !== f) } } catch (S) { te(s, s.return, S) } } function Ks(n, s, a) { try { var l = s.updateQueue, f = l !== null ? l.lastEffect : null; if (f !== null) { var m = f.next; l = m; do { if ((l.tag & n) === n) { var _ = l.inst, S = _.destroy; if (S !== void 0) { _.destroy = void 0, f = s; var V = a, q = S; try { q() } catch (W) { te(f, V, W) } } } l = l.next } while (l !== m) } } catch (W) { te(s, s.return, W) } } function Pv(n) { var s = n.updateQueue; if (s !== null) { var a = n.stateNode; try { w0(s, a) } catch (l) { te(n, n.return, l) } } } function kv(n, s, a) { a.props = ra(n.type, n.memoizedProps), a.state = n.memoizedState; try { a.componentWillUnmount() } catch (l) { te(n, s, l) } } function Ll(n, s) { try { var a = n.ref; if (a !== null) { switch (n.tag) { case 26: case 27: case 5: var l = n.stateNode; break; case 30: l = n.stateNode; break; default: l = n.stateNode }typeof a == "function" ? n.refCleanup = a(l) : a.current = l } } catch (f) { te(n, s, f) } } function zi(n, s) { var a = n.ref, l = n.refCleanup; if (a !== null) if (typeof l == "function") try { l() } catch (f) { te(n, s, f) } finally { n.refCleanup = null, n = n.alternate, n != null && (n.refCleanup = null) } else if (typeof a == "function") try { a(null) } catch (f) { te(n, s, f) } else a.current = null } function Lv(n) { var s = n.type, a = n.memoizedProps, l = n.stateNode; try { t: switch (s) { case "button": case "input": case "select": case "textarea": a.autoFocus && l.focus(); break t; case "img": a.src ? l.src = a.src : a.srcSet && (l.srcset = a.srcSet) } } catch (f) { te(n, n.return, f) } } function sm(n, s, a) { try { var l = n.stateNode; lx(l, n.type, a, s), l[Ge] = s } catch (f) { te(n, n.return, f) } } function zv(n) { return n.tag === 5 || n.tag === 3 || n.tag === 26 || n.tag === 27 && tr(n.type) || n.tag === 4 } function rm(n) { t: for (; ;) { for (; n.sibling === null;) { if (n.return === null || zv(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.tag === 27 && tr(n.type) || n.flags & 2 || n.child === null || n.tag === 4) continue t; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function am(n, s, a) { var l = n.tag; if (l === 5 || l === 6) n = n.stateNode, s ? (a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a).insertBefore(n, s) : (s = a.nodeType === 9 ? a.body : a.nodeName === "HTML" ? a.ownerDocument.body : a, s.appendChild(n), a = a._reactRootContainer, a != null || s.onclick !== null || (s.onclick = si)); else if (l !== 4 && (l === 27 && tr(n.type) && (a = n.stateNode, s = null), n = n.child, n !== null)) for (am(n, s, a), n = n.sibling; n !== null;)am(n, s, a), n = n.sibling } function Qc(n, s, a) { var l = n.tag; if (l === 5 || l === 6) n = n.stateNode, s ? a.insertBefore(n, s) : a.appendChild(n); else if (l !== 4 && (l === 27 && tr(n.type) && (a = n.stateNode), n = n.child, n !== null)) for (Qc(n, s, a), n = n.sibling; n !== null;)Qc(n, s, a), n = n.sibling } function jv(n) { var s = n.stateNode, a = n.memoizedProps; try { for (var l = n.type, f = s.attributes; f.length;)s.removeAttributeNode(f[0]); tn(s, l, a), s[De] = n, s[Ge] = a } catch (m) { te(n, n.return, m) } } var hs = !1, Pe = !1, om = !1, Uv = typeof WeakSet == "function" ? WeakSet : Set, Ke = null; function B2(n, s) { if (n = n.containerInfo, Rm = ph, n = Zy(n), td(n)) { if ("selectionStart" in n) var a = { start: n.selectionStart, end: n.selectionEnd }; else t: { a = (a = n.ownerDocument) && a.defaultView || window; var l = a.getSelection && a.getSelection(); if (l && l.rangeCount !== 0) { a = l.anchorNode; var f = l.anchorOffset, m = l.focusNode; l = l.focusOffset; try { a.nodeType, m.nodeType } catch { a = null; break t } var _ = 0, S = -1, V = -1, q = 0, W = 0, tt = n, H = null; e: for (; ;) { for (var Y; tt !== a || f !== 0 && tt.nodeType !== 3 || (S = _ + f), tt !== m || l !== 0 && tt.nodeType !== 3 || (V = _ + l), tt.nodeType === 3 && (_ += tt.nodeValue.length), (Y = tt.firstChild) !== null;)H = tt, tt = Y; for (; ;) { if (tt === n) break e; if (H === a && ++q === f && (S = _), H === m && ++W === l && (V = _), (Y = tt.nextSibling) !== null) break; tt = H, H = tt.parentNode } tt = Y } a = S === -1 || V === -1 ? null : { start: S, end: V } } else a = null } a = a || { start: 0, end: 0 } } else a = null; for (Dm = { focusedElem: n, selectionRange: a }, ph = !1, Ke = s; Ke !== null;)if (s = Ke, n = s.child, (s.subtreeFlags & 1028) !== 0 && n !== null) n.return = s, Ke = n; else for (; Ke !== null;) { switch (s = Ke, m = s.alternate, n = s.flags, s.tag) { case 0: if ((n & 4) !== 0 && (n = s.updateQueue, n = n !== null ? n.events : null, n !== null)) for (a = 0; a < n.length; a++)f = n[a], f.ref.impl = f.nextImpl; break; case 11: case 15: break; case 1: if ((n & 1024) !== 0 && m !== null) { n = void 0, a = s, f = m.memoizedProps, m = m.memoizedState, l = a.stateNode; try { var mt = ra(a.type, f); n = l.getSnapshotBeforeUpdate(mt, m), l.__reactInternalSnapshotBeforeUpdate = n } catch (St) { te(a, a.return, St) } } break; case 3: if ((n & 1024) !== 0) { if (n = s.stateNode.containerInfo, a = n.nodeType, a === 9) Im(n); else if (a === 1) switch (n.nodeName) { case "HEAD": case "HTML": case "BODY": Im(n); break; default: n.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((n & 1024) !== 0) throw Error(r(163)) }if (n = s.sibling, n !== null) { n.return = s.return, Ke = n; break } Ke = s.return } } function Bv(n, s, a) { var l = a.flags; switch (a.tag) { case 0: case 11: case 15: ds(n, a), l & 4 && kl(5, a); break; case 1: if (ds(n, a), l & 4) if (n = a.stateNode, s === null) try { n.componentDidMount() } catch (_) { te(a, a.return, _) } else { var f = ra(a.type, s.memoizedProps); s = s.memoizedState; try { n.componentDidUpdate(f, s, n.__reactInternalSnapshotBeforeUpdate) } catch (_) { te(a, a.return, _) } } l & 64 && Pv(a), l & 512 && Ll(a, a.return); break; case 3: if (ds(n, a), l & 64 && (n = a.updateQueue, n !== null)) { if (s = null, a.child !== null) switch (a.child.tag) { case 27: case 5: s = a.child.stateNode; break; case 1: s = a.child.stateNode }try { w0(n, s) } catch (_) { te(a, a.return, _) } } break; case 27: s === null && l & 4 && jv(a); case 26: case 5: ds(n, a), s === null && l & 4 && Lv(a), l & 512 && Ll(a, a.return); break; case 12: ds(n, a); break; case 31: ds(n, a), l & 4 && Hv(n, a); break; case 13: ds(n, a), l & 4 && Gv(n, a), l & 64 && (n = a.memoizedState, n !== null && (n = n.dehydrated, n !== null && (a = W2.bind(null, a), gx(n, a)))); break; case 22: if (l = a.memoizedState !== null || hs, !l) { s = s !== null && s.memoizedState !== null || Pe, f = hs; var m = Pe; hs = l, (Pe = s) && !m ? ms(n, a, (a.subtreeFlags & 8772) !== 0) : ds(n, a), hs = f, Pe = m } break; case 30: break; default: ds(n, a) } } function Fv(n) { var s = n.alternate; s !== null && (n.alternate = null, Fv(s)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (s = n.stateNode, s !== null && Ca(s)), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } var de = null, _n = !1; function fs(n, s, a) { for (a = a.child; a !== null;)qv(n, s, a), a = a.sibling } function qv(n, s, a) { if (Xe && typeof Xe.onCommitFiberUnmount == "function") try { Xe.onCommitFiberUnmount(ti, a) } catch { } switch (a.tag) { case 26: Pe || zi(a, s), fs(n, s, a), a.memoizedState ? a.memoizedState.count-- : a.stateNode && (a = a.stateNode, a.parentNode.removeChild(a)); break; case 27: Pe || zi(a, s); var l = de, f = _n; tr(a.type) && (de = a.stateNode, _n = !1), fs(n, s, a), Yl(a.stateNode), de = l, _n = f; break; case 5: Pe || zi(a, s); case 6: if (l = de, f = _n, de = null, fs(n, s, a), de = l, _n = f, de !== null) if (_n) try { (de.nodeType === 9 ? de.body : de.nodeName === "HTML" ? de.ownerDocument.body : de).removeChild(a.stateNode) } catch (m) { te(a, s, m) } else try { de.removeChild(a.stateNode) } catch (m) { te(a, s, m) } break; case 18: de !== null && (_n ? (n = de, P_(n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, a.stateNode), ho(n)) : P_(de, a.stateNode)); break; case 4: l = de, f = _n, de = a.stateNode.containerInfo, _n = !0, fs(n, s, a), de = l, _n = f; break; case 0: case 11: case 14: case 15: Ks(2, a, s), Pe || Ks(4, a, s), fs(n, s, a); break; case 1: Pe || (zi(a, s), l = a.stateNode, typeof l.componentWillUnmount == "function" && kv(a, s, l)), fs(n, s, a); break; case 21: fs(n, s, a); break; case 22: Pe = (l = Pe) || a.memoizedState !== null, fs(n, s, a), Pe = l; break; default: fs(n, s, a) } } function Hv(n, s) { if (s.memoizedState === null && (n = s.alternate, n !== null && (n = n.memoizedState, n !== null))) { n = n.dehydrated; try { ho(n) } catch (a) { te(s, s.return, a) } } } function Gv(n, s) { if (s.memoizedState === null && (n = s.alternate, n !== null && (n = n.memoizedState, n !== null && (n = n.dehydrated, n !== null)))) try { ho(n) } catch (a) { te(s, s.return, a) } } function F2(n) { switch (n.tag) { case 31: case 13: case 19: var s = n.stateNode; return s === null && (s = n.stateNode = new Uv), s; case 22: return n = n.stateNode, s = n._retryCache, s === null && (s = n._retryCache = new Uv), s; default: throw Error(r(435, n.tag)) } } function Xc(n, s) { var a = F2(n); s.forEach(function (l) { if (!a.has(l)) { a.add(l); var f = $2.bind(null, n, l); l.then(f, f) } }) } function bn(n, s) { var a = s.deletions; if (a !== null) for (var l = 0; l < a.length; l++) { var f = a[l], m = n, _ = s, S = _; t: for (; S !== null;) { switch (S.tag) { case 27: if (tr(S.type)) { de = S.stateNode, _n = !1; break t } break; case 5: de = S.stateNode, _n = !1; break t; case 3: case 4: de = S.stateNode.containerInfo, _n = !0; break t }S = S.return } if (de === null) throw Error(r(160)); qv(m, _, f), de = null, _n = !1, m = f.alternate, m !== null && (m.return = null), f.return = null } if (s.subtreeFlags & 13886) for (s = s.child; s !== null;)Yv(s, n), s = s.sibling } var ci = null; function Yv(n, s) { var a = n.alternate, l = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: bn(s, n), Tn(n), l & 4 && (Ks(3, n, n.return), kl(3, n), Ks(5, n, n.return)); break; case 1: bn(s, n), Tn(n), l & 512 && (Pe || a === null || zi(a, a.return)), l & 64 && hs && (n = n.updateQueue, n !== null && (l = n.callbacks, l !== null && (a = n.shared.hiddenCallbacks, n.shared.hiddenCallbacks = a === null ? l : a.concat(l)))); break; case 26: var f = ci; if (bn(s, n), Tn(n), l & 512 && (Pe || a === null || zi(a, a.return)), l & 4) { var m = a !== null ? a.memoizedState : null; if (l = n.memoizedState, a === null) if (l === null) if (n.stateNode === null) { t: { l = n.type, a = n.memoizedProps, f = f.ownerDocument || f; e: switch (l) { case "title": m = f.getElementsByTagName("title")[0], (!m || m[Ai] || m[De] || m.namespaceURI === "http://www.w3.org/2000/svg" || m.hasAttribute("itemprop")) && (m = f.createElement(l), f.head.insertBefore(m, f.querySelector("head > title"))), tn(m, l, a), m[De] = n, Ve(m), l = m; break t; case "link": var _ = Y_("link", "href", f).get(l + (a.href || "")); if (_) { for (var S = 0; S < _.length; S++)if (m = _[S], m.getAttribute("href") === (a.href == null || a.href === "" ? null : a.href) && m.getAttribute("rel") === (a.rel == null ? null : a.rel) && m.getAttribute("title") === (a.title == null ? null : a.title) && m.getAttribute("crossorigin") === (a.crossOrigin == null ? null : a.crossOrigin)) { _.splice(S, 1); break e } } m = f.createElement(l), tn(m, l, a), f.head.appendChild(m); break; case "meta": if (_ = Y_("meta", "content", f).get(l + (a.content || ""))) { for (S = 0; S < _.length; S++)if (m = _[S], m.getAttribute("content") === (a.content == null ? null : "" + a.content) && m.getAttribute("name") === (a.name == null ? null : a.name) && m.getAttribute("property") === (a.property == null ? null : a.property) && m.getAttribute("http-equiv") === (a.httpEquiv == null ? null : a.httpEquiv) && m.getAttribute("charset") === (a.charSet == null ? null : a.charSet)) { _.splice(S, 1); break e } } m = f.createElement(l), tn(m, l, a), f.head.appendChild(m); break; default: throw Error(r(468, l)) }m[De] = n, Ve(m), l = m } n.stateNode = l } else K_(f, n.type, n.stateNode); else n.stateNode = G_(f, l, n.memoizedProps); else m !== l ? (m === null ? a.stateNode !== null && (a = a.stateNode, a.parentNode.removeChild(a)) : m.count--, l === null ? K_(f, n.type, n.stateNode) : G_(f, l, n.memoizedProps)) : l === null && n.stateNode !== null && sm(n, n.memoizedProps, a.memoizedProps) } break; case 27: bn(s, n), Tn(n), l & 512 && (Pe || a === null || zi(a, a.return)), a !== null && l & 4 && sm(n, n.memoizedProps, a.memoizedProps); break; case 5: if (bn(s, n), Tn(n), l & 512 && (Pe || a === null || zi(a, a.return)), n.flags & 32) { f = n.stateNode; try { vn(f, "") } catch (mt) { te(n, n.return, mt) } } l & 4 && n.stateNode != null && (f = n.memoizedProps, sm(n, f, a !== null ? a.memoizedProps : f)), l & 1024 && (om = !0); break; case 6: if (bn(s, n), Tn(n), l & 4) { if (n.stateNode === null) throw Error(r(162)); l = n.memoizedProps, a = n.stateNode; try { a.nodeValue = l } catch (mt) { te(n, n.return, mt) } } break; case 3: if (hh = null, f = ci, ci = uh(s.containerInfo), bn(s, n), ci = f, Tn(n), l & 4 && a !== null && a.memoizedState.isDehydrated) try { ho(s.containerInfo) } catch (mt) { te(n, n.return, mt) } om && (om = !1, Kv(n)); break; case 4: l = ci, ci = uh(n.stateNode.containerInfo), bn(s, n), Tn(n), ci = l; break; case 12: bn(s, n), Tn(n); break; case 31: bn(s, n), Tn(n), l & 4 && (l = n.updateQueue, l !== null && (n.updateQueue = null, Xc(n, l))); break; case 13: bn(s, n), Tn(n), n.child.flags & 8192 && n.memoizedState !== null != (a !== null && a.memoizedState !== null) && ($c = fn()), l & 4 && (l = n.updateQueue, l !== null && (n.updateQueue = null, Xc(n, l))); break; case 22: f = n.memoizedState !== null; var V = a !== null && a.memoizedState !== null, q = hs, W = Pe; if (hs = q || f, Pe = W || V, bn(s, n), Pe = W, hs = q, Tn(n), l & 8192) t: for (s = n.stateNode, s._visibility = f ? s._visibility & -2 : s._visibility | 1, f && (a === null || V || hs || Pe || aa(n)), a = null, s = n; ;) { if (s.tag === 5 || s.tag === 26) { if (a === null) { V = a = s; try { if (m = V.stateNode, f) _ = m.style, typeof _.setProperty == "function" ? _.setProperty("display", "none", "important") : _.display = "none"; else { S = V.stateNode; var tt = V.memoizedProps.style, H = tt != null && tt.hasOwnProperty("display") ? tt.display : null; S.style.display = H == null || typeof H == "boolean" ? "" : ("" + H).trim() } } catch (mt) { te(V, V.return, mt) } } } else if (s.tag === 6) { if (a === null) { V = s; try { V.stateNode.nodeValue = f ? "" : V.memoizedProps } catch (mt) { te(V, V.return, mt) } } } else if (s.tag === 18) { if (a === null) { V = s; try { var Y = V.stateNode; f ? k_(Y, !0) : k_(V.stateNode, !1) } catch (mt) { te(V, V.return, mt) } } } else if ((s.tag !== 22 && s.tag !== 23 || s.memoizedState === null || s === n) && s.child !== null) { s.child.return = s, s = s.child; continue } if (s === n) break t; for (; s.sibling === null;) { if (s.return === null || s.return === n) break t; a === s && (a = null), s = s.return } a === s && (a = null), s.sibling.return = s.return, s = s.sibling } l & 4 && (l = n.updateQueue, l !== null && (a = l.retryQueue, a !== null && (l.retryQueue = null, Xc(n, a)))); break; case 19: bn(s, n), Tn(n), l & 4 && (l = n.updateQueue, l !== null && (n.updateQueue = null, Xc(n, l))); break; case 30: break; case 21: break; default: bn(s, n), Tn(n) } } function Tn(n) { var s = n.flags; if (s & 2) { try { for (var a, l = n.return; l !== null;) { if (zv(l)) { a = l; break } l = l.return } if (a == null) throw Error(r(160)); switch (a.tag) { case 27: var f = a.stateNode, m = rm(n); Qc(n, m, f); break; case 5: var _ = a.stateNode; a.flags & 32 && (vn(_, ""), a.flags &= -33); var S = rm(n); Qc(n, S, _); break; case 3: case 4: var V = a.stateNode.containerInfo, q = rm(n); am(n, q, V); break; default: throw Error(r(161)) } } catch (W) { te(n, n.return, W) } n.flags &= -3 } s & 4096 && (n.flags &= -4097) } function Kv(n) { if (n.subtreeFlags & 1024) for (n = n.child; n !== null;) { var s = n; Kv(s), s.tag === 5 && s.flags & 1024 && s.stateNode.reset(), n = n.sibling } } function ds(n, s) { if (s.subtreeFlags & 8772) for (s = s.child; s !== null;)Bv(n, s.alternate, s), s = s.sibling } function aa(n) { for (n = n.child; n !== null;) { var s = n; switch (s.tag) { case 0: case 11: case 14: case 15: Ks(4, s, s.return), aa(s); break; case 1: zi(s, s.return); var a = s.stateNode; typeof a.componentWillUnmount == "function" && kv(s, s.return, a), aa(s); break; case 27: Yl(s.stateNode); case 26: case 5: zi(s, s.return), aa(s); break; case 22: s.memoizedState === null && aa(s); break; case 30: aa(s); break; default: aa(s) }n = n.sibling } } function ms(n, s, a) { for (a = a && (s.subtreeFlags & 8772) !== 0, s = s.child; s !== null;) { var l = s.alternate, f = n, m = s, _ = m.flags; switch (m.tag) { case 0: case 11: case 15: ms(f, m, a), kl(4, m); break; case 1: if (ms(f, m, a), l = m, f = l.stateNode, typeof f.componentDidMount == "function") try { f.componentDidMount() } catch (q) { te(l, l.return, q) } if (l = m, f = l.updateQueue, f !== null) { var S = l.stateNode; try { var V = f.shared.hiddenCallbacks; if (V !== null) for (f.shared.hiddenCallbacks = null, f = 0; f < V.length; f++)A0(V[f], S) } catch (q) { te(l, l.return, q) } } a && _ & 64 && Pv(m), Ll(m, m.return); break; case 27: jv(m); case 26: case 5: ms(f, m, a), a && l === null && _ & 4 && Lv(m), Ll(m, m.return); break; case 12: ms(f, m, a); break; case 31: ms(f, m, a), a && _ & 4 && Hv(f, m); break; case 13: ms(f, m, a), a && _ & 4 && Gv(f, m); break; case 22: m.memoizedState === null && ms(f, m, a), Ll(m, m.return); break; case 30: break; default: ms(f, m, a) }s = s.sibling } } function lm(n, s) { var a = null; n !== null && n.memoizedState !== null && n.memoizedState.cachePool !== null && (a = n.memoizedState.cachePool.pool), n = null, s.memoizedState !== null && s.memoizedState.cachePool !== null && (n = s.memoizedState.cachePool.pool), n !== a && (n != null && n.refCount++, a != null && Sl(a)) } function um(n, s) { n = null, s.alternate !== null && (n = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== n && (s.refCount++, n != null && Sl(n)) } function hi(n, s, a, l) { if (s.subtreeFlags & 10256) for (s = s.child; s !== null;)Qv(n, s, a, l), s = s.sibling } function Qv(n, s, a, l) { var f = s.flags; switch (s.tag) { case 0: case 11: case 15: hi(n, s, a, l), f & 2048 && kl(9, s); break; case 1: hi(n, s, a, l); break; case 3: hi(n, s, a, l), f & 2048 && (n = null, s.alternate !== null && (n = s.alternate.memoizedState.cache), s = s.memoizedState.cache, s !== n && (s.refCount++, n != null && Sl(n))); break; case 12: if (f & 2048) { hi(n, s, a, l), n = s.stateNode; try { var m = s.memoizedProps, _ = m.id, S = m.onPostCommit; typeof S == "function" && S(_, s.alternate === null ? "mount" : "update", n.passiveEffectDuration, -0) } catch (V) { te(s, s.return, V) } } else hi(n, s, a, l); break; case 31: hi(n, s, a, l); break; case 13: hi(n, s, a, l); break; case 23: break; case 22: m = s.stateNode, _ = s.alternate, s.memoizedState !== null ? m._visibility & 2 ? hi(n, s, a, l) : zl(n, s) : m._visibility & 2 ? hi(n, s, a, l) : (m._visibility |= 2, to(n, s, a, l, (s.subtreeFlags & 10256) !== 0 || !1)), f & 2048 && lm(_, s); break; case 24: hi(n, s, a, l), f & 2048 && um(s.alternate, s); break; default: hi(n, s, a, l) } } function to(n, s, a, l, f) { for (f = f && ((s.subtreeFlags & 10256) !== 0 || !1), s = s.child; s !== null;) { var m = n, _ = s, S = a, V = l, q = _.flags; switch (_.tag) { case 0: case 11: case 15: to(m, _, S, V, f), kl(8, _); break; case 23: break; case 22: var W = _.stateNode; _.memoizedState !== null ? W._visibility & 2 ? to(m, _, S, V, f) : zl(m, _) : (W._visibility |= 2, to(m, _, S, V, f)), f && q & 2048 && lm(_.alternate, _); break; case 24: to(m, _, S, V, f), f && q & 2048 && um(_.alternate, _); break; default: to(m, _, S, V, f) }s = s.sibling } } function zl(n, s) { if (s.subtreeFlags & 10256) for (s = s.child; s !== null;) { var a = n, l = s, f = l.flags; switch (l.tag) { case 22: zl(a, l), f & 2048 && lm(l.alternate, l); break; case 24: zl(a, l), f & 2048 && um(l.alternate, l); break; default: zl(a, l) }s = s.sibling } } var jl = 8192; function eo(n, s, a) { if (n.subtreeFlags & jl) for (n = n.child; n !== null;)Xv(n, s, a), n = n.sibling } function Xv(n, s, a) { switch (n.tag) { case 26: eo(n, s, a), n.flags & jl && n.memoizedState !== null && Rx(a, ci, n.memoizedState, n.memoizedProps); break; case 5: eo(n, s, a); break; case 3: case 4: var l = ci; ci = uh(n.stateNode.containerInfo), eo(n, s, a), ci = l; break; case 22: n.memoizedState === null && (l = n.alternate, l !== null && l.memoizedState !== null ? (l = jl, jl = 16777216, eo(n, s, a), jl = l) : eo(n, s, a)); break; default: eo(n, s, a) } } function Wv(n) { var s = n.alternate; if (s !== null && (n = s.child, n !== null)) { s.child = null; do s = n.sibling, n.sibling = null, n = s; while (n !== null) } } function Ul(n) { var s = n.deletions; if ((n.flags & 16) !== 0) { if (s !== null) for (var a = 0; a < s.length; a++) { var l = s[a]; Ke = l, Zv(l, n) } Wv(n) } if (n.subtreeFlags & 10256) for (n = n.child; n !== null;)$v(n), n = n.sibling } function $v(n) { switch (n.tag) { case 0: case 11: case 15: Ul(n), n.flags & 2048 && Ks(9, n, n.return); break; case 3: Ul(n); break; case 12: Ul(n); break; case 22: var s = n.stateNode; n.memoizedState !== null && s._visibility & 2 && (n.return === null || n.return.tag !== 13) ? (s._visibility &= -3, Wc(n)) : Ul(n); break; default: Ul(n) } } function Wc(n) { var s = n.deletions; if ((n.flags & 16) !== 0) { if (s !== null) for (var a = 0; a < s.length; a++) { var l = s[a]; Ke = l, Zv(l, n) } Wv(n) } for (n = n.child; n !== null;) { switch (s = n, s.tag) { case 0: case 11: case 15: Ks(8, s, s.return), Wc(s); break; case 22: a = s.stateNode, a._visibility & 2 && (a._visibility &= -3, Wc(s)); break; default: Wc(s) }n = n.sibling } } function Zv(n, s) { for (; Ke !== null;) { var a = Ke; switch (a.tag) { case 0: case 11: case 15: Ks(8, a, s); break; case 23: case 22: if (a.memoizedState !== null && a.memoizedState.cachePool !== null) { var l = a.memoizedState.cachePool.pool; l != null && l.refCount++ } break; case 24: Sl(a.memoizedState.cache) }if (l = a.child, l !== null) l.return = a, Ke = l; else t: for (a = n; Ke !== null;) { l = Ke; var f = l.sibling, m = l.return; if (Fv(l), l === a) { Ke = null; break t } if (f !== null) { f.return = m, Ke = f; break t } Ke = m } } } var q2 = { getCacheForType: function (n) { var s = Ze(Ie), a = s.data.get(n); return a === void 0 && (a = n(), s.data.set(n, a)), a }, cacheSignal: function () { return Ze(Ie).controller.signal } }, H2 = typeof WeakMap == "function" ? WeakMap : Map, Qt = 0, ae = null, Pt = null, Lt = 0, Jt = 0, In = null, Qs = !1, no = !1, cm = !1, ps = 0, _e = 0, Xs = 0, oa = 0, hm = 0, On = 0, io = 0, Bl = null, En = null, fm = !1, $c = 0, Jv = 0, Zc = 1 / 0, Jc = null, Ws = null, Be = 0, $s = null, so = null, gs = 0, dm = 0, mm = null, t_ = null, Fl = 0, pm = null; function Nn() { return (Qt & 2) !== 0 && Lt !== 0 ? Lt & -Lt : Q.T !== null ? Tm() : tc() } function e_() { if (On === 0) if ((Lt & 536870912) === 0 || Bt) { var n = Nr; Nr <<= 1, (Nr & 3932160) === 0 && (Nr = 262144), On = n } else On = 536870912; return n = Vn.current, n !== null && (n.flags |= 32), On } function Sn(n, s, a) { (n === ae && (Jt === 2 || Jt === 9) || n.cancelPendingCommit !== null) && (ro(n, 0), Zs(n, Lt, On, !1)), Pr(n, a), ((Qt & 2) === 0 || n !== ae) && (n === ae && ((Qt & 2) === 0 && (oa |= a), _e === 4 && Zs(n, Lt, On, !1)), ji(n)) } function n_(n, s, a) { if ((Qt & 6) !== 0) throw Error(r(327)); var l = !a && (s & 127) === 0 && (s & n.expiredLanes) === 0 || ei(n, s), f = l ? K2(n, s) : ym(n, s, !0), m = l; do { if (f === 0) { no && !l && Zs(n, s, 0, !1); break } else { if (a = n.current.alternate, m && !G2(a)) { f = ym(n, s, !1), m = !1; continue } if (f === 2) { if (m = s, n.errorRecoveryDisabledLanes & m) var _ = 0; else _ = n.pendingLanes & -536870913, _ = _ !== 0 ? _ : _ & 536870912 ? 536870912 : 0; if (_ !== 0) { s = _; t: { var S = n; f = Bl; var V = S.current.memoizedState.isDehydrated; if (V && (ro(S, _).flags |= 256), _ = ym(S, _, !1), _ !== 2) { if (cm && !V) { S.errorRecoveryDisabledLanes |= m, oa |= m, f = 4; break t } m = En, En = f, m !== null && (En === null ? En = m : En.push.apply(En, m)) } f = _ } if (m = !1, f !== 2) continue } } if (f === 1) { ro(n, 0), Zs(n, s, 0, !0); break } t: { switch (l = n, m = f, m) { case 0: case 1: throw Error(r(345)); case 4: if ((s & 4194048) !== s) break; case 6: Zs(l, s, On, !Qs); break t; case 2: En = null; break; case 3: case 5: break; default: throw Error(r(329)) }if ((s & 62914560) === s && (f = $c + 300 - fn(), 10 < f)) { if (Zs(l, s, On, !Qs), Ti(l, 0, !0) !== 0) break t; gs = s, l.timeoutHandle = O_(i_.bind(null, l, a, En, Jc, fm, s, On, oa, io, Qs, m, "Throttled", -0, 0), f); break t } i_(l, a, En, Jc, fm, s, On, oa, io, Qs, m, null, -0, 0) } } break } while (!0); ji(n) } function i_(n, s, a, l, f, m, _, S, V, q, W, tt, H, Y) { if (n.timeoutHandle = -1, tt = s.subtreeFlags, tt & 8192 || (tt & 16785408) === 16785408) { tt = { stylesheets: null, count: 0, imgCount: 0, imgBytes: 0, suspenseyImages: [], waitingForImages: !0, waitingForViewTransition: !1, unsuspend: si }, Xv(s, m, tt); var mt = (m & 62914560) === m ? $c - fn() : (m & 4194048) === m ? Jv - fn() : 0; if (mt = Dx(tt, mt), mt !== null) { gs = m, n.cancelPendingCommit = mt(h_.bind(null, n, s, m, a, l, f, _, S, V, W, tt, null, H, Y)), Zs(n, m, _, !q); return } } h_(n, s, m, a, l, f, _, S, V) } function G2(n) { for (var s = n; ;) { var a = s.tag; if ((a === 0 || a === 11 || a === 15) && s.flags & 16384 && (a = s.updateQueue, a !== null && (a = a.stores, a !== null))) for (var l = 0; l < a.length; l++) { var f = a[l], m = f.getSnapshot; f = f.value; try { if (!Rn(m(), f)) return !1 } catch { return !1 } } if (a = s.child, s.subtreeFlags & 16384 && a !== null) a.return = s, s = a; else { if (s === n) break; for (; s.sibling === null;) { if (s.return === null || s.return === n) return !0; s = s.return } s.sibling.return = s.return, s = s.sibling } } return !0 } function Zs(n, s, a, l) { s &= ~hm, s &= ~oa, n.suspendedLanes |= s, n.pingedLanes &= ~s, l && (n.warmLanes |= s), l = n.expirationTimes; for (var f = s; 0 < f;) { var m = 31 - Te(f), _ = 1 << m; l[m] = -1, f &= ~_ } a !== 0 && kr(n, a, s) } function th() { return (Qt & 6) === 0 ? (ql(0), !1) : !0 } function gm() { if (Pt !== null) { if (Jt === 0) var n = Pt.return; else n = Pt, rs = Zr = null, Id(n), Xa = null, wl = 0, n = Pt; for (; n !== null;)Nv(n.alternate, n), n = n.return; Pt = null } } function ro(n, s) { var a = n.timeoutHandle; a !== -1 && (n.timeoutHandle = -1, hx(a)), a = n.cancelPendingCommit, a !== null && (n.cancelPendingCommit = null, a()), gs = 0, gm(), ae = n, Pt = a = is(n.current, null), Lt = s, Jt = 0, In = null, Qs = !1, no = ei(n, s), cm = !1, io = On = hm = oa = Xs = _e = 0, En = Bl = null, fm = !1, (s & 8) !== 0 && (s |= s & 32); var l = n.entangledLanes; if (l !== 0) for (n = n.entanglements, l &= s; 0 < l;) { var f = 31 - Te(l), m = 1 << f; s |= n[f], l &= ~m } return ps = s, Tc(), a } function s_(n, s) { Mt = null, Q.H = Ol, s === Qa || s === Dc ? (s = b0(), Jt = 3) : s === bd ? (s = b0(), Jt = 4) : Jt = s === Qd ? 8 : s !== null && typeof s == "object" && typeof s.then == "function" ? 6 : 1, In = s, Pt === null && (_e = 1, qc(n, qn(s, n.current))) } function r_() { var n = Vn.current; return n === null ? !0 : (Lt & 4194048) === Lt ? Kn === null : (Lt & 62914560) === Lt || (Lt & 536870912) !== 0 ? n === Kn : !1 } function a_() { var n = Q.H; return Q.H = Ol, n === null ? Ol : n } function o_() { var n = Q.A; return Q.A = q2, n } function eh() { _e = 4, Qs || (Lt & 4194048) !== Lt && Vn.current !== null || (no = !0), (Xs & 134217727) === 0 && (oa & 134217727) === 0 || ae === null || Zs(ae, Lt, On, !1) } function ym(n, s, a) { var l = Qt; Qt |= 2; var f = a_(), m = o_(); (ae !== n || Lt !== s) && (Jc = null, ro(n, s)), s = !1; var _ = _e; t: do try { if (Jt !== 0 && Pt !== null) { var S = Pt, V = In; switch (Jt) { case 8: gm(), _ = 6; break t; case 3: case 2: case 9: case 6: Vn.current === null && (s = !0); var q = Jt; if (Jt = 0, In = null, ao(n, S, V, q), a && no) { _ = 0; break t } break; default: q = Jt, Jt = 0, In = null, ao(n, S, V, q) } } Y2(), _ = _e; break } catch (W) { s_(n, W) } while (!0); return s && n.shellSuspendCounter++, rs = Zr = null, Qt = l, Q.H = f, Q.A = m, Pt === null && (ae = null, Lt = 0, Tc()), _ } function Y2() { for (; Pt !== null;)l_(Pt) } function K2(n, s) { var a = Qt; Qt |= 2; var l = a_(), f = o_(); ae !== n || Lt !== s ? (Jc = null, Zc = fn() + 500, ro(n, s)) : no = ei(n, s); t: do try { if (Jt !== 0 && Pt !== null) { s = Pt; var m = In; e: switch (Jt) { case 1: Jt = 0, In = null, ao(n, s, m, 1); break; case 2: case 9: if (v0(m)) { Jt = 0, In = null, u_(s); break } s = function () { Jt !== 2 && Jt !== 9 || ae !== n || (Jt = 7), ji(n) }, m.then(s, s); break t; case 3: Jt = 7; break t; case 4: Jt = 5; break t; case 7: v0(m) ? (Jt = 0, In = null, u_(s)) : (Jt = 0, In = null, ao(n, s, m, 7)); break; case 5: var _ = null; switch (Pt.tag) { case 26: _ = Pt.memoizedState; case 5: case 27: var S = Pt; if (_ ? Q_(_) : S.stateNode.complete) { Jt = 0, In = null; var V = S.sibling; if (V !== null) Pt = V; else { var q = S.return; q !== null ? (Pt = q, nh(q)) : Pt = null } break e } }Jt = 0, In = null, ao(n, s, m, 5); break; case 6: Jt = 0, In = null, ao(n, s, m, 6); break; case 8: gm(), _e = 6; break t; default: throw Error(r(462)) } } Q2(); break } catch (W) { s_(n, W) } while (!0); return rs = Zr = null, Q.H = l, Q.A = f, Qt = a, Pt !== null ? 0 : (ae = null, Lt = 0, Tc(), _e) } function Q2() { for (; Pt !== null && !Kf();)l_(Pt) } function l_(n) { var s = Iv(n.alternate, n, ps); n.memoizedProps = n.pendingProps, s === null ? nh(n) : Pt = s } function u_(n) { var s = n, a = s.alternate; switch (s.tag) { case 15: case 0: s = xv(a, s, s.pendingProps, s.type, void 0, Lt); break; case 11: s = xv(a, s, s.pendingProps, s.type.render, s.ref, Lt); break; case 5: Id(s); default: Nv(a, s), s = Pt = o0(s, ps), s = Iv(a, s, ps) }n.memoizedProps = n.pendingProps, s === null ? nh(n) : Pt = s } function ao(n, s, a, l) { rs = Zr = null, Id(s), Xa = null, wl = 0; var f = s.return; try { if (k2(n, f, s, a, Lt)) { _e = 1, qc(n, qn(a, n.current)), Pt = null; return } } catch (m) { if (f !== null) throw Pt = f, m; _e = 1, qc(n, qn(a, n.current)), Pt = null; return } s.flags & 32768 ? (Bt || l === 1 ? n = !0 : no || (Lt & 536870912) !== 0 ? n = !1 : (Qs = n = !0, (l === 2 || l === 9 || l === 3 || l === 6) && (l = Vn.current, l !== null && l.tag === 13 && (l.flags |= 16384))), c_(s, n)) : nh(s) } function nh(n) { var s = n; do { if ((s.flags & 32768) !== 0) { c_(s, Qs); return } n = s.return; var a = j2(s.alternate, s, ps); if (a !== null) { Pt = a; return } if (s = s.sibling, s !== null) { Pt = s; return } Pt = s = n } while (s !== null); _e === 0 && (_e = 5) } function c_(n, s) { do { var a = U2(n.alternate, n); if (a !== null) { a.flags &= 32767, Pt = a; return } if (a = n.return, a !== null && (a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null), !s && (n = n.sibling, n !== null)) { Pt = n; return } Pt = n = a } while (n !== null); _e = 6, Pt = null } function h_(n, s, a, l, f, m, _, S, V) { n.cancelPendingCommit = null; do ih(); while (Be !== 0); if ((Qt & 6) !== 0) throw Error(r(327)); if (s !== null) { if (s === n.current) throw Error(r(177)); if (m = s.lanes | s.childLanes, m |= rd, Wf(n, a, m, _, S, V), n === ae && (Pt = ae = null, Lt = 0), so = s, $s = n, gs = a, dm = m, mm = f, t_ = l, (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? (n.callbackNode = null, n.callbackPriority = 0, Z2(Rs, function () { return g_(), null })) : (n.callbackNode = null, n.callbackPriority = 0), l = (s.flags & 13878) !== 0, (s.subtreeFlags & 13878) !== 0 || l) { l = Q.T, Q.T = null, f = rt.p, rt.p = 2, _ = Qt, Qt |= 4; try { B2(n, s, a) } finally { Qt = _, rt.p = f, Q.T = l } } Be = 1, f_(), d_(), m_() } } function f_() { if (Be === 1) { Be = 0; var n = $s, s = so, a = (s.flags & 13878) !== 0; if ((s.subtreeFlags & 13878) !== 0 || a) { a = Q.T, Q.T = null; var l = rt.p; rt.p = 2; var f = Qt; Qt |= 4; try { Yv(s, n); var m = Dm, _ = Zy(n.containerInfo), S = m.focusedElem, V = m.selectionRange; if (_ !== S && S && S.ownerDocument && $y(S.ownerDocument.documentElement, S)) { if (V !== null && td(S)) { var q = V.start, W = V.end; if (W === void 0 && (W = q), "selectionStart" in S) S.selectionStart = q, S.selectionEnd = Math.min(W, S.value.length); else { var tt = S.ownerDocument || document, H = tt && tt.defaultView || window; if (H.getSelection) { var Y = H.getSelection(), mt = S.textContent.length, St = Math.min(V.start, mt), re = V.end === void 0 ? St : Math.min(V.end, mt); !Y.extend && St > re && (_ = re, re = St, St = _); var L = Wy(S, St), P = Wy(S, re); if (L && P && (Y.rangeCount !== 1 || Y.anchorNode !== L.node || Y.anchorOffset !== L.offset || Y.focusNode !== P.node || Y.focusOffset !== P.offset)) { var B = tt.createRange(); B.setStart(L.node, L.offset), Y.removeAllRanges(), St > re ? (Y.addRange(B), Y.extend(P.node, P.offset)) : (B.setEnd(P.node, P.offset), Y.addRange(B)) } } } } for (tt = [], Y = S; Y = Y.parentNode;)Y.nodeType === 1 && tt.push({ element: Y, left: Y.scrollLeft, top: Y.scrollTop }); for (typeof S.focus == "function" && S.focus(), S = 0; S < tt.length; S++) { var $ = tt[S]; $.element.scrollLeft = $.left, $.element.scrollTop = $.top } } ph = !!Rm, Dm = Rm = null } finally { Qt = f, rt.p = l, Q.T = a } } n.current = s, Be = 2 } } function d_() { if (Be === 2) { Be = 0; var n = $s, s = so, a = (s.flags & 8772) !== 0; if ((s.subtreeFlags & 8772) !== 0 || a) { a = Q.T, Q.T = null; var l = rt.p; rt.p = 2; var f = Qt; Qt |= 4; try { Bv(n, s.alternate, s) } finally { Qt = f, rt.p = l, Q.T = a } } Be = 3 } } function m_() { if (Be === 4 || Be === 3) { Be = 0, Ku(); var n = $s, s = so, a = gs, l = t_; (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? Be = 5 : (Be = 0, so = $s = null, p_(n, n.pendingLanes)); var f = n.pendingLanes; if (f === 0 && (Ws = null), Ji(a), s = s.stateNode, Xe && typeof Xe.onCommitFiberRoot == "function") try { Xe.onCommitFiberRoot(ti, s, void 0, (s.current.flags & 128) === 128) } catch { } if (l !== null) { s = Q.T, f = rt.p, rt.p = 2, Q.T = null; try { for (var m = n.onRecoverableError, _ = 0; _ < l.length; _++) { var S = l[_]; m(S.value, { componentStack: S.stack }) } } finally { Q.T = s, rt.p = f } } (gs & 3) !== 0 && ih(), ji(n), f = n.pendingLanes, (a & 261930) !== 0 && (f & 42) !== 0 ? n === pm ? Fl++ : (Fl = 0, pm = n) : Fl = 0, ql(0) } } function p_(n, s) { (n.pooledCacheLanes &= s) === 0 && (s = n.pooledCache, s != null && (n.pooledCache = null, Sl(s))) } function ih() { return f_(), d_(), m_(), g_() } function g_() { if (Be !== 5) return !1; var n = $s, s = dm; dm = 0; var a = Ji(gs), l = Q.T, f = rt.p; try { rt.p = 32 > a ? 32 : a, Q.T = null, a = mm, mm = null; var m = $s, _ = gs; if (Be = 0, so = $s = null, gs = 0, (Qt & 6) !== 0) throw Error(r(331)); var S = Qt; if (Qt |= 4, $v(m.current), Qv(m, m.current, _, a), Qt = S, ql(0, !1), Xe && typeof Xe.onPostCommitFiberRoot == "function") try { Xe.onPostCommitFiberRoot(ti, m) } catch { } return !0 } finally { rt.p = f, Q.T = l, p_(n, s) } } function y_(n, s, a) { s = qn(a, s), s = Kd(n.stateNode, s, 2), n = Hs(n, s, 2), n !== null && (Pr(n, 2), ji(n)) } function te(n, s, a) { if (n.tag === 3) y_(n, n, a); else for (; s !== null;) { if (s.tag === 3) { y_(s, n, a); break } else if (s.tag === 1) { var l = s.stateNode; if (typeof s.type.getDerivedStateFromError == "function" || typeof l.componentDidCatch == "function" && (Ws === null || !Ws.has(l))) { n = qn(a, n), a = vv(2), l = Hs(s, a, 2), l !== null && (_v(a, l, s, n), Pr(l, 2), ji(l)); break } } s = s.return } } function vm(n, s, a) { var l = n.pingCache; if (l === null) { l = n.pingCache = new H2; var f = new Set; l.set(s, f) } else f = l.get(s), f === void 0 && (f = new Set, l.set(s, f)); f.has(a) || (cm = !0, f.add(a), n = X2.bind(null, n, s, a), s.then(n, n)) } function X2(n, s, a) { var l = n.pingCache; l !== null && l.delete(s), n.pingedLanes |= n.suspendedLanes & a, n.warmLanes &= ~a, ae === n && (Lt & a) === a && (_e === 4 || _e === 3 && (Lt & 62914560) === Lt && 300 > fn() - $c ? (Qt & 2) === 0 && ro(n, 0) : hm |= a, io === Lt && (io = 0)), ji(n) } function v_(n, s) { s === 0 && (s = Ju()), n = Xr(n, s), n !== null && (Pr(n, s), ji(n)) } function W2(n) { var s = n.memoizedState, a = 0; s !== null && (a = s.retryLane), v_(n, a) } function $2(n, s) { var a = 0; switch (n.tag) { case 31: case 13: var l = n.stateNode, f = n.memoizedState; f !== null && (a = f.retryLane); break; case 19: l = n.stateNode; break; case 22: l = n.stateNode._retryCache; break; default: throw Error(r(314)) }l !== null && l.delete(s), v_(n, a) } function Z2(n, s) { return Ue(n, s) } var sh = null, oo = null, _m = !1, rh = !1, bm = !1, Js = 0; function ji(n) { n !== oo && n.next === null && (oo === null ? sh = oo = n : oo = oo.next = n), rh = !0, _m || (_m = !0, tx()) } function ql(n, s) { if (!bm && rh) { bm = !0; do for (var a = !1, l = sh; l !== null;) { if (n !== 0) { var f = l.pendingLanes; if (f === 0) var m = 0; else { var _ = l.suspendedLanes, S = l.pingedLanes; m = (1 << 31 - Te(42 | n) + 1) - 1, m &= f & ~(_ & ~S), m = m & 201326741 ? m & 201326741 | 1 : m ? m | 2 : 0 } m !== 0 && (a = !0, E_(l, m)) } else m = Lt, m = Ti(l, l === ae ? m : 0, l.cancelPendingCommit !== null || l.timeoutHandle !== -1), (m & 3) === 0 || ei(l, m) || (a = !0, E_(l, m)); l = l.next } while (a); bm = !1 } } function J2() { __() } function __() { rh = _m = !1; var n = 0; Js !== 0 && cx() && (n = Js); for (var s = fn(), a = null, l = sh; l !== null;) { var f = l.next, m = b_(l, s); m === 0 ? (l.next = null, a === null ? sh = f : a.next = f, f === null && (oo = a)) : (a = l, (n !== 0 || (m & 3) !== 0) && (rh = !0)), l = f } Be !== 0 && Be !== 5 || ql(n), Js !== 0 && (Js = 0) } function b_(n, s) { for (var a = n.suspendedLanes, l = n.pingedLanes, f = n.expirationTimes, m = n.pendingLanes & -62914561; 0 < m;) { var _ = 31 - Te(m), S = 1 << _, V = f[_]; V === -1 ? ((S & a) === 0 || (S & l) !== 0) && (f[_] = Xf(S, s)) : V <= s && (n.expiredLanes |= S), m &= ~S } if (s = ae, a = Lt, a = Ti(n, n === s ? a : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1), l = n.callbackNode, a === 0 || n === s && (Jt === 2 || Jt === 9) || n.cancelPendingCommit !== null) return l !== null && l !== null && Cs(l), n.callbackNode = null, n.callbackPriority = 0; if ((a & 3) === 0 || ei(n, a)) { if (s = a & -a, s === n.callbackPriority) return s; switch (l !== null && Cs(l), Ji(a)) { case 2: case 8: a = Jo; break; case 32: a = Rs; break; case 268435456: a = Qu; break; default: a = Rs }return l = T_.bind(null, n), a = Ue(a, l), n.callbackPriority = s, n.callbackNode = a, s } return l !== null && l !== null && Cs(l), n.callbackPriority = 2, n.callbackNode = null, 2 } function T_(n, s) { if (Be !== 0 && Be !== 5) return n.callbackNode = null, n.callbackPriority = 0, null; var a = n.callbackNode; if (ih() && n.callbackNode !== a) return null; var l = Lt; return l = Ti(n, n === ae ? l : 0, n.cancelPendingCommit !== null || n.timeoutHandle !== -1), l === 0 ? null : (n_(n, l, s), b_(n, fn()), n.callbackNode != null && n.callbackNode === a ? T_.bind(null, n) : null) } function E_(n, s) { if (ih()) return null; n_(n, s, !0) } function tx() { fx(function () { (Qt & 6) !== 0 ? Ue(Zo, J2) : __() }) } function Tm() { if (Js === 0) { var n = Ya; n === 0 && (n = _i, _i <<= 1, (_i & 261888) === 0 && (_i = 256)), Js = n } return Js } function S_(n) { return n == null || typeof n == "symbol" || typeof n == "boolean" ? null : typeof n == "function" ? n : Ma("" + n) } function A_(n, s) { var a = s.ownerDocument.createElement("input"); return a.name = s.name, a.value = s.value, n.id && a.setAttribute("form", n.id), s.parentNode.insertBefore(a, s), n = new FormData(n), a.parentNode.removeChild(a), n } function ex(n, s, a, l, f) { if (s === "submit" && a && a.stateNode === f) { var m = S_((f[Ge] || null).action), _ = l.submitter; _ && (s = (s = _[Ge] || null) ? S_(s.formAction) : _.getAttribute("formAction"), s !== null && (m = s, _ = null)); var S = new Ii("action", "action", null, l, f); n.push({ event: S, listeners: [{ instance: null, listener: function () { if (l.defaultPrevented) { if (Js !== 0) { var V = _ ? A_(f, _) : new FormData(f); Bd(a, { pending: !0, data: V, method: f.method, action: m }, null, V) } } else typeof m == "function" && (S.preventDefault(), V = _ ? A_(f, _) : new FormData(f), Bd(a, { pending: !0, data: V, method: f.method, action: m }, m, V)) }, currentTarget: f }] }) } } for (var Em = 0; Em < sd.length; Em++) { var Sm = sd[Em], nx = Sm.toLowerCase(), ix = Sm[0].toUpperCase() + Sm.slice(1); ui(nx, "on" + ix) } ui(e0, "onAnimationEnd"), ui(n0, "onAnimationIteration"), ui(i0, "onAnimationStart"), ui("dblclick", "onDoubleClick"), ui("focusin", "onFocus"), ui("focusout", "onBlur"), ui(_2, "onTransitionRun"), ui(b2, "onTransitionStart"), ui(T2, "onTransitionCancel"), ui(s0, "onTransitionEnd"), Ri("onMouseEnter", ["mouseout", "mouseover"]), Ri("onMouseLeave", ["mouseout", "mouseover"]), Ri("onPointerEnter", ["pointerout", "pointerover"]), Ri("onPointerLeave", ["pointerout", "pointerover"]), Ci("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Ci("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Ci("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Ci("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Ci("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Ci("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Hl = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), sx = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Hl)); function w_(n, s) { s = (s & 4) !== 0; for (var a = 0; a < n.length; a++) { var l = n[a], f = l.event; l = l.listeners; t: { var m = void 0; if (s) for (var _ = l.length - 1; 0 <= _; _--) { var S = l[_], V = S.instance, q = S.currentTarget; if (S = S.listener, V !== m && f.isPropagationStopped()) break t; m = S, f.currentTarget = q; try { m(f) } catch (W) { bc(W) } f.currentTarget = null, m = V } else for (_ = 0; _ < l.length; _++) { if (S = l[_], V = S.instance, q = S.currentTarget, S = S.listener, V !== m && f.isPropagationStopped()) break t; m = S, f.currentTarget = q; try { m(f) } catch (W) { bc(W) } f.currentTarget = null, m = V } } } } function kt(n, s) { var a = s[xa]; a === void 0 && (a = s[xa] = new Set); var l = n + "__bubble"; a.has(l) || (x_(s, n, 2, !1), a.add(l)) } function Am(n, s, a) { var l = 0; s && (l |= 4), x_(a, n, l, s) } var ah = "_reactListening" + Math.random().toString(36).slice(2); function wm(n) { if (!n[ah]) { n[ah] = !0, nl.forEach(function (a) { a !== "selectionchange" && (sx.has(a) || Am(a, !1, n), Am(a, !0, n)) }); var s = n.nodeType === 9 ? n : n.ownerDocument; s === null || s[ah] || (s[ah] = !0, Am("selectionchange", !1, s)) } } function x_(n, s, a, l) { switch (e1(s)) { case 2: var f = Ix; break; case 8: f = Ox; break; default: f = Um }a = f.bind(null, s, a, n), f = void 0, !Br || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (f = !0), l ? f !== void 0 ? n.addEventListener(s, a, { capture: !0, passive: f }) : n.addEventListener(s, a, !0) : f !== void 0 ? n.addEventListener(s, a, { passive: f }) : n.addEventListener(s, a, !1) } function xm(n, s, a, l, f) { var m = l; if ((s & 1) === 0 && (s & 2) === 0 && l !== null) t: for (; ;) { if (l === null) return; var _ = l.tag; if (_ === 3 || _ === 4) { var S = l.stateNode.containerInfo; if (S === f) break; if (_ === 4) for (_ = l.return; _ !== null;) { var V = _.tag; if ((V === 3 || V === 4) && _.stateNode.containerInfo === f) return; _ = _.return } for (; S !== null;) { if (_ = wi(S), _ === null) return; if (V = _.tag, V === 5 || V === 6 || V === 26 || V === 27) { l = m = _; continue t } S = S.parentNode } } l = l.return } Ns(function () { var q = m, W = jn(a), tt = []; t: { var H = r0.get(n); if (H !== void 0) { var Y = Ii, mt = n; switch (n) { case "keypress": if (qr(a) === 0) break t; case "keydown": case "keyup": Y = yc; break; case "focusin": mt = "focus", Y = Gr; break; case "focusout": mt = "blur", Y = Gr; break; case "beforeblur": case "afterblur": Y = Gr; break; case "click": if (a.button === 2) break t; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Y = pl; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Y = lc; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Y = y; break; case e0: case n0: case i0: Y = cc; break; case s0: Y = w; break; case "scroll": case "scrollend": Y = ml; break; case "wheel": Y = G; break; case "copy": case "cut": case "paste": Y = hc; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Y = ns; break; case "toggle": case "beforetoggle": Y = Vt }var St = (s & 4) !== 0, re = !St && (n === "scroll" || n === "scrollend"), L = St ? H !== null ? H + "Capture" : null : H; St = []; for (var P = q, B; P !== null;) { var $ = P; if (B = $.stateNode, $ = $.tag, $ !== 5 && $ !== 26 && $ !== 27 || B === null || L === null || ($ = ri(P, L), $ != null && St.push(Gl(P, $, B))), re) break; P = P.return } 0 < St.length && (H = new Y(H, mt, null, a, W), tt.push({ event: H, listeners: St })) } } if ((s & 7) === 0) { t: { if (H = n === "mouseover" || n === "pointerover", Y = n === "mouseout" || n === "pointerout", H && a !== hl && (mt = a.relatedTarget || a.fromElement) && (wi(mt) || mt[Si])) break t; if ((Y || H) && (H = W.window === W ? W : (H = W.ownerDocument) ? H.defaultView || H.parentWindow : window, Y ? (mt = a.relatedTarget || a.toElement, Y = q, mt = mt ? wi(mt) : null, mt !== null && (re = u(mt), St = mt.tag, mt !== re || St !== 5 && St !== 27 && St !== 6) && (mt = null)) : (Y = null, mt = q), Y !== mt)) { if (St = pl, $ = "onMouseLeave", L = "onMouseEnter", P = "mouse", (n === "pointerout" || n === "pointerover") && (St = ns, $ = "onPointerLeave", L = "onPointerEnter", P = "pointer"), re = Y == null ? H : xn(Y), B = mt == null ? H : xn(mt), H = new St($, P + "leave", Y, a, W), H.target = re, H.relatedTarget = B, $ = null, wi(W) === q && (St = new St(L, P + "enter", mt, a, W), St.target = B, St.relatedTarget = re, $ = St), re = $, Y && mt) e: { for (St = rx, L = Y, P = mt, B = 0, $ = L; $; $ = St($))B++; $ = 0; for (var _t = P; _t; _t = St(_t))$++; for (; 0 < B - $;)L = St(L), B--; for (; 0 < $ - B;)P = St(P), $--; for (; B--;) { if (L === P || P !== null && L === P.alternate) { St = L; break e } L = St(L), P = St(P) } St = null } else St = null; Y !== null && C_(tt, H, Y, St, !1), mt !== null && re !== null && C_(tt, re, mt, St, !0) } } t: { if (H = q ? xn(q) : window, Y = H.nodeName && H.nodeName.toLowerCase(), Y === "select" || Y === "input" && H.type === "file") var Ht = Hy; else if (Fy(H)) if (Gy) Ht = g2; else { Ht = m2; var vt = d2 } else Y = H.nodeName, !Y || Y.toLowerCase() !== "input" || H.type !== "checkbox" && H.type !== "radio" ? q && Va(q.elementType) && (Ht = Hy) : Ht = p2; if (Ht && (Ht = Ht(n, q))) { qy(tt, Ht, a, W); break t } vt && vt(n, H, q), n === "focusout" && q && H.type === "number" && q.memoizedProps.value != null && ll(H, "number", H.value) } switch (vt = q ? xn(q) : window, n) { case "focusin": (Fy(vt) || vt.contentEditable === "true") && (za = vt, ed = q, bl = null); break; case "focusout": bl = ed = za = null; break; case "mousedown": nd = !0; break; case "contextmenu": case "mouseup": case "dragend": nd = !1, Jy(tt, a, W); break; case "selectionchange": if (v2) break; case "keydown": case "keyup": Jy(tt, a, W) }var It; if (Kt) t: { switch (n) { case "compositionstart": var zt = "onCompositionStart"; break t; case "compositionend": zt = "onCompositionEnd"; break t; case "compositionupdate": zt = "onCompositionUpdate"; break t }zt = void 0 } else La ? Yr(n, a) && (zt = "onCompositionEnd") : n === "keydown" && a.keyCode === 229 && (zt = "onCompositionStart"); zt && (Pi && a.locale !== "ko" && (La || zt !== "onCompositionStart" ? zt === "onCompositionEnd" && La && (It = dl()) : (Mi = W, fl = "value" in Mi ? Mi.value : Mi.textContent, La = !0)), vt = oh(q, zt), 0 < vt.length && (zt = new Ni(zt, n, null, a, W), tt.push({ event: zt, listeners: vt }), It ? zt.data = It : (It = ka(a), It !== null && (zt.data = It)))), (It = Bn ? u2(n, a) : c2(n, a)) && (zt = oh(q, "onBeforeInput"), 0 < zt.length && (vt = new Ni("onBeforeInput", "beforeinput", null, a, W), tt.push({ event: vt, listeners: zt }), vt.data = It)), ex(tt, n, q, a, W) } w_(tt, s) }) } function Gl(n, s, a) { return { instance: n, listener: s, currentTarget: a } } function oh(n, s) { for (var a = s + "Capture", l = []; n !== null;) { var f = n, m = f.stateNode; if (f = f.tag, f !== 5 && f !== 26 && f !== 27 || m === null || (f = ri(n, a), f != null && l.unshift(Gl(n, f, m)), f = ri(n, s), f != null && l.push(Gl(n, f, m))), n.tag === 3) return l; n = n.return } return [] } function rx(n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5 && n.tag !== 27); return n || null } function C_(n, s, a, l, f) { for (var m = s._reactName, _ = []; a !== null && a !== l;) { var S = a, V = S.alternate, q = S.stateNode; if (S = S.tag, V !== null && V === l) break; S !== 5 && S !== 26 && S !== 27 || q === null || (V = q, f ? (q = ri(a, m), q != null && _.unshift(Gl(a, q, V))) : f || (q = ri(a, m), q != null && _.push(Gl(a, q, V)))), a = a.return } _.length !== 0 && n.push({ event: s, listeners: _ }) } var ax = /\r\n?/g, ox = /\u0000|\uFFFD/g; function R_(n) {
    return (typeof n == "string" ? n : "" + n).replace(ax, `
`).replace(ox, "")
  } function D_(n, s) { return s = R_(s), R_(n) === s } function se(n, s, a, l, f, m) { switch (a) { case "children": typeof l == "string" ? s === "body" || s === "textarea" && l === "" || vn(n, l) : (typeof l == "number" || typeof l == "bigint") && s !== "body" && vn(n, "" + l); break; case "className": Cn(n, "class", l); break; case "tabIndex": Cn(n, "tabindex", l); break; case "dir": case "role": case "viewBox": case "width": case "height": Cn(n, a, l); break; case "style": cl(n, l, m); break; case "data": if (s !== "object") { Cn(n, "data", l); break } case "src": case "href": if (l === "" && (s !== "a" || a !== "href")) { n.removeAttribute(a); break } if (l == null || typeof l == "function" || typeof l == "symbol" || typeof l == "boolean") { n.removeAttribute(a); break } l = Ma("" + l), n.setAttribute(a, l); break; case "action": case "formAction": if (typeof l == "function") { n.setAttribute(a, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof m == "function" && (a === "formAction" ? (s !== "input" && se(n, s, "name", f.name, f, null), se(n, s, "formEncType", f.formEncType, f, null), se(n, s, "formMethod", f.formMethod, f, null), se(n, s, "formTarget", f.formTarget, f, null)) : (se(n, s, "encType", f.encType, f, null), se(n, s, "method", f.method, f, null), se(n, s, "target", f.target, f, null))); if (l == null || typeof l == "symbol" || typeof l == "boolean") { n.removeAttribute(a); break } l = Ma("" + l), n.setAttribute(a, l); break; case "onClick": l != null && (n.onclick = si); break; case "onScroll": l != null && kt("scroll", n); break; case "onScrollEnd": l != null && kt("scrollend", n); break; case "dangerouslySetInnerHTML": if (l != null) { if (typeof l != "object" || !("__html" in l)) throw Error(r(61)); if (a = l.__html, a != null) { if (f.children != null) throw Error(r(60)); n.innerHTML = a } } break; case "multiple": n.multiple = l && typeof l != "function" && typeof l != "symbol"; break; case "muted": n.muted = l && typeof l != "function" && typeof l != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (l == null || typeof l == "function" || typeof l == "boolean" || typeof l == "symbol") { n.removeAttribute("xlink:href"); break } a = Ma("" + l), n.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", a); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": l != null && typeof l != "function" && typeof l != "symbol" ? n.setAttribute(a, "" + l) : n.removeAttribute(a); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": l && typeof l != "function" && typeof l != "symbol" ? n.setAttribute(a, "") : n.removeAttribute(a); break; case "capture": case "download": l === !0 ? n.setAttribute(a, "") : l !== !1 && l != null && typeof l != "function" && typeof l != "symbol" ? n.setAttribute(a, l) : n.removeAttribute(a); break; case "cols": case "rows": case "size": case "span": l != null && typeof l != "function" && typeof l != "symbol" && !isNaN(l) && 1 <= l ? n.setAttribute(a, l) : n.removeAttribute(a); break; case "rowSpan": case "start": l == null || typeof l == "function" || typeof l == "symbol" || isNaN(l) ? n.removeAttribute(a) : n.setAttribute(a, l); break; case "popover": kt("beforetoggle", n), kt("toggle", n), Ra(n, "popover", l); break; case "xlinkActuate": Me(n, "http://www.w3.org/1999/xlink", "xlink:actuate", l); break; case "xlinkArcrole": Me(n, "http://www.w3.org/1999/xlink", "xlink:arcrole", l); break; case "xlinkRole": Me(n, "http://www.w3.org/1999/xlink", "xlink:role", l); break; case "xlinkShow": Me(n, "http://www.w3.org/1999/xlink", "xlink:show", l); break; case "xlinkTitle": Me(n, "http://www.w3.org/1999/xlink", "xlink:title", l); break; case "xlinkType": Me(n, "http://www.w3.org/1999/xlink", "xlink:type", l); break; case "xmlBase": Me(n, "http://www.w3.org/XML/1998/namespace", "xml:base", l); break; case "xmlLang": Me(n, "http://www.w3.org/XML/1998/namespace", "xml:lang", l); break; case "xmlSpace": Me(n, "http://www.w3.org/XML/1998/namespace", "xml:space", l); break; case "is": Ra(n, "is", l); break; case "innerText": case "textContent": break; default: (!(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N") && (a = oc.get(a) || a, Ra(n, a, l)) } } function Cm(n, s, a, l, f, m) { switch (a) { case "style": cl(n, l, m); break; case "dangerouslySetInnerHTML": if (l != null) { if (typeof l != "object" || !("__html" in l)) throw Error(r(61)); if (a = l.__html, a != null) { if (f.children != null) throw Error(r(60)); n.innerHTML = a } } break; case "children": typeof l == "string" ? vn(n, l) : (typeof l == "number" || typeof l == "bigint") && vn(n, "" + l); break; case "onScroll": l != null && kt("scroll", n); break; case "onScrollEnd": l != null && kt("scrollend", n); break; case "onClick": l != null && (n.onclick = si); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!il.hasOwnProperty(a)) t: { if (a[0] === "o" && a[1] === "n" && (f = a.endsWith("Capture"), s = a.slice(2, f ? a.length - 7 : void 0), m = n[Ge] || null, m = m != null ? m[a] : null, typeof m == "function" && n.removeEventListener(s, m, f), typeof l == "function")) { typeof m != "function" && m !== null && (a in n ? n[a] = null : n.hasAttribute(a) && n.removeAttribute(a)), n.addEventListener(s, l, f); break t } a in n ? n[a] = l : l === !0 ? n.setAttribute(a, "") : Ra(n, a, l) } } } function tn(n, s, a) { switch (s) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": kt("error", n), kt("load", n); var l = !1, f = !1, m; for (m in a) if (a.hasOwnProperty(m)) { var _ = a[m]; if (_ != null) switch (m) { case "src": l = !0; break; case "srcSet": f = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(r(137, s)); default: se(n, s, m, _, a, null) } } f && se(n, s, "srcSet", a.srcSet, a, null), l && se(n, s, "src", a.src, a, null); return; case "input": kt("invalid", n); var S = m = _ = f = null, V = null, q = null; for (l in a) if (a.hasOwnProperty(l)) { var W = a[l]; if (W != null) switch (l) { case "name": f = W; break; case "type": _ = W; break; case "checked": V = W; break; case "defaultChecked": q = W; break; case "value": m = W; break; case "defaultValue": S = W; break; case "children": case "dangerouslySetInnerHTML": if (W != null) throw Error(r(137, s)); break; default: se(n, s, l, W, a, null) } } sc(n, m, S, V, q, _, f, !1); return; case "select": kt("invalid", n), l = _ = m = null; for (f in a) if (a.hasOwnProperty(f) && (S = a[f], S != null)) switch (f) { case "value": m = S; break; case "defaultValue": _ = S; break; case "multiple": l = S; default: se(n, s, f, S, a, null) }s = m, a = _, n.multiple = !!l, s != null ? Vs(n, !!l, s, !1) : a != null && Vs(n, !!l, a, !0); return; case "textarea": kt("invalid", n), m = f = l = null; for (_ in a) if (a.hasOwnProperty(_) && (S = a[_], S != null)) switch (_) { case "value": l = S; break; case "defaultValue": f = S; break; case "children": m = S; break; case "dangerouslySetInnerHTML": if (S != null) throw Error(r(91)); break; default: se(n, s, _, S, a, null) }Ms(n, l, f, m); return; case "option": for (V in a) a.hasOwnProperty(V) && (l = a[V], l != null) && (V === "selected" ? n.selected = l && typeof l != "function" && typeof l != "symbol" : se(n, s, V, l, a, null)); return; case "dialog": kt("beforetoggle", n), kt("toggle", n), kt("cancel", n), kt("close", n); break; case "iframe": case "object": kt("load", n); break; case "video": case "audio": for (l = 0; l < Hl.length; l++)kt(Hl[l], n); break; case "image": kt("error", n), kt("load", n); break; case "details": kt("toggle", n); break; case "embed": case "source": case "link": kt("error", n), kt("load", n); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (q in a) if (a.hasOwnProperty(q) && (l = a[q], l != null)) switch (q) { case "children": case "dangerouslySetInnerHTML": throw Error(r(137, s)); default: se(n, s, q, l, a, null) }return; default: if (Va(s)) { for (W in a) a.hasOwnProperty(W) && (l = a[W], l !== void 0 && Cm(n, s, W, l, a, void 0)); return } }for (S in a) a.hasOwnProperty(S) && (l = a[S], l != null && se(n, s, S, l, a, null)) } function lx(n, s, a, l) { switch (s) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var f = null, m = null, _ = null, S = null, V = null, q = null, W = null; for (Y in a) { var tt = a[Y]; if (a.hasOwnProperty(Y) && tt != null) switch (Y) { case "checked": break; case "value": break; case "defaultValue": V = tt; default: l.hasOwnProperty(Y) || se(n, s, Y, null, l, tt) } } for (var H in l) { var Y = l[H]; if (tt = a[H], l.hasOwnProperty(H) && (Y != null || tt != null)) switch (H) { case "type": m = Y; break; case "name": f = Y; break; case "checked": q = Y; break; case "defaultChecked": W = Y; break; case "value": _ = Y; break; case "defaultValue": S = Y; break; case "children": case "dangerouslySetInnerHTML": if (Y != null) throw Error(r(137, s)); break; default: Y !== tt && se(n, s, H, Y, l, tt) } } Da(n, _, S, V, q, W, m, f); return; case "select": Y = _ = S = H = null; for (m in a) if (V = a[m], a.hasOwnProperty(m) && V != null) switch (m) { case "value": break; case "multiple": Y = V; default: l.hasOwnProperty(m) || se(n, s, m, null, l, V) }for (f in l) if (m = l[f], V = a[f], l.hasOwnProperty(f) && (m != null || V != null)) switch (f) { case "value": H = m; break; case "defaultValue": S = m; break; case "multiple": _ = m; default: m !== V && se(n, s, f, m, l, V) }s = S, a = _, l = Y, H != null ? Vs(n, !!a, H, !1) : !!l != !!a && (s != null ? Vs(n, !!a, s, !0) : Vs(n, !!a, a ? [] : "", !1)); return; case "textarea": Y = H = null; for (S in a) if (f = a[S], a.hasOwnProperty(S) && f != null && !l.hasOwnProperty(S)) switch (S) { case "value": break; case "children": break; default: se(n, s, S, null, l, f) }for (_ in l) if (f = l[_], m = a[_], l.hasOwnProperty(_) && (f != null || m != null)) switch (_) { case "value": H = f; break; case "defaultValue": Y = f; break; case "children": break; case "dangerouslySetInnerHTML": if (f != null) throw Error(r(91)); break; default: f !== m && se(n, s, _, f, l, m) }rc(n, H, Y); return; case "option": for (var mt in a) H = a[mt], a.hasOwnProperty(mt) && H != null && !l.hasOwnProperty(mt) && (mt === "selected" ? n.selected = !1 : se(n, s, mt, null, l, H)); for (V in l) H = l[V], Y = a[V], l.hasOwnProperty(V) && H !== Y && (H != null || Y != null) && (V === "selected" ? n.selected = H && typeof H != "function" && typeof H != "symbol" : se(n, s, V, H, l, Y)); return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var St in a) H = a[St], a.hasOwnProperty(St) && H != null && !l.hasOwnProperty(St) && se(n, s, St, null, l, H); for (q in l) if (H = l[q], Y = a[q], l.hasOwnProperty(q) && H !== Y && (H != null || Y != null)) switch (q) { case "children": case "dangerouslySetInnerHTML": if (H != null) throw Error(r(137, s)); break; default: se(n, s, q, H, l, Y) }return; default: if (Va(s)) { for (var re in a) H = a[re], a.hasOwnProperty(re) && H !== void 0 && !l.hasOwnProperty(re) && Cm(n, s, re, void 0, l, H); for (W in l) H = l[W], Y = a[W], !l.hasOwnProperty(W) || H === Y || H === void 0 && Y === void 0 || Cm(n, s, W, H, l, Y); return } }for (var L in a) H = a[L], a.hasOwnProperty(L) && H != null && !l.hasOwnProperty(L) && se(n, s, L, null, l, H); for (tt in l) H = l[tt], Y = a[tt], !l.hasOwnProperty(tt) || H === Y || H == null && Y == null || se(n, s, tt, H, l, Y) } function V_(n) { switch (n) { case "css": case "script": case "font": case "img": case "image": case "input": case "link": return !0; default: return !1 } } function ux() { if (typeof performance.getEntriesByType == "function") { for (var n = 0, s = 0, a = performance.getEntriesByType("resource"), l = 0; l < a.length; l++) { var f = a[l], m = f.transferSize, _ = f.initiatorType, S = f.duration; if (m && S && V_(_)) { for (_ = 0, S = f.responseEnd, l += 1; l < a.length; l++) { var V = a[l], q = V.startTime; if (q > S) break; var W = V.transferSize, tt = V.initiatorType; W && V_(tt) && (V = V.responseEnd, _ += W * (V < S ? 1 : (S - q) / (V - q))) } if (--l, s += 8 * (m + _) / (f.duration / 1e3), n++, 10 < n) break } } if (0 < n) return s / n / 1e6 } return navigator.connection && (n = navigator.connection.downlink, typeof n == "number") ? n : 5 } var Rm = null, Dm = null; function lh(n) { return n.nodeType === 9 ? n : n.ownerDocument } function M_(n) { switch (n) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function I_(n, s) { if (n === 0) switch (s) { case "svg": return 1; case "math": return 2; default: return 0 }return n === 1 && s === "foreignObject" ? 0 : n } function Vm(n, s) { return n === "textarea" || n === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.children == "bigint" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null } var Mm = null; function cx() { var n = window.event; return n && n.type === "popstate" ? n === Mm ? !1 : (Mm = n, !0) : (Mm = null, !1) } var O_ = typeof setTimeout == "function" ? setTimeout : void 0, hx = typeof clearTimeout == "function" ? clearTimeout : void 0, N_ = typeof Promise == "function" ? Promise : void 0, fx = typeof queueMicrotask == "function" ? queueMicrotask : typeof N_ < "u" ? function (n) { return N_.resolve(null).then(n).catch(dx) } : O_; function dx(n) { setTimeout(function () { throw n }) } function tr(n) { return n === "head" } function P_(n, s) { var a = s, l = 0; do { var f = a.nextSibling; if (n.removeChild(a), f && f.nodeType === 8) if (a = f.data, a === "/$" || a === "/&") { if (l === 0) { n.removeChild(f), ho(s); return } l-- } else if (a === "$" || a === "$?" || a === "$~" || a === "$!" || a === "&") l++; else if (a === "html") Yl(n.ownerDocument.documentElement); else if (a === "head") { a = n.ownerDocument.head, Yl(a); for (var m = a.firstChild; m;) { var _ = m.nextSibling, S = m.nodeName; m[Ai] || S === "SCRIPT" || S === "STYLE" || S === "LINK" && m.rel.toLowerCase() === "stylesheet" || a.removeChild(m), m = _ } } else a === "body" && Yl(n.ownerDocument.body); a = f } while (a); ho(s) } function k_(n, s) { var a = n; n = 0; do { var l = a.nextSibling; if (a.nodeType === 1 ? s ? (a._stashedDisplay = a.style.display, a.style.display = "none") : (a.style.display = a._stashedDisplay || "", a.getAttribute("style") === "" && a.removeAttribute("style")) : a.nodeType === 3 && (s ? (a._stashedText = a.nodeValue, a.nodeValue = "") : a.nodeValue = a._stashedText || ""), l && l.nodeType === 8) if (a = l.data, a === "/$") { if (n === 0) break; n-- } else a !== "$" && a !== "$?" && a !== "$~" && a !== "$!" || n++; a = l } while (a) } function Im(n) { var s = n.firstChild; for (s && s.nodeType === 10 && (s = s.nextSibling); s;) { var a = s; switch (s = s.nextSibling, a.nodeName) { case "HTML": case "HEAD": case "BODY": Im(a), Ca(a); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (a.rel.toLowerCase() === "stylesheet") continue }n.removeChild(a) } } function mx(n, s, a, l) { for (; n.nodeType === 1;) { var f = a; if (n.nodeName.toLowerCase() !== s.toLowerCase()) { if (!l && (n.nodeName !== "INPUT" || n.type !== "hidden")) break } else if (l) { if (!n[Ai]) switch (s) { case "meta": if (!n.hasAttribute("itemprop")) break; return n; case "link": if (m = n.getAttribute("rel"), m === "stylesheet" && n.hasAttribute("data-precedence")) break; if (m !== f.rel || n.getAttribute("href") !== (f.href == null || f.href === "" ? null : f.href) || n.getAttribute("crossorigin") !== (f.crossOrigin == null ? null : f.crossOrigin) || n.getAttribute("title") !== (f.title == null ? null : f.title)) break; return n; case "style": if (n.hasAttribute("data-precedence")) break; return n; case "script": if (m = n.getAttribute("src"), (m !== (f.src == null ? null : f.src) || n.getAttribute("type") !== (f.type == null ? null : f.type) || n.getAttribute("crossorigin") !== (f.crossOrigin == null ? null : f.crossOrigin)) && m && n.hasAttribute("async") && !n.hasAttribute("itemprop")) break; return n; default: return n } } else if (s === "input" && n.type === "hidden") { var m = f.name == null ? null : "" + f.name; if (f.type === "hidden" && n.getAttribute("name") === m) return n } else return n; if (n = Qn(n.nextSibling), n === null) break } return null } function px(n, s, a) { if (s === "") return null; for (; n.nodeType !== 3;)if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !a || (n = Qn(n.nextSibling), n === null)) return null; return n } function L_(n, s) { for (; n.nodeType !== 8;)if ((n.nodeType !== 1 || n.nodeName !== "INPUT" || n.type !== "hidden") && !s || (n = Qn(n.nextSibling), n === null)) return null; return n } function Om(n) { return n.data === "$?" || n.data === "$~" } function Nm(n) { return n.data === "$!" || n.data === "$?" && n.ownerDocument.readyState !== "loading" } function gx(n, s) { var a = n.ownerDocument; if (n.data === "$~") n._reactRetry = s; else if (n.data !== "$?" || a.readyState !== "loading") s(); else { var l = function () { s(), a.removeEventListener("DOMContentLoaded", l) }; a.addEventListener("DOMContentLoaded", l), n._reactRetry = l } } function Qn(n) { for (; n != null; n = n.nextSibling) { var s = n.nodeType; if (s === 1 || s === 3) break; if (s === 8) { if (s = n.data, s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&" || s === "F!" || s === "F") break; if (s === "/$" || s === "/&") return null } } return n } var Pm = null; function z_(n) { n = n.nextSibling; for (var s = 0; n;) { if (n.nodeType === 8) { var a = n.data; if (a === "/$" || a === "/&") { if (s === 0) return Qn(n.nextSibling); s-- } else a !== "$" && a !== "$!" && a !== "$?" && a !== "$~" && a !== "&" || s++ } n = n.nextSibling } return null } function j_(n) { n = n.previousSibling; for (var s = 0; n;) { if (n.nodeType === 8) { var a = n.data; if (a === "$" || a === "$!" || a === "$?" || a === "$~" || a === "&") { if (s === 0) return n; s-- } else a !== "/$" && a !== "/&" || s++ } n = n.previousSibling } return null } function U_(n, s, a) { switch (s = lh(a), n) { case "html": if (n = s.documentElement, !n) throw Error(r(452)); return n; case "head": if (n = s.head, !n) throw Error(r(453)); return n; case "body": if (n = s.body, !n) throw Error(r(454)); return n; default: throw Error(r(451)) } } function Yl(n) { for (var s = n.attributes; s.length;)n.removeAttributeNode(s[0]); Ca(n) } var Xn = new Map, B_ = new Set; function uh(n) { return typeof n.getRootNode == "function" ? n.getRootNode() : n.nodeType === 9 ? n : n.ownerDocument } var ys = rt.d; rt.d = { f: yx, r: vx, D: _x, C: bx, L: Tx, m: Ex, X: Ax, S: Sx, M: wx }; function yx() { var n = ys.f(), s = th(); return n || s } function vx(n) { var s = zn(n); s !== null && s.tag === 5 && s.type === "form" ? sv(s) : ys.r(n) } var lo = typeof document > "u" ? null : document; function F_(n, s, a) { var l = lo; if (l && typeof s == "string" && s) { var f = yn(s); f = 'link[rel="' + n + '"][href="' + f + '"]', typeof a == "string" && (f += '[crossorigin="' + a + '"]'), B_.has(f) || (B_.add(f), n = { rel: n, crossOrigin: a, href: s }, l.querySelector(f) === null && (s = l.createElement("link"), tn(s, "link", n), Ve(s), l.head.appendChild(s))) } } function _x(n) { ys.D(n), F_("dns-prefetch", n, null) } function bx(n, s) { ys.C(n, s), F_("preconnect", n, s) } function Tx(n, s, a) { ys.L(n, s, a); var l = lo; if (l && n && s) { var f = 'link[rel="preload"][as="' + yn(s) + '"]'; s === "image" && a && a.imageSrcSet ? (f += '[imagesrcset="' + yn(a.imageSrcSet) + '"]', typeof a.imageSizes == "string" && (f += '[imagesizes="' + yn(a.imageSizes) + '"]')) : f += '[href="' + yn(n) + '"]'; var m = f; switch (s) { case "style": m = uo(n); break; case "script": m = co(n) }Xn.has(m) || (n = b({ rel: "preload", href: s === "image" && a && a.imageSrcSet ? void 0 : n, as: s }, a), Xn.set(m, n), l.querySelector(f) !== null || s === "style" && l.querySelector(Kl(m)) || s === "script" && l.querySelector(Ql(m)) || (s = l.createElement("link"), tn(s, "link", n), Ve(s), l.head.appendChild(s))) } } function Ex(n, s) { ys.m(n, s); var a = lo; if (a && n) { var l = s && typeof s.as == "string" ? s.as : "script", f = 'link[rel="modulepreload"][as="' + yn(l) + '"][href="' + yn(n) + '"]', m = f; switch (l) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": m = co(n) }if (!Xn.has(m) && (n = b({ rel: "modulepreload", href: n }, s), Xn.set(m, n), a.querySelector(f) === null)) { switch (l) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (a.querySelector(Ql(m))) return }l = a.createElement("link"), tn(l, "link", n), Ve(l), a.head.appendChild(l) } } } function Sx(n, s, a) { ys.S(n, s, a); var l = lo; if (l && n) { var f = xi(l).hoistableStyles, m = uo(n); s = s || "default"; var _ = f.get(m); if (!_) { var S = { loading: 0, preload: null }; if (_ = l.querySelector(Kl(m))) S.loading = 5; else { n = b({ rel: "stylesheet", href: n, "data-precedence": s }, a), (a = Xn.get(m)) && km(n, a); var V = _ = l.createElement("link"); Ve(V), tn(V, "link", n), V._p = new Promise(function (q, W) { V.onload = q, V.onerror = W }), V.addEventListener("load", function () { S.loading |= 1 }), V.addEventListener("error", function () { S.loading |= 2 }), S.loading |= 4, ch(_, s, l) } _ = { type: "stylesheet", instance: _, count: 1, state: S }, f.set(m, _) } } } function Ax(n, s) { ys.X(n, s); var a = lo; if (a && n) { var l = xi(a).hoistableScripts, f = co(n), m = l.get(f); m || (m = a.querySelector(Ql(f)), m || (n = b({ src: n, async: !0 }, s), (s = Xn.get(f)) && Lm(n, s), m = a.createElement("script"), Ve(m), tn(m, "link", n), a.head.appendChild(m)), m = { type: "script", instance: m, count: 1, state: null }, l.set(f, m)) } } function wx(n, s) { ys.M(n, s); var a = lo; if (a && n) { var l = xi(a).hoistableScripts, f = co(n), m = l.get(f); m || (m = a.querySelector(Ql(f)), m || (n = b({ src: n, async: !0, type: "module" }, s), (s = Xn.get(f)) && Lm(n, s), m = a.createElement("script"), Ve(m), tn(m, "link", n), a.head.appendChild(m)), m = { type: "script", instance: m, count: 1, state: null }, l.set(f, m)) } } function q_(n, s, a, l) { var f = (f = Ct.current) ? uh(f) : null; if (!f) throw Error(r(446)); switch (n) { case "meta": case "title": return null; case "style": return typeof a.precedence == "string" && typeof a.href == "string" ? (s = uo(a.href), a = xi(f).hoistableStyles, l = a.get(s), l || (l = { type: "style", instance: null, count: 0, state: null }, a.set(s, l)), l) : { type: "void", instance: null, count: 0, state: null }; case "link": if (a.rel === "stylesheet" && typeof a.href == "string" && typeof a.precedence == "string") { n = uo(a.href); var m = xi(f).hoistableStyles, _ = m.get(n); if (_ || (f = f.ownerDocument || f, _ = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, m.set(n, _), (m = f.querySelector(Kl(n))) && !m._p && (_.instance = m, _.state.loading = 5), Xn.has(n) || (a = { rel: "preload", as: "style", href: a.href, crossOrigin: a.crossOrigin, integrity: a.integrity, media: a.media, hrefLang: a.hrefLang, referrerPolicy: a.referrerPolicy }, Xn.set(n, a), m || xx(f, n, a, _.state))), s && l === null) throw Error(r(528, "")); return _ } if (s && l !== null) throw Error(r(529, "")); return null; case "script": return s = a.async, a = a.src, typeof a == "string" && s && typeof s != "function" && typeof s != "symbol" ? (s = co(a), a = xi(f).hoistableScripts, l = a.get(s), l || (l = { type: "script", instance: null, count: 0, state: null }, a.set(s, l)), l) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(r(444, n)) } } function uo(n) { return 'href="' + yn(n) + '"' } function Kl(n) { return 'link[rel="stylesheet"][' + n + "]" } function H_(n) { return b({}, n, { "data-precedence": n.precedence, precedence: null }) } function xx(n, s, a, l) { n.querySelector('link[rel="preload"][as="style"][' + s + "]") ? l.loading = 1 : (s = n.createElement("link"), l.preload = s, s.addEventListener("load", function () { return l.loading |= 1 }), s.addEventListener("error", function () { return l.loading |= 2 }), tn(s, "link", a), Ve(s), n.head.appendChild(s)) } function co(n) { return '[src="' + yn(n) + '"]' } function Ql(n) { return "script[async]" + n } function G_(n, s, a) { if (s.count++, s.instance === null) switch (s.type) { case "style": var l = n.querySelector('style[data-href~="' + yn(a.href) + '"]'); if (l) return s.instance = l, Ve(l), l; var f = b({}, a, { "data-href": a.href, "data-precedence": a.precedence, href: null, precedence: null }); return l = (n.ownerDocument || n).createElement("style"), Ve(l), tn(l, "style", f), ch(l, a.precedence, n), s.instance = l; case "stylesheet": f = uo(a.href); var m = n.querySelector(Kl(f)); if (m) return s.state.loading |= 4, s.instance = m, Ve(m), m; l = H_(a), (f = Xn.get(f)) && km(l, f), m = (n.ownerDocument || n).createElement("link"), Ve(m); var _ = m; return _._p = new Promise(function (S, V) { _.onload = S, _.onerror = V }), tn(m, "link", l), s.state.loading |= 4, ch(m, a.precedence, n), s.instance = m; case "script": return m = co(a.src), (f = n.querySelector(Ql(m))) ? (s.instance = f, Ve(f), f) : (l = a, (f = Xn.get(m)) && (l = b({}, a), Lm(l, f)), n = n.ownerDocument || n, f = n.createElement("script"), Ve(f), tn(f, "link", l), n.head.appendChild(f), s.instance = f); case "void": return null; default: throw Error(r(443, s.type)) } else s.type === "stylesheet" && (s.state.loading & 4) === 0 && (l = s.instance, s.state.loading |= 4, ch(l, a.precedence, n)); return s.instance } function ch(n, s, a) { for (var l = a.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), f = l.length ? l[l.length - 1] : null, m = f, _ = 0; _ < l.length; _++) { var S = l[_]; if (S.dataset.precedence === s) m = S; else if (m !== f) break } m ? m.parentNode.insertBefore(n, m.nextSibling) : (s = a.nodeType === 9 ? a.head : a, s.insertBefore(n, s.firstChild)) } function km(n, s) { n.crossOrigin == null && (n.crossOrigin = s.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = s.referrerPolicy), n.title == null && (n.title = s.title) } function Lm(n, s) { n.crossOrigin == null && (n.crossOrigin = s.crossOrigin), n.referrerPolicy == null && (n.referrerPolicy = s.referrerPolicy), n.integrity == null && (n.integrity = s.integrity) } var hh = null; function Y_(n, s, a) { if (hh === null) { var l = new Map, f = hh = new Map; f.set(a, l) } else f = hh, l = f.get(a), l || (l = new Map, f.set(a, l)); if (l.has(n)) return l; for (l.set(n, null), a = a.getElementsByTagName(n), f = 0; f < a.length; f++) { var m = a[f]; if (!(m[Ai] || m[De] || n === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== "http://www.w3.org/2000/svg") { var _ = m.getAttribute(s) || ""; _ = n + _; var S = l.get(_); S ? S.push(m) : l.set(_, [m]) } } return l } function K_(n, s, a) { n = n.ownerDocument || n, n.head.insertBefore(a, s === "title" ? n.querySelector("head > title") : null) } function Cx(n, s, a) { if (a === 1 || s.itemProp != null) return !1; switch (n) { case "meta": case "title": return !0; case "style": if (typeof s.precedence != "string" || typeof s.href != "string" || s.href === "") break; return !0; case "link": if (typeof s.rel != "string" || typeof s.href != "string" || s.href === "" || s.onLoad || s.onError) break; return s.rel === "stylesheet" ? (n = s.disabled, typeof s.precedence == "string" && n == null) : !0; case "script": if (s.async && typeof s.async != "function" && typeof s.async != "symbol" && !s.onLoad && !s.onError && s.src && typeof s.src == "string") return !0 }return !1 } function Q_(n) { return !(n.type === "stylesheet" && (n.state.loading & 3) === 0) } function Rx(n, s, a, l) { if (a.type === "stylesheet" && (typeof l.media != "string" || matchMedia(l.media).matches !== !1) && (a.state.loading & 4) === 0) { if (a.instance === null) { var f = uo(l.href), m = s.querySelector(Kl(f)); if (m) { s = m._p, s !== null && typeof s == "object" && typeof s.then == "function" && (n.count++, n = fh.bind(n), s.then(n, n)), a.state.loading |= 4, a.instance = m, Ve(m); return } m = s.ownerDocument || s, l = H_(l), (f = Xn.get(f)) && km(l, f), m = m.createElement("link"), Ve(m); var _ = m; _._p = new Promise(function (S, V) { _.onload = S, _.onerror = V }), tn(m, "link", l), a.instance = m } n.stylesheets === null && (n.stylesheets = new Map), n.stylesheets.set(a, s), (s = a.state.preload) && (a.state.loading & 3) === 0 && (n.count++, a = fh.bind(n), s.addEventListener("load", a), s.addEventListener("error", a)) } } var zm = 0; function Dx(n, s) { return n.stylesheets && n.count === 0 && mh(n, n.stylesheets), 0 < n.count || 0 < n.imgCount ? function (a) { var l = setTimeout(function () { if (n.stylesheets && mh(n, n.stylesheets), n.unsuspend) { var m = n.unsuspend; n.unsuspend = null, m() } }, 6e4 + s); 0 < n.imgBytes && zm === 0 && (zm = 62500 * ux()); var f = setTimeout(function () { if (n.waitingForImages = !1, n.count === 0 && (n.stylesheets && mh(n, n.stylesheets), n.unsuspend)) { var m = n.unsuspend; n.unsuspend = null, m() } }, (n.imgBytes > zm ? 50 : 800) + s); return n.unsuspend = a, function () { n.unsuspend = null, clearTimeout(l), clearTimeout(f) } } : null } function fh() { if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) { if (this.stylesheets) mh(this, this.stylesheets); else if (this.unsuspend) { var n = this.unsuspend; this.unsuspend = null, n() } } } var dh = null; function mh(n, s) { n.stylesheets = null, n.unsuspend !== null && (n.count++, dh = new Map, s.forEach(Vx, n), dh = null, fh.call(n)) } function Vx(n, s) { if (!(s.state.loading & 4)) { var a = dh.get(n); if (a) var l = a.get(null); else { a = new Map, dh.set(n, a); for (var f = n.querySelectorAll("link[data-precedence],style[data-precedence]"), m = 0; m < f.length; m++) { var _ = f[m]; (_.nodeName === "LINK" || _.getAttribute("media") !== "not all") && (a.set(_.dataset.precedence, _), l = _) } l && a.set(null, l) } f = s.instance, _ = f.getAttribute("data-precedence"), m = a.get(_) || l, m === l && a.set(null, f), a.set(_, f), this.count++, l = fh.bind(this), f.addEventListener("load", l), f.addEventListener("error", l), m ? m.parentNode.insertBefore(f, m.nextSibling) : (n = n.nodeType === 9 ? n.head : n, n.insertBefore(f, n.firstChild)), s.state.loading |= 4 } } var Xl = { $$typeof: X, Provider: null, Consumer: null, _currentValue: et, _currentValue2: et, _threadCount: 0 }; function Mx(n, s, a, l, f, m, _, S, V) { this.tag = 1, this.containerInfo = n, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Ei(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ei(0), this.hiddenUpdates = Ei(null), this.identifierPrefix = l, this.onUncaughtError = f, this.onCaughtError = m, this.onRecoverableError = _, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = V, this.incompleteTransitions = new Map } function X_(n, s, a, l, f, m, _, S, V, q, W, tt) { return n = new Mx(n, s, a, _, V, q, W, tt, S), s = 1, m === !0 && (s |= 24), m = Dn(3, null, null, s), n.current = m, m.stateNode = n, s = yd(), s.refCount++, n.pooledCache = s, s.refCount++, m.memoizedState = { element: l, isDehydrated: a, cache: s }, Td(m), n } function W_(n) { return n ? (n = Ba, n) : Ba } function $_(n, s, a, l, f, m) { f = W_(f), l.context === null ? l.context = f : l.pendingContext = f, l = qs(s), l.payload = { element: a }, m = m === void 0 ? null : m, m !== null && (l.callback = m), a = Hs(n, l, s), a !== null && (Sn(a, n, s), Cl(a, n, s)) } function Z_(n, s) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { var a = n.retryLane; n.retryLane = a !== 0 && a < s ? a : s } } function jm(n, s) { Z_(n, s), (n = n.alternate) && Z_(n, s) } function J_(n) { if (n.tag === 13 || n.tag === 31) { var s = Xr(n, 67108864); s !== null && Sn(s, n, 67108864), jm(n, 67108864) } } function t1(n) { if (n.tag === 13 || n.tag === 31) { var s = Nn(); s = Lr(s); var a = Xr(n, s); a !== null && Sn(a, n, s), jm(n, s) } } var ph = !0; function Ix(n, s, a, l) { var f = Q.T; Q.T = null; var m = rt.p; try { rt.p = 2, Um(n, s, a, l) } finally { rt.p = m, Q.T = f } } function Ox(n, s, a, l) { var f = Q.T; Q.T = null; var m = rt.p; try { rt.p = 8, Um(n, s, a, l) } finally { rt.p = m, Q.T = f } } function Um(n, s, a, l) { if (ph) { var f = Bm(l); if (f === null) xm(n, s, l, gh, a), n1(n, l); else if (Px(f, n, s, a, l)) l.stopPropagation(); else if (n1(n, l), s & 4 && -1 < Nx.indexOf(n)) { for (; f !== null;) { var m = zn(f); if (m !== null) switch (m.tag) { case 3: if (m = m.stateNode, m.current.memoizedState.isDehydrated) { var _ = bi(m.pendingLanes); if (_ !== 0) { var S = m; for (S.pendingLanes |= 2, S.entangledLanes |= 2; _;) { var V = 1 << 31 - Te(_); S.entanglements[1] |= V, _ &= ~V } ji(m), (Qt & 6) === 0 && (Zc = fn() + 500, ql(0)) } } break; case 31: case 13: S = Xr(m, 2), S !== null && Sn(S, m, 2), th(), jm(m, 2) }if (m = Bm(l), m === null && xm(n, s, l, gh, a), m === f) break; f = m } f !== null && l.stopPropagation() } else xm(n, s, l, null, a) } } function Bm(n) { return n = jn(n), Fm(n) } var gh = null; function Fm(n) { if (gh = null, n = wi(n), n !== null) { var s = u(n); if (s === null) n = null; else { var a = s.tag; if (a === 13) { if (n = c(s), n !== null) return n; n = null } else if (a === 31) { if (n = d(s), n !== null) return n; n = null } else if (a === 3) { if (s.stateNode.current.memoizedState.isDehydrated) return s.tag === 3 ? s.stateNode.containerInfo : null; n = null } else s !== n && (n = null) } } return gh = n, null } function e1(n) { switch (n) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (Or()) { case Zo: return 2; case Jo: return 8; case Rs: case Qf: return 32; case Qu: return 268435456; default: return 32 }default: return 32 } } var qm = !1, er = null, nr = null, ir = null, Wl = new Map, $l = new Map, sr = [], Nx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function n1(n, s) { switch (n) { case "focusin": case "focusout": er = null; break; case "dragenter": case "dragleave": nr = null; break; case "mouseover": case "mouseout": ir = null; break; case "pointerover": case "pointerout": Wl.delete(s.pointerId); break; case "gotpointercapture": case "lostpointercapture": $l.delete(s.pointerId) } } function Zl(n, s, a, l, f, m) { return n === null || n.nativeEvent !== m ? (n = { blockedOn: s, domEventName: a, eventSystemFlags: l, nativeEvent: m, targetContainers: [f] }, s !== null && (s = zn(s), s !== null && J_(s)), n) : (n.eventSystemFlags |= l, s = n.targetContainers, f !== null && s.indexOf(f) === -1 && s.push(f), n) } function Px(n, s, a, l, f) { switch (s) { case "focusin": return er = Zl(er, n, s, a, l, f), !0; case "dragenter": return nr = Zl(nr, n, s, a, l, f), !0; case "mouseover": return ir = Zl(ir, n, s, a, l, f), !0; case "pointerover": var m = f.pointerId; return Wl.set(m, Zl(Wl.get(m) || null, n, s, a, l, f)), !0; case "gotpointercapture": return m = f.pointerId, $l.set(m, Zl($l.get(m) || null, n, s, a, l, f)), !0 }return !1 } function i1(n) { var s = wi(n.target); if (s !== null) { var a = u(s); if (a !== null) { if (s = a.tag, s === 13) { if (s = c(a), s !== null) { n.blockedOn = s, ni(n.priority, function () { t1(a) }); return } } else if (s === 31) { if (s = d(a), s !== null) { n.blockedOn = s, ni(n.priority, function () { t1(a) }); return } } else if (s === 3 && a.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null; return } } } n.blockedOn = null } function yh(n) { if (n.blockedOn !== null) return !1; for (var s = n.targetContainers; 0 < s.length;) { var a = Bm(n.nativeEvent); if (a === null) { a = n.nativeEvent; var l = new a.constructor(a.type, a); hl = l, a.target.dispatchEvent(l), hl = null } else return s = zn(a), s !== null && J_(s), n.blockedOn = a, !1; s.shift() } return !0 } function s1(n, s, a) { yh(n) && a.delete(s) } function kx() { qm = !1, er !== null && yh(er) && (er = null), nr !== null && yh(nr) && (nr = null), ir !== null && yh(ir) && (ir = null), Wl.forEach(s1), $l.forEach(s1) } function vh(n, s) { n.blockedOn === s && (n.blockedOn = null, qm || (qm = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, kx))) } var _h = null; function r1(n) { _h !== n && (_h = n, e.unstable_scheduleCallback(e.unstable_NormalPriority, function () { _h === n && (_h = null); for (var s = 0; s < n.length; s += 3) { var a = n[s], l = n[s + 1], f = n[s + 2]; if (typeof l != "function") { if (Fm(l || a) === null) continue; break } var m = zn(a); m !== null && (n.splice(s, 3), s -= 3, Bd(m, { pending: !0, data: f, method: a.method, action: l }, l, f)) } })) } function ho(n) { function s(V) { return vh(V, n) } er !== null && vh(er, n), nr !== null && vh(nr, n), ir !== null && vh(ir, n), Wl.forEach(s), $l.forEach(s); for (var a = 0; a < sr.length; a++) { var l = sr[a]; l.blockedOn === n && (l.blockedOn = null) } for (; 0 < sr.length && (a = sr[0], a.blockedOn === null);)i1(a), a.blockedOn === null && sr.shift(); if (a = (n.ownerDocument || n).$$reactFormReplay, a != null) for (l = 0; l < a.length; l += 3) { var f = a[l], m = a[l + 1], _ = f[Ge] || null; if (typeof m == "function") _ || r1(a); else if (_) { var S = null; if (m && m.hasAttribute("formAction")) { if (f = m, _ = m[Ge] || null) S = _.formAction; else if (Fm(f) !== null) continue } else S = _.action; typeof S == "function" ? a[l + 1] = S : (a.splice(l, 3), l -= 3), r1(a) } } } function a1() { function n(m) { m.canIntercept && m.info === "react-transition" && m.intercept({ handler: function () { return new Promise(function (_) { return f = _ }) }, focusReset: "manual", scroll: "manual" }) } function s() { f !== null && (f(), f = null), l || setTimeout(a, 20) } function a() { if (!l && !navigation.transition) { var m = navigation.currentEntry; m && m.url != null && navigation.navigate(m.url, { state: m.getState(), info: "react-transition", history: "replace" }) } } if (typeof navigation == "object") { var l = !1, f = null; return navigation.addEventListener("navigate", n), navigation.addEventListener("navigatesuccess", s), navigation.addEventListener("navigateerror", s), setTimeout(a, 100), function () { l = !0, navigation.removeEventListener("navigate", n), navigation.removeEventListener("navigatesuccess", s), navigation.removeEventListener("navigateerror", s), f !== null && (f(), f = null) } } } function Hm(n) { this._internalRoot = n } bh.prototype.render = Hm.prototype.render = function (n) { var s = this._internalRoot; if (s === null) throw Error(r(409)); var a = s.current, l = Nn(); $_(a, l, n, s, null, null) }, bh.prototype.unmount = Hm.prototype.unmount = function () { var n = this._internalRoot; if (n !== null) { this._internalRoot = null; var s = n.containerInfo; $_(n.current, 2, null, n, null, null), th(), s[Si] = null } }; function bh(n) { this._internalRoot = n } bh.prototype.unstable_scheduleHydration = function (n) { if (n) { var s = tc(); n = { blockedOn: null, target: n, priority: s }; for (var a = 0; a < sr.length && s !== 0 && s < sr[a].priority; a++); sr.splice(a, 0, n), a === 0 && i1(n) } }; var o1 = t.version; if (o1 !== "19.2.4") throw Error(r(527, o1, "19.2.4")); rt.findDOMNode = function (n) { var s = n._reactInternals; if (s === void 0) throw typeof n.render == "function" ? Error(r(188)) : (n = Object.keys(n).join(","), Error(r(268, n))); return n = g(s), n = n !== null ? v(n) : null, n = n === null ? null : n.stateNode, n }; var Lx = { bundleType: 0, version: "19.2.4", rendererPackageName: "react-dom", currentDispatcherRef: Q, reconcilerVersion: "19.2.4" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Th = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Th.isDisabled && Th.supportsFiber) try { ti = Th.inject(Lx), Xe = Th } catch { } } return tu.createRoot = function (n, s) { if (!o(n)) throw Error(r(299)); var a = !1, l = "", f = mv, m = pv, _ = gv; return s != null && (s.unstable_strictMode === !0 && (a = !0), s.identifierPrefix !== void 0 && (l = s.identifierPrefix), s.onUncaughtError !== void 0 && (f = s.onUncaughtError), s.onCaughtError !== void 0 && (m = s.onCaughtError), s.onRecoverableError !== void 0 && (_ = s.onRecoverableError)), s = X_(n, 1, !1, null, null, a, l, null, f, m, _, a1), n[Si] = s.current, wm(n), new Hm(s) }, tu.hydrateRoot = function (n, s, a) { if (!o(n)) throw Error(r(299)); var l = !1, f = "", m = mv, _ = pv, S = gv, V = null; return a != null && (a.unstable_strictMode === !0 && (l = !0), a.identifierPrefix !== void 0 && (f = a.identifierPrefix), a.onUncaughtError !== void 0 && (m = a.onUncaughtError), a.onCaughtError !== void 0 && (_ = a.onCaughtError), a.onRecoverableError !== void 0 && (S = a.onRecoverableError), a.formState !== void 0 && (V = a.formState)), s = X_(n, 1, !0, s, a ?? null, l, f, V, m, _, S, a1), s.context = W_(null), a = s.current, l = Nn(), l = Lr(l), f = qs(l), f.callback = null, Hs(a, f, l), a = l, s.current.lanes = a, Pr(s, a), ji(s), n[Si] = s.current, wm(n), new bh(s) }, tu.version = "19.2.4", tu
} var y1; function Qx() { if (y1) return Km.exports; y1 = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), Km.exports = Kx(), Km.exports } var Xx = Qx(); const Eg = J.createContext({}); function Sg(e) { const t = J.useRef(null); return t.current === null && (t.current = e()), t.current } const cE = typeof window < "u", hE = cE ? J.useLayoutEffect : J.useEffect, Af = J.createContext(null); function Ag(e, t) { e.indexOf(t) === -1 && e.push(t) } function wg(e, t) { const i = e.indexOf(t); i > -1 && e.splice(i, 1) } const Xi = (e, t, i) => i > t ? t : i < e ? e : i; let xg = () => { }; const Es = {}, fE = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); function dE(e) { return typeof e == "object" && e !== null } const mE = e => /^0[^.\s]+$/u.test(e); function Cg(e) { let t; return () => (t === void 0 && (t = e()), t) } const Zn = e => e, Wx = (e, t) => i => t(e(i)), ku = (...e) => e.reduce(Wx), bu = (e, t, i) => { const r = t - e; return r === 0 ? 1 : (i - e) / r }; class Rg { constructor() { this.subscriptions = [] } add(t) { return Ag(this.subscriptions, t), () => wg(this.subscriptions, t) } notify(t, i, r) { const o = this.subscriptions.length; if (o) if (o === 1) this.subscriptions[0](t, i, r); else for (let u = 0; u < o; u++) { const c = this.subscriptions[u]; c && c(t, i, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Hi = e => e * 1e3, $n = e => e / 1e3; function pE(e, t) { return t ? e * (1e3 / t) : 0 } const gE = (e, t, i) => (((1 - 3 * i + 3 * t) * e + (3 * i - 6 * t)) * e + 3 * t) * e, $x = 1e-7, Zx = 12; function Jx(e, t, i, r, o) { let u, c, d = 0; do c = t + (i - t) / 2, u = gE(c, r, o) - e, u > 0 ? i = c : t = c; while (Math.abs(u) > $x && ++d < Zx); return c } function Lu(e, t, i, r) { if (e === t && i === r) return Zn; const o = u => Jx(u, 0, 1, e, i); return u => u === 0 || u === 1 ? u : gE(o(u), t, r) } const yE = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, vE = e => t => 1 - e(1 - t), _E = Lu(.33, 1.53, .69, .99), Dg = vE(_E), bE = yE(Dg), TE = e => (e *= 2) < 1 ? .5 * Dg(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), Vg = e => 1 - Math.sin(Math.acos(e)), EE = vE(Vg), SE = yE(Vg), tC = Lu(.42, 0, 1, 1), eC = Lu(0, 0, .58, 1), AE = Lu(.42, 0, .58, 1), nC = e => Array.isArray(e) && typeof e[0] != "number", wE = e => Array.isArray(e) && typeof e[0] == "number", iC = { linear: Zn, easeIn: tC, easeInOut: AE, easeOut: eC, circIn: Vg, circInOut: SE, circOut: EE, backIn: Dg, backInOut: bE, backOut: _E, anticipate: TE }, sC = e => typeof e == "string", v1 = e => { if (wE(e)) { xg(e.length === 4); const [t, i, r, o] = e; return Lu(t, i, r, o) } else if (sC(e)) return iC[e]; return e }, Eh = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"]; function rC(e, t) { let i = new Set, r = new Set, o = !1, u = !1; const c = new WeakSet; let d = { delta: 0, timestamp: 0, isProcessing: !1 }; function p(v) { c.has(v) && (g.schedule(v), e()), v(d) } const g = { schedule: (v, b = !1, E = !1) => { const M = E && o ? i : r; return b && c.add(v), M.has(v) || M.add(v), v }, cancel: v => { r.delete(v), c.delete(v) }, process: v => { if (d = v, o) { u = !0; return } o = !0, [i, r] = [r, i], i.forEach(p), i.clear(), o = !1, u && (u = !1, g.process(v)) } }; return g } const aC = 40; function xE(e, t) { let i = !1, r = !0; const o = { delta: 0, timestamp: 0, isProcessing: !1 }, u = () => i = !0, c = Eh.reduce((X, at) => (X[at] = rC(u), X), {}), { setup: d, read: p, resolveKeyframes: g, preUpdate: v, update: b, preRender: E, render: x, postRender: M } = c, j = () => { const X = Es.useManualTiming ? o.timestamp : performance.now(); i = !1, Es.useManualTiming || (o.delta = r ? 1e3 / 60 : Math.max(Math.min(X - o.timestamp, aC), 1)), o.timestamp = X, o.isProcessing = !0, d.process(o), p.process(o), g.process(o), v.process(o), b.process(o), E.process(o), x.process(o), M.process(o), o.isProcessing = !1, i && t && (r = !1, e(j)) }, z = () => { i = !0, r = !0, o.isProcessing || e(j) }; return { schedule: Eh.reduce((X, at) => { const lt = c[at]; return X[at] = (ht, R = !1, A = !1) => (i || z(), lt.schedule(ht, R, A)), X }, {}), cancel: X => { for (let at = 0; at < Eh.length; at++)c[Eh[at]].cancel(X) }, state: o, steps: c } } const { schedule: le, cancel: vr, state: en, steps: $m } = xE(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Zn, !0); let Nh; function oC() { Nh = void 0 } const pn = { now: () => (Nh === void 0 && pn.set(en.isProcessing || Es.useManualTiming ? en.timestamp : performance.now()), Nh), set: e => { Nh = e, queueMicrotask(oC) } }, CE = e => t => typeof t == "string" && t.startsWith(e), RE = CE("--"), lC = CE("var(--"), Mg = e => lC(e) ? uC.test(e.split("/*")[0].trim()) : !1, uC = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function _1(e) { return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--") } const zo = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Tu = { ...zo, transform: e => Xi(0, 1, e) }, Sh = { ...zo, default: 1 }, hu = e => Math.round(e * 1e5) / 1e5, Ig = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function cC(e) { return e == null } const hC = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Og = (e, t) => i => !!(typeof i == "string" && hC.test(i) && i.startsWith(e) || t && !cC(i) && Object.prototype.hasOwnProperty.call(i, t)), DE = (e, t, i) => r => { if (typeof r != "string") return r; const [o, u, c, d] = r.match(Ig); return { [e]: parseFloat(o), [t]: parseFloat(u), [i]: parseFloat(c), alpha: d !== void 0 ? parseFloat(d) : 1 } }, fC = e => Xi(0, 255, e), Zm = { ...zo, transform: e => Math.round(fC(e)) }, da = { test: Og("rgb", "red"), parse: DE("red", "green", "blue"), transform: ({ red: e, green: t, blue: i, alpha: r = 1 }) => "rgba(" + Zm.transform(e) + ", " + Zm.transform(t) + ", " + Zm.transform(i) + ", " + hu(Tu.transform(r)) + ")" }; function dC(e) { let t = "", i = "", r = "", o = ""; return e.length > 5 ? (t = e.substring(1, 3), i = e.substring(3, 5), r = e.substring(5, 7), o = e.substring(7, 9)) : (t = e.substring(1, 2), i = e.substring(2, 3), r = e.substring(3, 4), o = e.substring(4, 5), t += t, i += i, r += r, o += o), { red: parseInt(t, 16), green: parseInt(i, 16), blue: parseInt(r, 16), alpha: o ? parseInt(o, 16) / 255 : 1 } } const xp = { test: Og("#"), parse: dC, transform: da.transform }, zu = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), lr = zu("deg"), Gi = zu("%"), yt = zu("px"), mC = zu("vh"), pC = zu("vw"), b1 = { ...Gi, parse: e => Gi.parse(e) / 100, transform: e => Gi.transform(e * 100) }, bo = { test: Og("hsl", "hue"), parse: DE("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: i, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Gi.transform(hu(t)) + ", " + Gi.transform(hu(i)) + ", " + hu(Tu.transform(r)) + ")" }, Le = { test: e => da.test(e) || xp.test(e) || bo.test(e), parse: e => da.test(e) ? da.parse(e) : bo.test(e) ? bo.parse(e) : xp.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? da.transform(e) : bo.transform(e), getAnimatableNone: e => { const t = Le.parse(e); return t.alpha = 0, Le.transform(t) } }, gC = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function yC(e) { return isNaN(e) && typeof e == "string" && (e.match(Ig)?.length || 0) + (e.match(gC)?.length || 0) > 0 } const VE = "number", ME = "color", vC = "var", _C = "var(", T1 = "${}", bC = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Eu(e) { const t = e.toString(), i = [], r = { color: [], number: [], var: [] }, o = []; let u = 0; const d = t.replace(bC, p => (Le.test(p) ? (r.color.push(u), o.push(ME), i.push(Le.parse(p))) : p.startsWith(_C) ? (r.var.push(u), o.push(vC), i.push(p)) : (r.number.push(u), o.push(VE), i.push(parseFloat(p))), ++u, T1)).split(T1); return { values: i, split: d, indexes: r, types: o } } function IE(e) { return Eu(e).values } function OE(e) { const { split: t, types: i } = Eu(e), r = t.length; return o => { let u = ""; for (let c = 0; c < r; c++)if (u += t[c], o[c] !== void 0) { const d = i[c]; d === VE ? u += hu(o[c]) : d === ME ? u += Le.transform(o[c]) : u += o[c] } return u } } const TC = e => typeof e == "number" ? 0 : Le.test(e) ? Le.getAnimatableNone(e) : e; function EC(e) { const t = IE(e); return OE(e)(t.map(TC)) } const _r = { test: yC, parse: IE, createTransformer: OE, getAnimatableNone: EC }; function Jm(e, t, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e } function SC({ hue: e, saturation: t, lightness: i, alpha: r }) { e /= 360, t /= 100, i /= 100; let o = 0, u = 0, c = 0; if (!t) o = u = c = i; else { const d = i < .5 ? i * (1 + t) : i + t - i * t, p = 2 * i - d; o = Jm(p, d, e + 1 / 3), u = Jm(p, d, e), c = Jm(p, d, e - 1 / 3) } return { red: Math.round(o * 255), green: Math.round(u * 255), blue: Math.round(c * 255), alpha: r } } function Qh(e, t) { return i => i > 0 ? t : e } const pe = (e, t, i) => e + (t - e) * i, tp = (e, t, i) => { const r = e * e, o = i * (t * t - r) + r; return o < 0 ? 0 : Math.sqrt(o) }, AC = [xp, da, bo], wC = e => AC.find(t => t.test(e)); function E1(e) { const t = wC(e); if (!t) return !1; let i = t.parse(e); return t === bo && (i = SC(i)), i } const S1 = (e, t) => { const i = E1(e), r = E1(t); if (!i || !r) return Qh(e, t); const o = { ...i }; return u => (o.red = tp(i.red, r.red, u), o.green = tp(i.green, r.green, u), o.blue = tp(i.blue, r.blue, u), o.alpha = pe(i.alpha, r.alpha, u), da.transform(o)) }, Cp = new Set(["none", "hidden"]); function xC(e, t) { return Cp.has(e) ? i => i <= 0 ? e : t : i => i >= 1 ? t : e } function CC(e, t) { return i => pe(e, t, i) } function Ng(e) { return typeof e == "number" ? CC : typeof e == "string" ? Mg(e) ? Qh : Le.test(e) ? S1 : VC : Array.isArray(e) ? NE : typeof e == "object" ? Le.test(e) ? S1 : RC : Qh } function NE(e, t) { const i = [...e], r = i.length, o = e.map((u, c) => Ng(u)(u, t[c])); return u => { for (let c = 0; c < r; c++)i[c] = o[c](u); return i } } function RC(e, t) { const i = { ...e, ...t }, r = {}; for (const o in i) e[o] !== void 0 && t[o] !== void 0 && (r[o] = Ng(e[o])(e[o], t[o])); return o => { for (const u in r) i[u] = r[u](o); return i } } function DC(e, t) { const i = [], r = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { const u = t.types[o], c = e.indexes[u][r[u]], d = e.values[c] ?? 0; i[o] = d, r[u]++ } return i } const VC = (e, t) => { const i = _r.createTransformer(t), r = Eu(e), o = Eu(t); return r.indexes.var.length === o.indexes.var.length && r.indexes.color.length === o.indexes.color.length && r.indexes.number.length >= o.indexes.number.length ? Cp.has(e) && !o.values.length || Cp.has(t) && !r.values.length ? xC(e, t) : ku(NE(DC(r, o), o.values), i) : Qh(e, t) }; function PE(e, t, i) { return typeof e == "number" && typeof t == "number" && typeof i == "number" ? pe(e, t, i) : Ng(e)(e, t) } const MC = e => { const t = ({ timestamp: i }) => e(i); return { start: (i = !0) => le.update(t, i), stop: () => vr(t), now: () => en.isProcessing ? en.timestamp : pn.now() } }, kE = (e, t, i = 10) => { let r = ""; const o = Math.max(Math.round(t / i), 2); for (let u = 0; u < o; u++)r += Math.round(e(u / (o - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, Xh = 2e4; function Pg(e) { let t = 0; const i = 50; let r = e.next(t); for (; !r.done && t < Xh;)t += i, r = e.next(t); return t >= Xh ? 1 / 0 : t } function IC(e, t = 100, i) { const r = i({ ...e, keyframes: [0, t] }), o = Math.min(Pg(r), Xh); return { type: "keyframes", ease: u => r.next(o * u).value / t, duration: $n(o) } } const OC = 5; function LE(e, t, i) { const r = Math.max(t - OC, 0); return pE(i - e(r), t - r) } const be = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, ep = .001; function NC({ duration: e = be.duration, bounce: t = be.bounce, velocity: i = be.velocity, mass: r = be.mass }) { let o, u, c = 1 - t; c = Xi(be.minDamping, be.maxDamping, c), e = Xi(be.minDuration, be.maxDuration, $n(e)), c < 1 ? (o = g => { const v = g * c, b = v * e, E = v - i, x = Rp(g, c), M = Math.exp(-b); return ep - E / x * M }, u = g => { const b = g * c * e, E = b * i + i, x = Math.pow(c, 2) * Math.pow(g, 2) * e, M = Math.exp(-b), j = Rp(Math.pow(g, 2), c); return (-o(g) + ep > 0 ? -1 : 1) * ((E - x) * M) / j }) : (o = g => { const v = Math.exp(-g * e), b = (g - i) * e + 1; return -ep + v * b }, u = g => { const v = Math.exp(-g * e), b = (i - g) * (e * e); return v * b }); const d = 5 / e, p = kC(o, u, d); if (e = Hi(e), isNaN(p)) return { stiffness: be.stiffness, damping: be.damping, duration: e }; { const g = Math.pow(p, 2) * r; return { stiffness: g, damping: c * 2 * Math.sqrt(r * g), duration: e } } } const PC = 12; function kC(e, t, i) { let r = i; for (let o = 1; o < PC; o++)r = r - e(r) / t(r); return r } function Rp(e, t) { return e * Math.sqrt(1 - t * t) } const LC = ["duration", "bounce"], zC = ["stiffness", "damping", "mass"]; function A1(e, t) { return t.some(i => e[i] !== void 0) } function jC(e) { let t = { velocity: be.velocity, stiffness: be.stiffness, damping: be.damping, mass: be.mass, isResolvedFromDuration: !1, ...e }; if (!A1(e, zC) && A1(e, LC)) if (e.visualDuration) { const i = e.visualDuration, r = 2 * Math.PI / (i * 1.2), o = r * r, u = 2 * Xi(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o); t = { ...t, mass: be.mass, stiffness: o, damping: u } } else { const i = NC(e); t = { ...t, ...i, mass: be.mass }, t.isResolvedFromDuration = !0 } return t } function Wh(e = be.visualDuration, t = be.bounce) { const i = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: o } = i; const u = i.keyframes[0], c = i.keyframes[i.keyframes.length - 1], d = { done: !1, value: u }, { stiffness: p, damping: g, mass: v, duration: b, velocity: E, isResolvedFromDuration: x } = jC({ ...i, velocity: -$n(i.velocity || 0) }), M = E || 0, j = g / (2 * Math.sqrt(p * v)), z = c - u, K = $n(Math.sqrt(p / v)), it = Math.abs(z) < 5; r || (r = it ? be.restSpeed.granular : be.restSpeed.default), o || (o = it ? be.restDelta.granular : be.restDelta.default); let X; if (j < 1) { const lt = Rp(K, j); X = ht => { const R = Math.exp(-j * K * ht); return c - R * ((M + j * K * z) / lt * Math.sin(lt * ht) + z * Math.cos(lt * ht)) } } else if (j === 1) X = lt => c - Math.exp(-K * lt) * (z + (M + K * z) * lt); else { const lt = K * Math.sqrt(j * j - 1); X = ht => { const R = Math.exp(-j * K * ht), A = Math.min(lt * ht, 300); return c - R * ((M + j * K * z) * Math.sinh(A) + lt * z * Math.cosh(A)) / lt } } const at = { calculatedDuration: x && b || null, next: lt => { const ht = X(lt); if (x) d.done = lt >= b; else { let R = lt === 0 ? M : 0; j < 1 && (R = lt === 0 ? Hi(M) : LE(X, lt, ht)); const A = Math.abs(R) <= r, C = Math.abs(c - ht) <= o; d.done = A && C } return d.value = d.done ? c : ht, d }, toString: () => { const lt = Math.min(Pg(at), Xh), ht = kE(R => at.next(lt * R).value, lt, 30); return lt + "ms " + ht }, toTransition: () => { } }; return at } Wh.applyToOptions = e => { const t = IC(e, 100, Wh); return e.ease = t.ease, e.duration = Hi(t.duration), e.type = "keyframes", e }; function Dp({ keyframes: e, velocity: t = 0, power: i = .8, timeConstant: r = 325, bounceDamping: o = 10, bounceStiffness: u = 500, modifyTarget: c, min: d, max: p, restDelta: g = .5, restSpeed: v }) { const b = e[0], E = { done: !1, value: b }, x = A => d !== void 0 && A < d || p !== void 0 && A > p, M = A => d === void 0 ? p : p === void 0 || Math.abs(d - A) < Math.abs(p - A) ? d : p; let j = i * t; const z = b + j, K = c === void 0 ? z : c(z); K !== z && (j = K - b); const it = A => -j * Math.exp(-A / r), X = A => K + it(A), at = A => { const C = it(A), O = X(A); E.done = Math.abs(C) <= g, E.value = E.done ? K : O }; let lt, ht; const R = A => { x(E.value) && (lt = A, ht = Wh({ keyframes: [E.value, M(E.value)], velocity: LE(X, A, E.value), damping: o, stiffness: u, restDelta: g, restSpeed: v })) }; return R(0), { calculatedDuration: null, next: A => { let C = !1; return !ht && lt === void 0 && (C = !0, at(A), R(A)), lt !== void 0 && A >= lt ? ht.next(A - lt) : (!C && at(A), E) } } } function UC(e, t, i) { const r = [], o = i || Es.mix || PE, u = e.length - 1; for (let c = 0; c < u; c++) { let d = o(e[c], e[c + 1]); if (t) { const p = Array.isArray(t) ? t[c] || Zn : t; d = ku(p, d) } r.push(d) } return r } function BC(e, t, { clamp: i = !0, ease: r, mixer: o } = {}) { const u = e.length; if (xg(u === t.length), u === 1) return () => t[0]; if (u === 2 && t[0] === t[1]) return () => t[1]; const c = e[0] === e[1]; e[0] > e[u - 1] && (e = [...e].reverse(), t = [...t].reverse()); const d = UC(t, r, o), p = d.length, g = v => { if (c && v < e[0]) return t[0]; let b = 0; if (p > 1) for (; b < e.length - 2 && !(v < e[b + 1]); b++); const E = bu(e[b], e[b + 1], v); return d[b](E) }; return i ? v => g(Xi(e[0], e[u - 1], v)) : g } function FC(e, t) { const i = e[e.length - 1]; for (let r = 1; r <= t; r++) { const o = bu(0, t, r); e.push(pe(i, 1, o)) } } function qC(e) { const t = [0]; return FC(t, e.length - 1), t } function HC(e, t) { return e.map(i => i * t) } function GC(e, t) { return e.map(() => t || AE).splice(0, e.length - 1) } function fu({ duration: e = 300, keyframes: t, times: i, ease: r = "easeInOut" }) { const o = nC(r) ? r.map(v1) : v1(r), u = { done: !1, value: t[0] }, c = HC(i && i.length === t.length ? i : qC(t), e), d = BC(c, t, { ease: Array.isArray(o) ? o : GC(t, o) }); return { calculatedDuration: e, next: p => (u.value = d(p), u.done = p >= e, u) } } const YC = e => e !== null; function kg(e, { repeat: t, repeatType: i = "loop" }, r, o = 1) { const u = e.filter(YC), d = o < 0 || t && i !== "loop" && t % 2 === 1 ? 0 : u.length - 1; return !d || r === void 0 ? u[d] : r } const KC = { decay: Dp, inertia: Dp, tween: fu, keyframes: fu, spring: Wh }; function zE(e) { typeof e.type == "string" && (e.type = KC[e.type]) } class Lg { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(t => { this.resolve = t }) } notifyFinished() { this.resolve() } then(t, i) { return this.finished.then(t, i) } } const QC = e => e / 100; class zg extends Lg { constructor(t) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { const { motionValue: i } = this.options; i && i.updatedAt !== pn.now() && this.tick(pn.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.()) }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause() } initAnimation() { const { options: t } = this; zE(t); const { type: i = fu, repeat: r = 0, repeatDelay: o = 0, repeatType: u, velocity: c = 0 } = t; let { keyframes: d } = t; const p = i || fu; p !== fu && typeof d[0] != "number" && (this.mixKeyframes = ku(QC, PE(d[0], d[1])), d = [0, 100]); const g = p({ ...t, keyframes: d }); u === "mirror" && (this.mirroredGenerator = p({ ...t, keyframes: [...d].reverse(), velocity: -c })), g.calculatedDuration === null && (g.calculatedDuration = Pg(g)); const { calculatedDuration: v } = g; this.calculatedDuration = v, this.resolvedDuration = v + o, this.totalDuration = this.resolvedDuration * (r + 1) - o, this.generator = g } updateTime(t) { const i = Math.round(t - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = i } tick(t, i = !1) { const { generator: r, totalDuration: o, mixKeyframes: u, mirroredGenerator: c, resolvedDuration: d, calculatedDuration: p } = this; if (this.startTime === null) return r.next(0); const { delay: g = 0, keyframes: v, repeat: b, repeatType: E, repeatDelay: x, type: M, onUpdate: j, finalKeyframe: z } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - o / this.speed, this.startTime)), i ? this.currentTime = t : this.updateTime(t); const K = this.currentTime - g * (this.playbackSpeed >= 0 ? 1 : -1), it = this.playbackSpeed >= 0 ? K < 0 : K > o; this.currentTime = Math.max(K, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = o); let X = this.currentTime, at = r; if (b) { const A = Math.min(this.currentTime, o) / d; let C = Math.floor(A), O = A % 1; !O && A >= 1 && (O = 1), O === 1 && C--, C = Math.min(C, b + 1), C % 2 && (E === "reverse" ? (O = 1 - O, x && (O -= x / d)) : E === "mirror" && (at = c)), X = Xi(0, 1, O) * d } const lt = it ? { done: !1, value: v[0] } : at.next(X); u && (lt.value = u(lt.value)); let { done: ht } = lt; !it && p !== null && (ht = this.playbackSpeed >= 0 ? this.currentTime >= o : this.currentTime <= 0); const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && ht); return R && M !== Dp && (lt.value = kg(v, this.options, z, this.speed)), j && j(lt.value), R && this.finish(), lt } then(t, i) { return this.finished.then(t, i) } get duration() { return $n(this.calculatedDuration) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + $n(t) } get time() { return $n(this.currentTime) } set time(t) { t = Hi(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1) } get speed() { return this.playbackSpeed } set speed(t) { this.updateTime(pn.now()); const i = this.playbackSpeed !== t; this.playbackSpeed = t, i && (this.time = $n(this.currentTime)) } play() { if (this.isStopped) return; const { driver: t = MC, startTime: i } = this.options; this.driver || (this.driver = t(o => this.tick(o))), this.options.onPlay?.(); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = i ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(pn.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.() } cancel() { this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.() } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } attachTimeline(t) { return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this) } } function XC(e) { for (let t = 1; t < e.length; t++)e[t] ?? (e[t] = e[t - 1]) } const ma = e => e * 180 / Math.PI, Vp = e => { const t = ma(Math.atan2(e[1], e[0])); return Mp(t) }, WC = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2, rotate: Vp, rotateZ: Vp, skewX: e => ma(Math.atan(e[1])), skewY: e => ma(Math.atan(e[2])), skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2 }, Mp = e => (e = e % 360, e < 0 && (e += 360), e), w1 = Vp, x1 = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]), C1 = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]), $C = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: x1, scaleY: C1, scale: e => (x1(e) + C1(e)) / 2, rotateX: e => Mp(ma(Math.atan2(e[6], e[5]))), rotateY: e => Mp(ma(Math.atan2(-e[2], e[0]))), rotateZ: w1, rotate: w1, skewX: e => ma(Math.atan(e[4])), skewY: e => ma(Math.atan(e[1])), skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2 }; function Ip(e) { return e.includes("scale") ? 1 : 0 } function Op(e, t) { if (!e || e === "none") return Ip(t); const i = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, o; if (i) r = $C, o = i; else { const d = e.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = WC, o = d } if (!o) return Ip(t); const u = r[t], c = o[1].split(",").map(JC); return typeof u == "function" ? u(c) : c[u] } const ZC = (e, t) => { const { transform: i = "none" } = getComputedStyle(e); return Op(i, t) }; function JC(e) { return parseFloat(e.trim()) } const jo = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Uo = new Set(jo), R1 = e => e === zo || e === yt, tR = new Set(["x", "y", "z"]), eR = jo.filter(e => !tR.has(e)); function nR(e) { const t = []; return eR.forEach(i => { const r = e.getValue(i); r !== void 0 && (t.push([i, r.get()]), r.set(i.startsWith("scale") ? 1 : 0)) }), t } const cr = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: i = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(i), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: i = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(i), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: (e, { transform: t }) => Op(t, "x"), y: (e, { transform: t }) => Op(t, "y") }; cr.translateX = cr.x; cr.translateY = cr.y; const ga = new Set; let Np = !1, Pp = !1, kp = !1; function jE() { if (Pp) { const e = Array.from(ga).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), i = new Map; t.forEach(r => { const o = nR(r); o.length && (i.set(r, o), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const o = i.get(r); o && o.forEach(([u, c]) => { r.getValue(u)?.set(c) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } Pp = !1, Np = !1, ga.forEach(e => e.complete(kp)), ga.clear() } function UE() { ga.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Pp = !0) }) } function iR() { kp = !0, UE(), jE(), kp = !1 } class jg { constructor(t, i, r, o, u, c = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = i, this.name = r, this.motionValue = o, this.element = u, this.isAsync = c } scheduleResolve() { this.state = "scheduled", this.isAsync ? (ga.add(this), Np || (Np = !0, le.read(UE), le.resolveKeyframes(jE))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: i, element: r, motionValue: o } = this; if (t[0] === null) { const u = o?.get(), c = t[t.length - 1]; if (u !== void 0) t[0] = u; else if (r && i) { const d = r.readValue(i, c); d != null && (t[0] = d) } t[0] === void 0 && (t[0] = c), o && u === void 0 && o.set(t[0]) } XC(t) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(t = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), ga.delete(this) } cancel() { this.state === "scheduled" && (ga.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const sR = e => e.startsWith("--"); function rR(e, t, i) { sR(t) ? e.style.setProperty(t, i) : e.style[t] = i } const aR = Cg(() => window.ScrollTimeline !== void 0), oR = {}; function lR(e, t) { const i = Cg(e); return () => oR[t] ?? i() } const BE = lR(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), au = ([e, t, i, r]) => `cubic-bezier(${e}, ${t}, ${i}, ${r})`, D1 = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: au([0, .65, .55, 1]), circOut: au([.55, 0, 1, .45]), backIn: au([.31, .01, .66, -.59]), backOut: au([.33, 1.53, .69, .99]) }; function FE(e, t) { if (e) return typeof e == "function" ? BE() ? kE(e, t) : "ease-out" : wE(e) ? au(e) : Array.isArray(e) ? e.map(i => FE(i, t) || D1.easeOut) : D1[e] } function uR(e, t, i, { delay: r = 0, duration: o = 300, repeat: u = 0, repeatType: c = "loop", ease: d = "easeOut", times: p } = {}, g = void 0) { const v = { [t]: i }; p && (v.offset = p); const b = FE(d, o); Array.isArray(b) && (v.easing = b); const E = { delay: r, duration: o, easing: Array.isArray(b) ? "linear" : b, fill: "both", iterations: u + 1, direction: c === "reverse" ? "alternate" : "normal" }; return g && (E.pseudoElement = g), e.animate(v, E) } function qE(e) { return typeof e == "function" && "applyToOptions" in e } function cR({ type: e, ...t }) { return qE(e) && BE() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t) } class hR extends Lg { constructor(t) { if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t) return; const { element: i, name: r, keyframes: o, pseudoElement: u, allowFlatten: c = !1, finalKeyframe: d, onComplete: p } = t; this.isPseudoElement = !!u, this.allowFlatten = c, this.options = t, xg(typeof t.type != "string"); const g = cR(t); this.animation = uR(i, r, o, g, u), g.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !u) { const v = kg(o, this.options, d, this.speed); this.updateMotionValue ? this.updateMotionValue(v) : rR(i, r, v), this.animation.cancel() } p?.(), this.notifyFinished() } } play() { this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { this.animation.finish?.() } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: t } = this; t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { const t = this.options?.element; !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.() } get duration() { const t = this.animation.effect?.getComputedTiming?.().duration || 0; return $n(Number(t)) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + $n(t) } get time() { return $n(Number(this.animation.currentTime) || 0) } set time(t) { this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = Hi(t) } get speed() { return this.animation.playbackRate } set speed(t) { t < 0 && (this.finishedTime = null), this.animation.playbackRate = t } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return this.manualStartTime ?? Number(this.animation.startTime) } set startTime(t) { this.manualStartTime = this.animation.startTime = t } attachTimeline({ timeline: t, observe: i }) { return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && aR() ? (this.animation.timeline = t, Zn) : i(this) } } const HE = { anticipate: TE, backInOut: bE, circInOut: SE }; function fR(e) { return e in HE } function dR(e) { typeof e.ease == "string" && fR(e.ease) && (e.ease = HE[e.ease]) } const np = 10; class mR extends hR { constructor(t) { dR(t), zE(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t } updateMotionValue(t) { const { motionValue: i, onUpdate: r, onComplete: o, element: u, ...c } = this.options; if (!i) return; if (t !== void 0) { i.set(t); return } const d = new zg({ ...c, autoplay: !1 }), p = Math.max(np, pn.now() - this.startTime), g = Xi(0, np, p - np); i.setWithVelocity(d.sample(Math.max(0, p - g)).value, d.sample(p).value, g), d.stop() } } const V1 = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (_r.test(e) || e === "0") && !e.startsWith("url(")); function pR(e) { const t = e[0]; if (e.length === 1) return !0; for (let i = 0; i < e.length; i++)if (e[i] !== t) return !0 } function gR(e, t, i, r) { const o = e[0]; if (o === null) return !1; if (t === "display" || t === "visibility") return !0; const u = e[e.length - 1], c = V1(o, t), d = V1(u, t); return !c || !d ? !1 : pR(e) || (i === "spring" || qE(i)) && r } function Lp(e) { e.duration = 0, e.type = "keyframes" } const yR = new Set(["opacity", "clipPath", "filter", "transform"]), vR = Cg(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function _R(e) { const { motionValue: t, name: i, repeatDelay: r, repeatType: o, damping: u, type: c } = e; if (!(t?.owner?.current instanceof HTMLElement)) return !1; const { onUpdate: p, transformTemplate: g } = t.owner.getProps(); return vR() && i && yR.has(i) && (i !== "transform" || !g) && !p && !r && o !== "mirror" && u !== 0 && c !== "inertia" } const bR = 40; class TR extends Lg { constructor({ autoplay: t = !0, delay: i = 0, type: r = "keyframes", repeat: o = 0, repeatDelay: u = 0, repeatType: c = "loop", keyframes: d, name: p, motionValue: g, element: v, ...b }) { super(), this.stop = () => { this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel() }, this.createdAt = pn.now(); const E = { autoplay: t, delay: i, type: r, repeat: o, repeatDelay: u, repeatType: c, name: p, motionValue: g, element: v, ...b }, x = v?.KeyframeResolver || jg; this.keyframeResolver = new x(d, (M, j, z) => this.onKeyframesResolved(M, j, E, !z), p, g, v), this.keyframeResolver?.scheduleResolve() } onKeyframesResolved(t, i, r, o) { this.keyframeResolver = void 0; const { name: u, type: c, velocity: d, delay: p, isHandoff: g, onUpdate: v } = r; this.resolvedAt = pn.now(), gR(t, u, c, d) || ((Es.instantAnimations || !p) && v?.(kg(t, r, i)), t[0] = t[t.length - 1], Lp(r), r.repeat = 0); const E = { startTime: o ? this.resolvedAt ? this.resolvedAt - this.createdAt > bR ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: i, ...r, keyframes: t }, x = !g && _R(E), M = E.motionValue?.owner?.current, j = x ? new mR({ ...E, element: M }) : new zg(E); j.finished.then(() => { this.notifyFinished() }).catch(Zn), this.pendingTimeline && (this.stopTimeline = j.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = j } get finished() { return this._animation ? this.animation.finished : this._finished } then(t, i) { return this.finished.finally(t).then(() => { }) } get animation() { return this._animation || (this.keyframeResolver?.resume(), iR()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(t) { this.animation.time = t } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(t) { this.animation.speed = t } get startTime() { return this.animation.startTime } attachTimeline(t) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { this._animation && this.animation.cancel(), this.keyframeResolver?.cancel() } } function GE(e, t, i, r = 0, o = 1) { const u = Array.from(e).sort((g, v) => g.sortNodePosition(v)).indexOf(t), c = e.size, d = (c - 1) * r; return typeof i == "function" ? i(u, c) : o === 1 ? u * r : d - u * r } const ER = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function SR(e) { const t = ER.exec(e); if (!t) return [,]; const [, i, r, o] = t; return [`--${i ?? r}`, o] } function YE(e, t, i = 1) { const [r, o] = SR(e); if (!r) return; const u = window.getComputedStyle(t).getPropertyValue(r); if (u) { const c = u.trim(); return fE(c) ? parseFloat(c) : c } return Mg(o) ? YE(o, t, i + 1) : o } const AR = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, wR = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), xR = { type: "keyframes", duration: .8 }, CR = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, RR = (e, { keyframes: t }) => t.length > 2 ? xR : Uo.has(e) ? e.startsWith("scale") ? wR(t[1]) : AR : CR, DR = e => e !== null; function VR(e, { repeat: t, repeatType: i = "loop" }, r) { const o = e.filter(DR), u = t && i !== "loop" && t % 2 === 1 ? 0 : o.length - 1; return o[u] } function KE(e, t) { if (e?.inherit && t) { const { inherit: i, ...r } = e; return { ...t, ...r } } return e } function Ug(e, t) { const i = e?.[t] ?? e?.default ?? e; return i !== e ? KE(i, e) : i } function MR({ when: e, delay: t, delayChildren: i, staggerChildren: r, staggerDirection: o, repeat: u, repeatType: c, repeatDelay: d, from: p, elapsed: g, ...v }) { return !!Object.keys(v).length } const Bg = (e, t, i, r = {}, o, u) => c => { const d = Ug(r, e) || {}, p = d.delay || r.delay || 0; let { elapsed: g = 0 } = r; g = g - Hi(p); const v = { keyframes: Array.isArray(i) ? i : [null, i], ease: "easeOut", velocity: t.getVelocity(), ...d, delay: -g, onUpdate: E => { t.set(E), d.onUpdate && d.onUpdate(E) }, onComplete: () => { c(), d.onComplete && d.onComplete() }, name: e, motionValue: t, element: u ? void 0 : o }; MR(d) || Object.assign(v, RR(e, v)), v.duration && (v.duration = Hi(v.duration)), v.repeatDelay && (v.repeatDelay = Hi(v.repeatDelay)), v.from !== void 0 && (v.keyframes[0] = v.from); let b = !1; if ((v.type === !1 || v.duration === 0 && !v.repeatDelay) && (Lp(v), v.delay === 0 && (b = !0)), (Es.instantAnimations || Es.skipAnimations || o?.shouldSkipAnimations) && (b = !0, Lp(v), v.delay = 0), v.allowFlatten = !d.type && !d.ease, b && !u && t.get() !== void 0) { const E = VR(v.keyframes, d); if (E !== void 0) { le.update(() => { v.onUpdate(E), v.onComplete() }); return } } return d.isSync ? new zg(v) : new TR(v) }; function M1(e) { const t = [{}, {}]; return e?.values.forEach((i, r) => { t[0][r] = i.get(), t[1][r] = i.getVelocity() }), t } function Fg(e, t, i, r) { if (typeof t == "function") { const [o, u] = M1(r); t = t(i !== void 0 ? i : e.custom, o, u) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [o, u] = M1(r); t = t(i !== void 0 ? i : e.custom, o, u) } return t } function wo(e, t, i) { const r = e.getProps(); return Fg(r, t, i !== void 0 ? i : r.custom, e) } const QE = new Set(["width", "height", "top", "left", "right", "bottom", ...jo]), I1 = 30, IR = e => !isNaN(parseFloat(e)); class OR { constructor(t, i = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => { const o = pn.now(); if (this.updatedAt !== o && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents)) for (const u of this.dependents) u.dirty() }, this.hasAnimated = !1, this.setCurrent(t), this.owner = i.owner } setCurrent(t) { this.current = t, this.updatedAt = pn.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = IR(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, i) { this.events[t] || (this.events[t] = new Rg); const r = this.events[t].add(i); return t === "change" ? () => { r(), le.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, i) { this.passiveEffect = t, this.stopPassiveEffect = i } set(t) { this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t) } setWithVelocity(t, i, r) { this.set(i), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, i = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { this.events.change?.notify(this.current) } addDependent(t) { this.dependents || (this.dependents = new Set), this.dependents.add(t) } removeDependent(t) { this.dependents && this.dependents.delete(t) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = pn.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > I1) return 0; const i = Math.min(this.updatedAt - this.prevUpdatedAt, I1); return pE(parseFloat(this.current) - parseFloat(this.prevFrameValue), i) } start(t) { return this.stop(), new Promise(i => { this.hasAnimated = !0, this.animation = t(i), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Vo(e, t) { return new OR(e, t) } const zp = e => Array.isArray(e); function NR(e, t, i) { e.hasValue(t) ? e.getValue(t).set(i) : e.addValue(t, Vo(i)) } function PR(e) { return zp(e) ? e[e.length - 1] || 0 : e } function kR(e, t) { const i = wo(e, t); let { transitionEnd: r = {}, transition: o = {}, ...u } = i || {}; u = { ...u, ...r }; for (const c in u) { const d = PR(u[c]); NR(e, c, d) } } const hn = e => !!(e && e.getVelocity); function LR(e) { return !!(hn(e) && e.add) } function jp(e, t) { const i = e.getValue("willChange"); if (LR(i)) return i.add(t); if (!i && Es.WillChange) { const r = new Es.WillChange("auto"); e.addValue("willChange", r), r.add(t) } } function qg(e) { return e.replace(/([A-Z])/g, t => `-${t.toLowerCase()}`) } const zR = "framerAppearId", XE = "data-" + qg(zR); function WE(e) { return e.props[XE] } function jR({ protectedKeys: e, needsAnimating: t }, i) { const r = e.hasOwnProperty(i) && t[i] !== !0; return t[i] = !1, r } function $E(e, t, { delay: i = 0, transitionOverride: r, type: o } = {}) { let { transition: u, transitionEnd: c, ...d } = t; const p = e.getDefaultTransition(); u = u ? KE(u, p) : p; const g = u?.reduceMotion; r && (u = r); const v = [], b = o && e.animationState && e.animationState.getState()[o]; for (const E in d) { const x = e.getValue(E, e.latestValues[E] ?? null), M = d[E]; if (M === void 0 || b && jR(b, E)) continue; const j = { delay: i, ...Ug(u || {}, E) }, z = x.get(); if (z !== void 0 && !x.isAnimating && !Array.isArray(M) && M === z && !j.velocity) continue; let K = !1; if (window.MotionHandoffAnimation) { const at = WE(e); if (at) { const lt = window.MotionHandoffAnimation(at, E, le); lt !== null && (j.startTime = lt, K = !0) } } jp(e, E); const it = g ?? e.shouldReduceMotion; x.start(Bg(E, x, M, it && QE.has(E) ? { type: !1 } : j, e, K)); const X = x.animation; X && v.push(X) } if (c) { const E = () => le.update(() => { c && kR(e, c) }); v.length ? Promise.all(v).then(E) : E() } return v } function Up(e, t, i = {}) { const r = wo(e, t, i.type === "exit" ? e.presenceContext?.custom : void 0); let { transition: o = e.getDefaultTransition() || {} } = r || {}; i.transitionOverride && (o = i.transitionOverride); const u = r ? () => Promise.all($E(e, r, i)) : () => Promise.resolve(), c = e.variantChildren && e.variantChildren.size ? (p = 0) => { const { delayChildren: g = 0, staggerChildren: v, staggerDirection: b } = o; return UR(e, t, p, g, v, b, i) } : () => Promise.resolve(), { when: d } = o; if (d) { const [p, g] = d === "beforeChildren" ? [u, c] : [c, u]; return p().then(() => g()) } else return Promise.all([u(), c(i.delay)]) } function UR(e, t, i = 0, r = 0, o = 0, u = 1, c) { const d = []; for (const p of e.variantChildren) p.notify("AnimationStart", t), d.push(Up(p, t, { ...c, delay: i + (typeof r == "function" ? 0 : r) + GE(e.variantChildren, p, r, o, u) }).then(() => p.notify("AnimationComplete", t))); return Promise.all(d) } function BR(e, t, i = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const o = t.map(u => Up(e, u, i)); r = Promise.all(o) } else if (typeof t == "string") r = Up(e, t, i); else { const o = typeof t == "function" ? wo(e, t, i.custom) : t; r = Promise.all($E(e, o, i)) } return r.then(() => { e.notify("AnimationComplete", t) }) } const FR = { test: e => e === "auto", parse: e => e }, ZE = e => t => t.test(e), JE = [zo, yt, Gi, lr, pC, mC, FR], O1 = e => JE.find(ZE(e)); function qR(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || mE(e) : !0 } const HR = new Set(["brightness", "contrast", "saturate", "opacity"]); function GR(e) { const [t, i] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = i.match(Ig) || []; if (!r) return e; const o = i.replace(r, ""); let u = HR.has(t) ? 1 : 0; return r !== i && (u *= 100), t + "(" + u + o + ")" } const YR = /\b([a-z-]*)\(.*?\)/gu, Bp = { ..._r, getAnimatableNone: e => { const t = e.match(YR); return t ? t.map(GR).join(" ") : e } }, N1 = { ...zo, transform: Math.round }, KR = { rotate: lr, rotateX: lr, rotateY: lr, rotateZ: lr, scale: Sh, scaleX: Sh, scaleY: Sh, scaleZ: Sh, skew: lr, skewX: lr, skewY: lr, distance: yt, translateX: yt, translateY: yt, translateZ: yt, x: yt, y: yt, z: yt, perspective: yt, transformPerspective: yt, opacity: Tu, originX: b1, originY: b1, originZ: yt }, Hg = { borderWidth: yt, borderTopWidth: yt, borderRightWidth: yt, borderBottomWidth: yt, borderLeftWidth: yt, borderRadius: yt, borderTopLeftRadius: yt, borderTopRightRadius: yt, borderBottomRightRadius: yt, borderBottomLeftRadius: yt, width: yt, maxWidth: yt, height: yt, maxHeight: yt, top: yt, right: yt, bottom: yt, left: yt, inset: yt, insetBlock: yt, insetBlockStart: yt, insetBlockEnd: yt, insetInline: yt, insetInlineStart: yt, insetInlineEnd: yt, padding: yt, paddingTop: yt, paddingRight: yt, paddingBottom: yt, paddingLeft: yt, paddingBlock: yt, paddingBlockStart: yt, paddingBlockEnd: yt, paddingInline: yt, paddingInlineStart: yt, paddingInlineEnd: yt, margin: yt, marginTop: yt, marginRight: yt, marginBottom: yt, marginLeft: yt, marginBlock: yt, marginBlockStart: yt, marginBlockEnd: yt, marginInline: yt, marginInlineStart: yt, marginInlineEnd: yt, fontSize: yt, backgroundPositionX: yt, backgroundPositionY: yt, ...KR, zIndex: N1, fillOpacity: Tu, strokeOpacity: Tu, numOctaves: N1 }, QR = { ...Hg, color: Le, backgroundColor: Le, outlineColor: Le, fill: Le, stroke: Le, borderColor: Le, borderTopColor: Le, borderRightColor: Le, borderBottomColor: Le, borderLeftColor: Le, filter: Bp, WebkitFilter: Bp }, tS = e => QR[e]; function eS(e, t) { let i = tS(e); return i !== Bp && (i = _r), i.getAnimatableNone ? i.getAnimatableNone(t) : void 0 } const XR = new Set(["auto", "none", "0"]); function WR(e, t, i) { let r = 0, o; for (; r < e.length && !o;) { const u = e[r]; typeof u == "string" && !XR.has(u) && Eu(u).values.length && (o = e[r]), r++ } if (o && i) for (const u of t) e[u] = eS(i, o) } class $R extends jg { constructor(t, i, r, o, u) { super(t, i, r, o, u, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: i, name: r } = this; if (!i || !i.current) return; super.readKeyframes(); for (let v = 0; v < t.length; v++) { let b = t[v]; if (typeof b == "string" && (b = b.trim(), Mg(b))) { const E = YE(b, i.current); E !== void 0 && (t[v] = E), v === t.length - 1 && (this.finalKeyframe = b) } } if (this.resolveNoneKeyframes(), !QE.has(r) || t.length !== 2) return; const [o, u] = t, c = O1(o), d = O1(u), p = _1(o), g = _1(u); if (p !== g && cr[r]) { this.needsMeasurement = !0; return } if (c !== d) if (R1(c) && R1(d)) for (let v = 0; v < t.length; v++) { const b = t[v]; typeof b == "string" && (t[v] = parseFloat(b)) } else cr[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: i } = this, r = []; for (let o = 0; o < t.length; o++)(t[o] === null || qR(t[o])) && r.push(o); r.length && WR(t, r, i) } measureInitialState() { const { element: t, unresolvedKeyframes: i, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = cr[r](t.measureViewportBox(), window.getComputedStyle(t.current)), i[0] = this.measuredOrigin; const o = i[i.length - 1]; o !== void 0 && t.getValue(r, o).jump(o, !1) } measureEndState() { const { element: t, name: i, unresolvedKeyframes: r } = this; if (!t || !t.current) return; const o = t.getValue(i); o && o.jump(this.measuredOrigin, !1); const u = r.length - 1, c = r[u]; r[u] = cr[i](t.measureViewportBox(), window.getComputedStyle(t.current)), c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c), this.removedTransforms?.length && this.removedTransforms.forEach(([d, p]) => { t.getValue(d).set(p) }), this.resolveNoneKeyframes() } } function nS(e, t, i) { if (e == null) return []; if (e instanceof EventTarget) return [e]; if (typeof e == "string") { let r = document; const o = i?.[e] ?? r.querySelectorAll(e); return o ? Array.from(o) : [] } return Array.from(e).filter(r => r != null) } const iS = (e, t) => t && typeof e == "number" ? t.transform(e) : e; function Fp(e) { return dE(e) && "offsetHeight" in e } const { schedule: Gg } = xE(queueMicrotask, !1), di = { x: !1, y: !1 }; function sS() { return di.x || di.y } function ZR(e) { return e === "x" || e === "y" ? di[e] ? null : (di[e] = !0, () => { di[e] = !1 }) : di.x || di.y ? null : (di.x = di.y = !0, () => { di.x = di.y = !1 }) } function rS(e, t) { const i = nS(e), r = new AbortController, o = { passive: !0, ...t, signal: r.signal }; return [i, o, () => r.abort()] } function JR(e) { return !(e.pointerType === "touch" || sS()) } function tD(e, t, i = {}) { const [r, o, u] = rS(e, i); return r.forEach(c => { let d = !1, p = !1, g; const v = () => { c.removeEventListener("pointerleave", M) }, b = z => { g && (g(z), g = void 0), v() }, E = z => { d = !1, window.removeEventListener("pointerup", E), window.removeEventListener("pointercancel", E), p && (p = !1, b(z)) }, x = () => { d = !0, window.addEventListener("pointerup", E, o), window.addEventListener("pointercancel", E, o) }, M = z => { if (z.pointerType !== "touch") { if (d) { p = !0; return } b(z) } }, j = z => { if (!JR(z)) return; p = !1; const K = t(c, z); typeof K == "function" && (g = K, c.addEventListener("pointerleave", M, o)) }; c.addEventListener("pointerenter", j, o), c.addEventListener("pointerdown", x, o) }), u } const aS = (e, t) => t ? e === t ? !0 : aS(e, t.parentElement) : !1, Yg = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, eD = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function nD(e) { return eD.has(e.tagName) || e.isContentEditable === !0 } const iD = new Set(["INPUT", "SELECT", "TEXTAREA"]); function sD(e) { return iD.has(e.tagName) || e.isContentEditable === !0 } const Ph = new WeakSet; function P1(e) { return t => { t.key === "Enter" && e(t) } } function ip(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const rD = (e, t) => { const i = e.currentTarget; if (!i) return; const r = P1(() => { if (Ph.has(i)) return; ip(i, "down"); const o = P1(() => { ip(i, "up") }), u = () => ip(i, "cancel"); i.addEventListener("keyup", o, t), i.addEventListener("blur", u, t) }); i.addEventListener("keydown", r, t), i.addEventListener("blur", () => i.removeEventListener("keydown", r), t) }; function k1(e) { return Yg(e) && !sS() } const L1 = new WeakSet; function aD(e, t, i = {}) { const [r, o, u] = rS(e, i), c = d => { const p = d.currentTarget; if (!k1(d) || L1.has(d)) return; Ph.add(p), i.stopPropagation && L1.add(d); const g = t(p, d), v = (x, M) => { window.removeEventListener("pointerup", b), window.removeEventListener("pointercancel", E), Ph.has(p) && Ph.delete(p), k1(x) && typeof g == "function" && g(x, { success: M }) }, b = x => { v(x, p === window || p === document || i.useGlobalTarget || aS(p, x.target)) }, E = x => { v(x, !1) }; window.addEventListener("pointerup", b, o), window.addEventListener("pointercancel", E, o) }; return r.forEach(d => { (i.useGlobalTarget ? window : d).addEventListener("pointerdown", c, o), Fp(d) && (d.addEventListener("focus", g => rD(g, o)), !nD(d) && !d.hasAttribute("tabindex") && (d.tabIndex = 0)) }), u } function Kg(e) { return dE(e) && "ownerSVGElement" in e } const kh = new WeakMap; let Lh; const oS = (e, t, i) => (r, o) => o && o[0] ? o[0][e + "Size"] : Kg(r) && "getBBox" in r ? r.getBBox()[t] : r[i], oD = oS("inline", "width", "offsetWidth"), lD = oS("block", "height", "offsetHeight"); function uD({ target: e, borderBoxSize: t }) { kh.get(e)?.forEach(i => { i(e, { get width() { return oD(e, t) }, get height() { return lD(e, t) } }) }) } function cD(e) { e.forEach(uD) } function hD() { typeof ResizeObserver > "u" || (Lh = new ResizeObserver(cD)) } function fD(e, t) { Lh || hD(); const i = nS(e); return i.forEach(r => { let o = kh.get(r); o || (o = new Set, kh.set(r, o)), o.add(t), Lh?.observe(r) }), () => { i.forEach(r => { const o = kh.get(r); o?.delete(t), o?.size || Lh?.unobserve(r) }) } } const zh = new Set; let To; function dD() { To = () => { const e = { get width() { return window.innerWidth }, get height() { return window.innerHeight } }; zh.forEach(t => t(e)) }, window.addEventListener("resize", To) } function mD(e) { return zh.add(e), To || dD(), () => { zh.delete(e), !zh.size && typeof To == "function" && (window.removeEventListener("resize", To), To = void 0) } } function z1(e, t) { return typeof e == "function" ? mD(e) : fD(e, t) } function pD(e) { return Kg(e) && e.tagName === "svg" } const gD = [...JE, Le, _r], yD = e => gD.find(ZE(e)), j1 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Eo = () => ({ x: j1(), y: j1() }), U1 = () => ({ min: 0, max: 0 }), qe = () => ({ x: U1(), y: U1() }), qp = { current: null }, lS = { current: !1 }, vD = typeof window < "u"; function _D() { if (lS.current = !0, !!vD) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => qp.current = e.matches; e.addEventListener("change", t), t() } else qp.current = !1 } const bD = new WeakMap; function wf(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function Su(e) { return typeof e == "string" || Array.isArray(e) } const Qg = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Xg = ["initial", ...Qg]; function xf(e) { return wf(e.animate) || Xg.some(t => Su(e[t])) } function uS(e) { return !!(xf(e) || e.variants) } function TD(e, t, i) { for (const r in t) { const o = t[r], u = i[r]; if (hn(o)) e.addValue(r, o); else if (hn(u)) e.addValue(r, Vo(o, { owner: e })); else if (u !== o) if (e.hasValue(r)) { const c = e.getValue(r); c.liveStyle === !0 ? c.jump(o) : c.hasAnimated || c.set(o) } else { const c = e.getStaticValue(r); e.addValue(r, Vo(c !== void 0 ? c : o, { owner: e })) } } for (const r in i) t[r] === void 0 && e.removeValue(r); return t } const B1 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; let $h = {}; function cS(e) { $h = e } function ED() { return $h } class SD { scrapeMotionValuesFromProps(t, i, r) { return {} } constructor({ parent: t, props: i, presenceContext: r, reducedMotionConfig: o, skipAnimations: u, blockInitialAnimation: c, visualState: d }, p = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = new Map, this.KeyframeResolver = jg, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.hasBeenMounted = !1, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const x = pn.now(); this.renderScheduledAt < x && (this.renderScheduledAt = x, le.render(this.render, !1, !0)) }; const { latestValues: g, renderState: v } = d; this.latestValues = g, this.baseTarget = { ...g }, this.initialValues = i.initial ? { ...g } : {}, this.renderState = v, this.parent = t, this.props = i, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = o, this.skipAnimationsConfig = u, this.options = p, this.blockInitialAnimation = !!c, this.isControllingVariants = xf(i), this.isVariantNode = uS(i), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: b, ...E } = this.scrapeMotionValuesFromProps(i, {}, this); for (const x in E) { const M = E[x]; g[x] !== void 0 && hn(M) && M.set(g[x]) } } mount(t) { if (this.hasBeenMounted) for (const i in this.initialValues) this.values.get(i)?.jump(this.initialValues[i]), this.latestValues[i] = this.initialValues[i]; this.current = t, bD.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, r) => this.bindToMotionValue(r, i)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (lS.current || _D(), this.shouldReduceMotion = qp.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext), this.hasBeenMounted = !0 } unmount() { this.projection && this.projection.unmount(), vr(this.notifyUpdate), vr(this.render), this.valueSubscriptions.forEach(t => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this); for (const t in this.events) this.events[t].clear(); for (const t in this.features) { const i = this.features[t]; i && (i.unmount(), i.isMounted = !1) } this.current = null } addChild(t) { this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t) } removeChild(t) { this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t) } bindToMotionValue(t, i) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); const r = Uo.has(t); r && this.onBindTransform && this.onBindTransform(); const o = i.on("change", c => { this.latestValues[t] = c, this.props.onUpdate && le.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let u; typeof window < "u" && window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, t, i)), this.valueSubscriptions.set(t, () => { o(), u && u(), i.owner && i.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in $h) { const i = $h[t]; if (!i) continue; const { isEnabled: r, Feature: o } = i; if (!this.features[t] && o && r(this.props) && (this.features[t] = new o(this)), this.features[t]) { const u = this.features[t]; u.isMounted ? u.update() : (u.mount(), u.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : qe() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, i) { this.latestValues[t] = i } update(t, i) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = i; for (let r = 0; r < B1.length; r++) { const o = B1[r]; this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]); const u = "on" + o, c = t[u]; c && (this.propEventSubscriptions[o] = this.on(o, c)) } this.prevMotionValues = TD(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const i = this.getClosestVariantNode(); if (i) return i.variantChildren && i.variantChildren.add(t), () => i.variantChildren.delete(t) } addValue(t, i) { const r = this.values.get(t); i !== r && (r && this.removeValue(t), this.bindToMotionValue(t, i), this.values.set(t, i), this.latestValues[t] = i.get()) } removeValue(t) { this.values.delete(t); const i = this.valueSubscriptions.get(t); i && (i(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, i) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && i !== void 0 && (r = Vo(i === null ? void 0 : i, { owner: this }), this.addValue(t, r)), r } readValue(t, i) { let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options); return r != null && (typeof r == "string" && (fE(r) || mE(r)) ? r = parseFloat(r) : !yD(r) && _r.test(i) && (r = eS(t, i)), this.setBaseTarget(t, hn(r) ? r.get() : r)), hn(r) ? r.get() : r } setBaseTarget(t, i) { this.baseTarget[t] = i } getBaseTarget(t) { const { initial: i } = this.props; let r; if (typeof i == "string" || typeof i == "object") { const u = Fg(this.props, i, this.presenceContext?.custom); u && (r = u[t]) } if (i && r !== void 0) return r; const o = this.getBaseTargetFromProps(this.props, t); return o !== void 0 && !hn(o) ? o : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t] } on(t, i) { return this.events[t] || (this.events[t] = new Rg), this.events[t].add(i) } notify(t, ...i) { this.events[t] && this.events[t].notify(...i) } scheduleRenderMicrotask() { Gg.render(this.render) } } class hS extends SD { constructor() { super(...arguments), this.KeyframeResolver = $R } sortInstanceNodePosition(t, i) { return t.compareDocumentPosition(i) & 2 ? 1 : -1 } getBaseTargetFromProps(t, i) { const r = t.style; return r ? r[i] : void 0 } removeValueFromRenderState(t, { vars: i, style: r }) { delete i[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; hn(t) && (this.childSubscription = t.on("change", i => { this.current && (this.current.textContent = `${i}`) })) } } class Cr { constructor(t) { this.isMounted = !1, this.node = t } update() { } } function fS({ top: e, left: t, right: i, bottom: r }) { return { x: { min: t, max: i }, y: { min: e, max: r } } } function AD({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function wD(e, t) { if (!t) return e; const i = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: i.y, left: i.x, bottom: r.y, right: r.x } } function sp(e) { return e === void 0 || e === 1 } function Hp({ scale: e, scaleX: t, scaleY: i }) { return !sp(e) || !sp(t) || !sp(i) } function ca(e) { return Hp(e) || dS(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function dS(e) { return F1(e.x) || F1(e.y) } function F1(e) { return e && e !== "0%" } function Zh(e, t, i) { const r = e - i, o = t * r; return i + o } function q1(e, t, i, r, o) { return o !== void 0 && (e = Zh(e, o, r)), Zh(e, i, r) + t } function Gp(e, t = 0, i = 1, r, o) { e.min = q1(e.min, t, i, r, o), e.max = q1(e.max, t, i, r, o) } function mS(e, { x: t, y: i }) { Gp(e.x, t.translate, t.scale, t.originPoint), Gp(e.y, i.translate, i.scale, i.originPoint) } const H1 = .999999999999, G1 = 1.0000000000001; function xD(e, t, i, r = !1) { const o = i.length; if (!o) return; t.x = t.y = 1; let u, c; for (let d = 0; d < o; d++) { u = i[d], c = u.projectionDelta; const { visualElement: p } = u.options; p && p.props.style && p.props.style.display === "contents" || (r && u.options.layoutScroll && u.scroll && u !== u.root && Ao(e, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }), c && (t.x *= c.x.scale, t.y *= c.y.scale, mS(e, c)), r && ca(u.latestValues) && Ao(e, u.latestValues)) } t.x < G1 && t.x > H1 && (t.x = 1), t.y < G1 && t.y > H1 && (t.y = 1) } function So(e, t) { e.min = e.min + t, e.max = e.max + t } function Y1(e, t, i, r, o = .5) { const u = pe(e.min, e.max, o); Gp(e, t, i, u, r) } function Ao(e, t) { Y1(e.x, t.x, t.scaleX, t.scale, t.originX), Y1(e.y, t.y, t.scaleY, t.scale, t.originY) } function pS(e, t) { return fS(wD(e.getBoundingClientRect(), t)) } function CD(e, t, i) { const r = pS(e, i), { scroll: o } = t; return o && (So(r.x, o.offset.x), So(r.y, o.offset.y)), r } const RD = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, DD = jo.length; function VD(e, t, i) { let r = "", o = !0; for (let u = 0; u < DD; u++) { const c = jo[u], d = e[c]; if (d === void 0) continue; let p = !0; if (typeof d == "number") p = d === (c.startsWith("scale") ? 1 : 0); else { const g = parseFloat(d); p = c.startsWith("scale") ? g === 1 : g === 0 } if (!p || i) { const g = iS(d, Hg[c]); if (!p) { o = !1; const v = RD[c] || c; r += `${v}(${g}) ` } i && (t[c] = g) } } return r = r.trim(), i ? r = i(t, o ? "" : r) : o && (r = "none"), r } function Wg(e, t, i) { const { style: r, vars: o, transformOrigin: u } = e; let c = !1, d = !1; for (const p in t) { const g = t[p]; if (Uo.has(p)) { c = !0; continue } else if (RE(p)) { o[p] = g; continue } else { const v = iS(g, Hg[p]); p.startsWith("origin") ? (d = !0, u[p] = v) : r[p] = v } } if (t.transform || (c || i ? r.transform = VD(t, e.transform, i) : r.transform && (r.transform = "none")), d) { const { originX: p = "50%", originY: g = "50%", originZ: v = 0 } = u; r.transformOrigin = `${p} ${g} ${v}` } } function gS(e, { style: t, vars: i }, r, o) { const u = e.style; let c; for (c in t) u[c] = t[c]; o?.applyProjectionStyles(u, r); for (c in i) u.setProperty(c, i[c]) } function K1(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const eu = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (yt.test(e)) e = parseFloat(e); else return e; const i = K1(e, t.target.x), r = K1(e, t.target.y); return `${i}% ${r}%` } }, MD = { correct: (e, { treeScale: t, projectionDelta: i }) => { const r = e, o = _r.parse(e); if (o.length > 5) return r; const u = _r.createTransformer(e), c = typeof o[0] != "number" ? 1 : 0, d = i.x.scale * t.x, p = i.y.scale * t.y; o[0 + c] /= d, o[1 + c] /= p; const g = pe(d, p, .5); return typeof o[2 + c] == "number" && (o[2 + c] /= g), typeof o[3 + c] == "number" && (o[3 + c] /= g), u(o) } }, Yp = { borderRadius: { ...eu, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: eu, borderTopRightRadius: eu, borderBottomLeftRadius: eu, borderBottomRightRadius: eu, boxShadow: MD }; function yS(e, { layout: t, layoutId: i }) { return Uo.has(e) || e.startsWith("origin") || (t || i !== void 0) && (!!Yp[e] || e === "opacity") } function $g(e, t, i) { const r = e.style, o = t?.style, u = {}; if (!r) return u; for (const c in r) (hn(r[c]) || o && hn(o[c]) || yS(c, e) || i?.getValue(c)?.liveStyle !== void 0) && (u[c] = r[c]); return u } function ID(e) { return window.getComputedStyle(e) } class OD extends hS { constructor() { super(...arguments), this.type = "html", this.renderInstance = gS } readValueFromInstance(t, i) { if (Uo.has(i)) return this.projection?.isProjecting ? Ip(i) : ZC(t, i); { const r = ID(t), o = (RE(i) ? r.getPropertyValue(i) : r[i]) || 0; return typeof o == "string" ? o.trim() : o } } measureInstanceViewportBox(t, { transformPagePoint: i }) { return pS(t, i) } build(t, i, r) { Wg(t, i, r.transformTemplate) } scrapeMotionValuesFromProps(t, i, r) { return $g(t, i, r) } } const ND = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, PD = { offset: "strokeDashoffset", array: "strokeDasharray" }; function kD(e, t, i = 1, r = 0, o = !0) { e.pathLength = 1; const u = o ? ND : PD; e[u.offset] = `${-r}`, e[u.array] = `${t} ${i}` } const LD = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"]; function vS(e, { attrX: t, attrY: i, attrScale: r, pathLength: o, pathSpacing: u = 1, pathOffset: c = 0, ...d }, p, g, v) { if (Wg(e, d, g), p) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: b, style: E } = e; b.transform && (E.transform = b.transform, delete b.transform), (E.transform || b.transformOrigin) && (E.transformOrigin = b.transformOrigin ?? "50% 50%", delete b.transformOrigin), E.transform && (E.transformBox = v?.transformBox ?? "fill-box", delete b.transformBox); for (const x of LD) b[x] !== void 0 && (E[x] = b[x], delete b[x]); t !== void 0 && (b.x = t), i !== void 0 && (b.y = i), r !== void 0 && (b.scale = r), o !== void 0 && kD(b, o, u, c, !1) } const _S = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]), bS = e => typeof e == "string" && e.toLowerCase() === "svg"; function zD(e, t, i, r) { gS(e, t, void 0, r); for (const o in t.attrs) e.setAttribute(_S.has(o) ? o : qg(o), t.attrs[o]) } function TS(e, t, i) { const r = $g(e, t, i); for (const o in e) if (hn(e[o]) || hn(t[o])) { const u = jo.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o; r[u] = e[o] } return r } class jD extends hS { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = qe } getBaseTargetFromProps(t, i) { return t[i] } readValueFromInstance(t, i) { if (Uo.has(i)) { const r = tS(i); return r && r.default || 0 } return i = _S.has(i) ? i : qg(i), t.getAttribute(i) } scrapeMotionValuesFromProps(t, i, r) { return TS(t, i, r) } build(t, i, r) { vS(t, i, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(t, i, r, o) { zD(t, i, r, o) } mount(t) { this.isSVGTag = bS(t.tagName), super.mount(t) } } const UD = Xg.length; function ES(e) { if (!e) return; if (!e.isControllingVariants) { const i = e.parent ? ES(e.parent) || {} : {}; return e.props.initial !== void 0 && (i.initial = e.props.initial), i } const t = {}; for (let i = 0; i < UD; i++) { const r = Xg[i], o = e.props[r]; (Su(o) || o === !1) && (t[r] = o) } return t } function SS(e, t) { if (!Array.isArray(t)) return !1; const i = t.length; if (i !== e.length) return !1; for (let r = 0; r < i; r++)if (t[r] !== e[r]) return !1; return !0 } const BD = [...Qg].reverse(), FD = Qg.length; function qD(e) { return t => Promise.all(t.map(({ animation: i, options: r }) => BR(e, i, r))) } function HD(e) { let t = qD(e), i = Q1(), r = !0; const o = p => (g, v) => { const b = wo(e, v, p === "exit" ? e.presenceContext?.custom : void 0); if (b) { const { transition: E, transitionEnd: x, ...M } = b; g = { ...g, ...M, ...x } } return g }; function u(p) { t = p(e) } function c(p) { const { props: g } = e, v = ES(e.parent) || {}, b = [], E = new Set; let x = {}, M = 1 / 0; for (let z = 0; z < FD; z++) { const K = BD[z], it = i[K], X = g[K] !== void 0 ? g[K] : v[K], at = Su(X), lt = K === p ? it.isActive : null; lt === !1 && (M = z); let ht = X === v[K] && X !== g[K] && at; if (ht && r && e.manuallyAnimateOnMount && (ht = !1), it.protectedKeys = { ...x }, !it.isActive && lt === null || !X && !it.prevProp || wf(X) || typeof X == "boolean") continue; const R = GD(it.prevProp, X); let A = R || K === p && it.isActive && !ht && at || z > M && at, C = !1; const O = Array.isArray(X) ? X : [X]; let I = O.reduce(o(K), {}); lt === !1 && (I = {}); const { prevResolvedValues: k = {} } = it, D = { ...k, ...I }, Yt = rt => { A = !0, E.has(rt) && (C = !0, E.delete(rt)), it.needsAnimating[rt] = !0; const et = e.getValue(rt); et && (et.liveStyle = !1) }; for (const rt in D) { const et = I[rt], xt = k[rt]; if (x.hasOwnProperty(rt)) continue; let Ot = !1; zp(et) && zp(xt) ? Ot = !SS(et, xt) : Ot = et !== xt, Ot ? et != null ? Yt(rt) : E.add(rt) : et !== void 0 && E.has(rt) ? Yt(rt) : it.protectedKeys[rt] = !0 } it.prevProp = X, it.prevResolvedValues = I, it.isActive && (x = { ...x, ...I }), r && e.blockInitialAnimation && (A = !1); const Wt = ht && R; A && (!Wt || C) && b.push(...O.map(rt => { const et = { type: K }; if (typeof rt == "string" && r && !Wt && e.manuallyAnimateOnMount && e.parent) { const { parent: xt } = e, Ot = wo(xt, rt); if (xt.enteringChildren && Ot) { const { delayChildren: N } = Ot.transition || {}; et.delay = GE(xt.enteringChildren, e, N) } } return { animation: rt, options: et } })) } if (E.size) { const z = {}; if (typeof g.initial != "boolean") { const K = wo(e, Array.isArray(g.initial) ? g.initial[0] : g.initial); K && K.transition && (z.transition = K.transition) } E.forEach(K => { const it = e.getBaseTarget(K), X = e.getValue(K); X && (X.liveStyle = !0), z[K] = it ?? null }), b.push({ animation: z }) } let j = !!b.length; return r && (g.initial === !1 || g.initial === g.animate) && !e.manuallyAnimateOnMount && (j = !1), r = !1, j ? t(b) : Promise.resolve() } function d(p, g) { if (i[p].isActive === g) return Promise.resolve(); e.variantChildren?.forEach(b => b.animationState?.setActive(p, g)), i[p].isActive = g; const v = c(p); for (const b in i) i[b].protectedKeys = {}; return v } return { animateChanges: c, setActive: d, setAnimateFunction: u, getState: () => i, reset: () => { i = Q1() } } } function GD(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !SS(t, e) : !1 } function la(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Q1() { return { animate: la(!0), whileInView: la(), whileHover: la(), whileTap: la(), whileDrag: la(), whileFocus: la(), exit: la() } } function X1(e, t) { e.min = t.min, e.max = t.max } function fi(e, t) { X1(e.x, t.x), X1(e.y, t.y) } function W1(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } const AS = 1e-4, YD = 1 - AS, KD = 1 + AS, wS = .01, QD = 0 - wS, XD = 0 + wS; function gn(e) { return e.max - e.min } function WD(e, t, i) { return Math.abs(e - t) <= i } function $1(e, t, i, r = .5) { e.origin = r, e.originPoint = pe(t.min, t.max, e.origin), e.scale = gn(i) / gn(t), e.translate = pe(i.min, i.max, e.origin) - e.originPoint, (e.scale >= YD && e.scale <= KD || isNaN(e.scale)) && (e.scale = 1), (e.translate >= QD && e.translate <= XD || isNaN(e.translate)) && (e.translate = 0) } function du(e, t, i, r) { $1(e.x, t.x, i.x, r ? r.originX : void 0), $1(e.y, t.y, i.y, r ? r.originY : void 0) } function Z1(e, t, i) { e.min = i.min + t.min, e.max = e.min + gn(t) } function $D(e, t, i) { Z1(e.x, t.x, i.x), Z1(e.y, t.y, i.y) } function J1(e, t, i) { e.min = t.min - i.min, e.max = e.min + gn(t) } function Jh(e, t, i) { J1(e.x, t.x, i.x), J1(e.y, t.y, i.y) } function tb(e, t, i, r, o) { return e -= t, e = Zh(e, 1 / i, r), o !== void 0 && (e = Zh(e, 1 / o, r)), e } function ZD(e, t = 0, i = 1, r = .5, o, u = e, c = e) { if (Gi.test(t) && (t = parseFloat(t), t = pe(c.min, c.max, t / 100) - c.min), typeof t != "number") return; let d = pe(u.min, u.max, r); e === u && (d -= t), e.min = tb(e.min, t, i, d, o), e.max = tb(e.max, t, i, d, o) } function eb(e, t, [i, r, o], u, c) { ZD(e, t[i], t[r], t[o], t.scale, u, c) } const JD = ["x", "scaleX", "originX"], t4 = ["y", "scaleY", "originY"]; function nb(e, t, i, r) { eb(e.x, t, JD, i ? i.x : void 0, r ? r.x : void 0), eb(e.y, t, t4, i ? i.y : void 0, r ? r.y : void 0) } function ib(e) { return e.translate === 0 && e.scale === 1 } function xS(e) { return ib(e.x) && ib(e.y) } function sb(e, t) { return e.min === t.min && e.max === t.max } function e4(e, t) { return sb(e.x, t.x) && sb(e.y, t.y) } function rb(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function CS(e, t) { return rb(e.x, t.x) && rb(e.y, t.y) } function ab(e) { return gn(e.x) / gn(e.y) } function ob(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } function Ui(e) { return [e("x"), e("y")] } function n4(e, t, i) { let r = ""; const o = e.x.translate / t.x, u = e.y.translate / t.y, c = i?.z || 0; if ((o || u || c) && (r = `translate3d(${o}px, ${u}px, ${c}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), i) { const { transformPerspective: g, rotate: v, rotateX: b, rotateY: E, skewX: x, skewY: M } = i; g && (r = `perspective(${g}px) ${r}`), v && (r += `rotate(${v}deg) `), b && (r += `rotateX(${b}deg) `), E && (r += `rotateY(${E}deg) `), x && (r += `skewX(${x}deg) `), M && (r += `skewY(${M}deg) `) } const d = e.x.scale * t.x, p = e.y.scale * t.y; return (d !== 1 || p !== 1) && (r += `scale(${d}, ${p})`), r || "none" } const RS = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], i4 = RS.length, lb = e => typeof e == "string" ? parseFloat(e) : e, ub = e => typeof e == "number" || yt.test(e); function s4(e, t, i, r, o, u) { o ? (e.opacity = pe(0, i.opacity ?? 1, r4(r)), e.opacityExit = pe(t.opacity ?? 1, 0, a4(r))) : u && (e.opacity = pe(t.opacity ?? 1, i.opacity ?? 1, r)); for (let c = 0; c < i4; c++) { const d = `border${RS[c]}Radius`; let p = cb(t, d), g = cb(i, d); if (p === void 0 && g === void 0) continue; p || (p = 0), g || (g = 0), p === 0 || g === 0 || ub(p) === ub(g) ? (e[d] = Math.max(pe(lb(p), lb(g), r), 0), (Gi.test(g) || Gi.test(p)) && (e[d] += "%")) : e[d] = g } (t.rotate || i.rotate) && (e.rotate = pe(t.rotate || 0, i.rotate || 0, r)) } function cb(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const r4 = DS(0, .5, EE), a4 = DS(.5, .95, Zn); function DS(e, t, i) { return r => r < e ? 0 : r > t ? 1 : i(bu(e, t, r)) } function o4(e, t, i) { const r = hn(e) ? e : Vo(e); return r.start(Bg("", r, t, i)), r.animation } function Au(e, t, i, r = { passive: !0 }) { return e.addEventListener(t, i, r), () => e.removeEventListener(t, i) } const l4 = (e, t) => e.depth - t.depth; class u4 { constructor() { this.children = [], this.isDirty = !1 } add(t) { Ag(this.children, t), this.isDirty = !0 } remove(t) { wg(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(l4), this.isDirty = !1, this.children.forEach(t) } } function c4(e, t) { const i = pn.now(), r = ({ timestamp: o }) => { const u = o - i; u >= t && (vr(r), e(u - t)) }; return le.setup(r, !0), () => vr(r) } function jh(e) { return hn(e) ? e.get() : e } class h4 { constructor() { this.members = [] } add(t) { Ag(this.members, t), t.scheduleRender() } remove(t) { if (wg(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const i = this.members[this.members.length - 1]; i && this.promote(i) } } relegate(t) { const i = this.members.findIndex(o => t === o); if (i === 0) return !1; let r; for (let o = i; o >= 0; o--) { const u = this.members[o]; if (u.isPresent !== !1) { r = u; break } } return r ? (this.promote(r), !0) : !1 } promote(t, i) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(); const o = r.options.layoutDependency, u = t.options.layoutDependency; o !== void 0 && u !== void 0 && o === u || (t.resumeFrom = r, i && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0)); const { crossfade: d } = t.options; d === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: i, resumingFrom: r } = t; i.onExitComplete && i.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } const Uh = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }, rp = ["", "X", "Y", "Z"], f4 = 1e3; let d4 = 0; function ap(e, t, i, r) { const { latestValues: o } = t; o[e] && (i[e] = o[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function VS(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const i = WE(t); if (window.MotionHasOptimisedAnimation(i, "transform")) { const { layout: o, layoutId: u } = e.options; window.MotionCancelOptimisedAnimation(i, "transform", le, !(o || u)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && VS(r) } function MS({ attachResizeListener: e, defaultParent: t, measureScroll: i, checkIsScrollRoot: r, resetTransform: o }) { return class { constructor(c = {}, d = t?.()) { this.id = d4++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(g4), this.nodes.forEach(b4), this.nodes.forEach(T4), this.nodes.forEach(y4) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = c, this.root = d ? d.root || d : this, this.path = d ? [...d.path, d] : [], this.parent = d, this.depth = d ? d.depth + 1 : 0; for (let p = 0; p < this.path.length; p++)this.path[p].shouldResetTransform = !0; this.root === this && (this.nodes = new u4) } addEventListener(c, d) { return this.eventHandlers.has(c) || this.eventHandlers.set(c, new Rg), this.eventHandlers.get(c).add(d) } notifyListeners(c, ...d) { const p = this.eventHandlers.get(c); p && p.notify(...d) } hasListeners(c) { return this.eventHandlers.has(c) } mount(c) { if (this.instance) return; this.isSVG = Kg(c) && !pD(c), this.instance = c; const { layoutId: d, layout: p, visualElement: g } = this.options; if (g && !g.current && g.mount(c), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (p || d) && (this.isLayoutDirty = !0), e) { let v, b = 0; const E = () => this.root.updateBlockedByResize = !1; le.read(() => { b = window.innerWidth }), e(c, () => { const x = window.innerWidth; x !== b && (b = x, this.root.updateBlockedByResize = !0, v && v(), v = c4(E, 250), Uh.hasAnimatedSinceResize && (Uh.hasAnimatedSinceResize = !1, this.nodes.forEach(db))) }) } d && this.root.registerSharedNode(d, this), this.options.animate !== !1 && g && (d || p) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: b, hasRelativeLayoutChanged: E, layout: x }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const M = this.options.transition || g.getDefaultTransition() || x4, { onLayoutAnimationStart: j, onLayoutAnimationComplete: z } = g.getProps(), K = !this.targetLayout || !CS(this.targetLayout, x), it = !b && E; if (this.options.layoutRoot || this.resumeFrom || it || b && (K || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const X = { ...Ug(M, "layout"), onPlay: j, onComplete: z }; (g.shouldReduceMotion || this.options.layoutRoot) && (X.delay = 0, X.type = !1), this.startAnimation(X), this.setAnimationOrigin(v, it) } else b || db(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = x }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const c = this.getStack(); c && c.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), vr(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(E4), this.animationId++) } getTransformTemplate() { const { visualElement: c } = this.options; return c && c.getProps().transformTemplate } willUpdate(c = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && VS(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let v = 0; v < this.path.length; v++) { const b = this.path[v]; b.shouldResetTransform = !0, b.updateScroll("snapshot"), b.options.layoutRoot && b.willUpdate(!1) } const { layoutId: d, layout: p } = this.options; if (d === void 0 && !p) return; const g = this.getTransformTemplate(); this.prevTransformTemplateValue = g ? g(this.latestValues, "") : void 0, this.updateSnapshot(), c && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(hb); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(fb); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(_4), this.nodes.forEach(m4), this.nodes.forEach(p4)) : this.nodes.forEach(fb), this.clearAllSnapshots(); const d = pn.now(); en.delta = Xi(0, 1e3 / 60, d - en.timestamp), en.timestamp = d, en.isProcessing = !0, $m.update.process(en), $m.preRender.process(en), $m.render.process(en), en.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Gg.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(v4), this.sharedNodes.forEach(S4) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, le.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { le.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !gn(this.snapshot.measuredBox.x) && !gn(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let p = 0; p < this.path.length; p++)this.path[p].updateScroll(); const c = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = qe(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: d } = this.options; d && d.notify("LayoutMeasure", this.layout.layoutBox, c ? c.layoutBox : void 0) } updateScroll(c = "measure") { let d = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === c && (d = !1), d && this.instance) { const p = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: c, isRoot: p, offset: i(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : p } } } resetTransform() { if (!o) return; const c = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, d = this.projectionDelta && !xS(this.projectionDelta), p = this.getTransformTemplate(), g = p ? p(this.latestValues, "") : void 0, v = g !== this.prevTransformTemplateValue; c && this.instance && (d || ca(this.latestValues) || v) && (o(this.instance, g), this.shouldResetTransform = !1, this.scheduleRender()) } measure(c = !0) { const d = this.measurePageBox(); let p = this.removeElementScroll(d); return c && (p = this.removeTransform(p)), C4(p), { animationId: this.root.animationId, measuredBox: d, layoutBox: p, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: c } = this.options; if (!c) return qe(); const d = c.measureViewportBox(); if (!(this.scroll?.wasRoot || this.path.some(R4))) { const { scroll: g } = this.root; g && (So(d.x, g.offset.x), So(d.y, g.offset.y)) } return d } removeElementScroll(c) { const d = qe(); if (fi(d, c), this.scroll?.wasRoot) return d; for (let p = 0; p < this.path.length; p++) { const g = this.path[p], { scroll: v, options: b } = g; g !== this.root && v && b.layoutScroll && (v.wasRoot && fi(d, c), So(d.x, v.offset.x), So(d.y, v.offset.y)) } return d } applyTransform(c, d = !1) { const p = qe(); fi(p, c); for (let g = 0; g < this.path.length; g++) { const v = this.path[g]; !d && v.options.layoutScroll && v.scroll && v !== v.root && Ao(p, { x: -v.scroll.offset.x, y: -v.scroll.offset.y }), ca(v.latestValues) && Ao(p, v.latestValues) } return ca(this.latestValues) && Ao(p, this.latestValues), p } removeTransform(c) { const d = qe(); fi(d, c); for (let p = 0; p < this.path.length; p++) { const g = this.path[p]; if (!g.instance || !ca(g.latestValues)) continue; Hp(g.latestValues) && g.updateSnapshot(); const v = qe(), b = g.measurePageBox(); fi(v, b), nb(d, g.latestValues, g.snapshot ? g.snapshot.layoutBox : void 0, v) } return ca(this.latestValues) && nb(d, this.latestValues), d } setTargetDelta(c) { this.targetDelta = c, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(c) { this.options = { ...this.options, ...c, crossfade: c.crossfade !== void 0 ? c.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== en.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(c = !1) { const d = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = d.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = d.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = d.isSharedProjectionDirty); const p = !!this.resumingFrom || this !== d; if (!(c || p && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: v, layoutId: b } = this.options; if (!this.layout || !(v || b)) return; this.resolvedRelativeTargetAt = en.timestamp; const E = this.getClosestProjectingParent(); E && this.linkedParentVersion !== E.layoutVersion && !E.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (E && E.layout ? this.createRelativeTarget(E, this.layout.layoutBox, E.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = qe(), this.targetWithTransforms = qe()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), $D(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : fi(this.target, this.layout.layoutBox), mS(this.target, this.targetDelta)) : fi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, E && !!E.resumingFrom == !!this.resumingFrom && !E.options.layoutScroll && E.target && this.animationProgress !== 1 ? this.createRelativeTarget(E, this.target, E.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || Hp(this.parent.latestValues) || dS(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(c, d, p) { this.relativeParent = c, this.linkedParentVersion = c.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = qe(), this.relativeTargetOrigin = qe(), Jh(this.relativeTargetOrigin, d, p), fi(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { const c = this.getLead(), d = !!this.resumingFrom || this !== c; let p = !0; if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (p = !1), d && (this.isSharedProjectionDirty || this.isTransformDirty) && (p = !1), this.resolvedRelativeTargetAt === en.timestamp && (p = !1), p) return; const { layout: g, layoutId: v } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(g || v)) return; fi(this.layoutCorrected, this.layout.layoutBox); const b = this.treeScale.x, E = this.treeScale.y; xD(this.layoutCorrected, this.treeScale, this.path, d), c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox, c.targetWithTransforms = qe()); const { target: x } = c; if (!x) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (W1(this.prevProjectionDelta.x, this.projectionDelta.x), W1(this.prevProjectionDelta.y, this.projectionDelta.y)), du(this.projectionDelta, this.layoutCorrected, x, this.latestValues), (this.treeScale.x !== b || this.treeScale.y !== E || !ob(this.projectionDelta.x, this.prevProjectionDelta.x) || !ob(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", x)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(c = !0) { if (this.options.visualElement?.scheduleRender(), c) { const d = this.getStack(); d && d.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Eo(), this.projectionDelta = Eo(), this.projectionDeltaWithTransform = Eo() } setAnimationOrigin(c, d = !1) { const p = this.snapshot, g = p ? p.latestValues : {}, v = { ...this.latestValues }, b = Eo(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !d; const E = qe(), x = p ? p.source : void 0, M = this.layout ? this.layout.source : void 0, j = x !== M, z = this.getStack(), K = !z || z.members.length <= 1, it = !!(j && !K && this.options.crossfade === !0 && !this.path.some(w4)); this.animationProgress = 0; let X; this.mixTargetDelta = at => { const lt = at / 1e3; mb(b.x, c.x, lt), mb(b.y, c.y, lt), this.setTargetDelta(b), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Jh(E, this.layout.layoutBox, this.relativeParent.layout.layoutBox), A4(this.relativeTarget, this.relativeTargetOrigin, E, lt), X && e4(this.relativeTarget, X) && (this.isProjectionDirty = !1), X || (X = qe()), fi(X, this.relativeTarget)), j && (this.animationValues = v, s4(v, g, this.latestValues, lt, it, K)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = lt }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(c) { this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (vr(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = le.update(() => { Uh.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Vo(0)), this.currentAnimation = o4(this.motionValue, [0, 1e3], { ...c, velocity: 0, isSync: !0, onUpdate: d => { this.mixTargetDelta(d), c.onUpdate && c.onUpdate(d) }, onStop: () => { }, onComplete: () => { c.onComplete && c.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const c = this.getStack(); c && c.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(f4), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const c = this.getLead(); let { targetWithTransforms: d, target: p, layout: g, latestValues: v } = c; if (!(!d || !p || !g)) { if (this !== c && this.layout && g && IS(this.options.animationType, this.layout.layoutBox, g.layoutBox)) { p = this.target || qe(); const b = gn(this.layout.layoutBox.x); p.x.min = c.target.x.min, p.x.max = p.x.min + b; const E = gn(this.layout.layoutBox.y); p.y.min = c.target.y.min, p.y.max = p.y.min + E } fi(d, p), Ao(d, v), du(this.projectionDeltaWithTransform, this.layoutCorrected, d, v) } } registerSharedNode(c, d) { this.sharedNodes.has(c) || this.sharedNodes.set(c, new h4), this.sharedNodes.get(c).add(d); const g = d.options.initialPromotionConfig; d.promote({ transition: g ? g.transition : void 0, preserveFollowOpacity: g && g.shouldPreserveFollowOpacity ? g.shouldPreserveFollowOpacity(d) : void 0 }) } isLead() { const c = this.getStack(); return c ? c.lead === this : !0 } getLead() { const { layoutId: c } = this.options; return c ? this.getStack()?.lead || this : this } getPrevLead() { const { layoutId: c } = this.options; return c ? this.getStack()?.prevLead : void 0 } getStack() { const { layoutId: c } = this.options; if (c) return this.root.sharedNodes.get(c) } promote({ needsReset: c, transition: d, preserveFollowOpacity: p } = {}) { const g = this.getStack(); g && g.promote(this, p), c && (this.projectionDelta = void 0, this.needsReset = !0), d && this.setOptions({ transition: d }) } relegate() { const c = this.getStack(); return c ? c.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: c } = this.options; if (!c) return; let d = !1; const { latestValues: p } = c; if ((p.z || p.rotate || p.rotateX || p.rotateY || p.rotateZ || p.skewX || p.skewY) && (d = !0), !d) return; const g = {}; p.z && ap("z", c, g, this.animationValues); for (let v = 0; v < rp.length; v++)ap(`rotate${rp[v]}`, c, g, this.animationValues), ap(`skew${rp[v]}`, c, g, this.animationValues); c.render(); for (const v in g) c.setStaticValue(v, g[v]), this.animationValues && (this.animationValues[v] = g[v]); c.scheduleRender() } applyProjectionStyles(c, d) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { c.visibility = "hidden"; return } const p = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, c.visibility = "", c.opacity = "", c.pointerEvents = jh(d?.pointerEvents) || "", c.transform = p ? p(this.latestValues, "") : "none"; return } const g = this.getLead(); if (!this.projectionDelta || !this.layout || !g.target) { this.options.layoutId && (c.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, c.pointerEvents = jh(d?.pointerEvents) || ""), this.hasProjected && !ca(this.latestValues) && (c.transform = p ? p({}, "") : "none", this.hasProjected = !1); return } c.visibility = ""; const v = g.animationValues || g.latestValues; this.applyTransformsToTarget(); let b = n4(this.projectionDeltaWithTransform, this.treeScale, v); p && (b = p(v, b)), c.transform = b; const { x: E, y: x } = this.projectionDelta; c.transformOrigin = `${E.origin * 100}% ${x.origin * 100}% 0`, g.animationValues ? c.opacity = g === this ? v.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : c.opacity = g === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0; for (const M in Yp) { if (v[M] === void 0) continue; const { correct: j, applyTo: z, isCSSVariable: K } = Yp[M], it = b === "none" ? v[M] : j(v[M], g); if (z) { const X = z.length; for (let at = 0; at < X; at++)c[z[at]] = it } else K ? this.options.visualElement.renderState.vars[M] = it : c[M] = it } this.options.layoutId && (c.pointerEvents = g === this ? jh(d?.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(c => c.currentAnimation?.stop()), this.root.nodes.forEach(hb), this.root.sharedNodes.clear() } } } function m4(e) { e.updateLayout() } function p4(e) { const t = e.resumeFrom?.snapshot || e.snapshot; if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) { const { layoutBox: i, measuredBox: r } = e.layout, { animationType: o } = e.options, u = t.source !== e.layout.source; o === "size" ? Ui(v => { const b = u ? t.measuredBox[v] : t.layoutBox[v], E = gn(b); b.min = i[v].min, b.max = b.min + E }) : IS(o, t.layoutBox, i) && Ui(v => { const b = u ? t.measuredBox[v] : t.layoutBox[v], E = gn(i[v]); b.max = b.min + E, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[v].max = e.relativeTarget[v].min + E) }); const c = Eo(); du(c, i, t.layoutBox); const d = Eo(); u ? du(d, e.applyTransform(r, !0), t.measuredBox) : du(d, i, t.layoutBox); const p = !xS(c); let g = !1; if (!e.resumeFrom) { const v = e.getClosestProjectingParent(); if (v && !v.resumeFrom) { const { snapshot: b, layout: E } = v; if (b && E) { const x = qe(); Jh(x, t.layoutBox, b.layoutBox); const M = qe(); Jh(M, i, E.layoutBox), CS(x, M) || (g = !0), v.options.layoutRoot && (e.relativeTarget = M, e.relativeTargetOrigin = x, e.relativeParent = v) } } } e.notifyListeners("didUpdate", { layout: i, snapshot: t, delta: d, layoutDelta: c, hasLayoutChanged: p, hasRelativeLayoutChanged: g }) } else if (e.isLead()) { const { onExitComplete: i } = e.options; i && i() } e.options.transition = void 0 } function g4(e) { e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function y4(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function v4(e) { e.clearSnapshot() } function hb(e) { e.clearMeasurements() } function fb(e) { e.isLayoutDirty = !1 } function _4(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function db(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function b4(e) { e.resolveTargetDelta() } function T4(e) { e.calcProjection() } function E4(e) { e.resetSkewAndRotation() } function S4(e) { e.removeLeadSnapshot() } function mb(e, t, i) { e.translate = pe(t.translate, 0, i), e.scale = pe(t.scale, 1, i), e.origin = t.origin, e.originPoint = t.originPoint } function pb(e, t, i, r) { e.min = pe(t.min, i.min, r), e.max = pe(t.max, i.max, r) } function A4(e, t, i, r) { pb(e.x, t.x, i.x, r), pb(e.y, t.y, i.y, r) } function w4(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const x4 = { duration: .45, ease: [.4, 0, .1, 1] }, gb = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), yb = gb("applewebkit/") && !gb("chrome/") ? Math.round : Zn; function vb(e) { e.min = yb(e.min), e.max = yb(e.max) } function C4(e) { vb(e.x), vb(e.y) } function IS(e, t, i) { return e === "position" || e === "preserve-aspect" && !WD(ab(t), ab(i), .2) } function R4(e) { return e !== e.root && e.scroll?.wasRoot } const D4 = MS({ attachResizeListener: (e, t) => Au(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0, y: document.documentElement.scrollTop || document.body?.scrollTop || 0 }), checkIsScrollRoot: () => !0 }), op = { current: void 0 }, OS = MS({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!op.current) { const e = new D4({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), op.current = e } return op.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), Zg = J.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); function _b(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function V4(...e) { return t => { let i = !1; const r = e.map(o => { const u = _b(o, t); return !i && typeof u == "function" && (i = !0), u }); if (i) return () => { for (let o = 0; o < r.length; o++) { const u = r[o]; typeof u == "function" ? u() : _b(e[o], null) } } } } function M4(...e) { return J.useCallback(V4(...e), e) } class I4 extends J.Component { getSnapshotBeforeUpdate(t) { const i = this.props.childRef.current; if (i && t.isPresent && !this.props.isPresent && this.props.pop !== !1) { const r = i.offsetParent, o = Fp(r) && r.offsetWidth || 0, u = Fp(r) && r.offsetHeight || 0, c = this.props.sizeRef.current; c.height = i.offsetHeight || 0, c.width = i.offsetWidth || 0, c.top = i.offsetTop, c.left = i.offsetLeft, c.right = o - c.width - c.left, c.bottom = u - c.height - c.top } return null } componentDidUpdate() { } render() { return this.props.children } } function O4({ children: e, isPresent: t, anchorX: i, anchorY: r, root: o, pop: u }) {
  const c = J.useId(), d = J.useRef(null), p = J.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0, bottom: 0 }), { nonce: g } = J.useContext(Zg), v = e.props?.ref ?? e?.ref, b = M4(d, v); return J.useInsertionEffect(() => {
    const { width: E, height: x, top: M, left: j, right: z, bottom: K } = p.current; if (t || u === !1 || !d.current || !E || !x) return; const it = i === "left" ? `left: ${j}` : `right: ${z}`, X = r === "bottom" ? `bottom: ${K}` : `top: ${M}`; d.current.dataset.motionPopId = c; const at = document.createElement("style"); g && (at.nonce = g); const lt = o ?? document.head; return lt.appendChild(at), at.sheet && at.sheet.insertRule(`
          [data-motion-pop-id="${c}"] {
            position: absolute !important;
            width: ${E}px !important;
            height: ${x}px !important;
            ${it}px !important;
            ${X}px !important;
          }
        `), () => { lt.contains(at) && lt.removeChild(at) }
  }, [t]), F.jsx(I4, { isPresent: t, childRef: d, sizeRef: p, pop: u, children: u === !1 ? e : J.cloneElement(e, { ref: b }) })
} const N4 = ({ children: e, initial: t, isPresent: i, onExitComplete: r, custom: o, presenceAffectsLayout: u, mode: c, anchorX: d, anchorY: p, root: g }) => { const v = Sg(P4), b = J.useId(); let E = !0, x = J.useMemo(() => (E = !1, { id: b, initial: t, isPresent: i, custom: o, onExitComplete: M => { v.set(M, !0); for (const j of v.values()) if (!j) return; r && r() }, register: M => (v.set(M, !1), () => v.delete(M)) }), [i, v, r]); return u && E && (x = { ...x }), J.useMemo(() => { v.forEach((M, j) => v.set(j, !1)) }, [i]), J.useEffect(() => { !i && !v.size && r && r() }, [i]), e = F.jsx(O4, { pop: c === "popLayout", isPresent: i, anchorX: d, anchorY: p, root: g, children: e }), F.jsx(Af.Provider, { value: x, children: e }) }; function P4() { return new Map } function NS(e = !0) { const t = J.useContext(Af); if (t === null) return [!0, null]; const { isPresent: i, onExitComplete: r, register: o } = t, u = J.useId(); J.useEffect(() => { if (e) return o(u) }, [e]); const c = J.useCallback(() => e && r && r(u), [u, r, e]); return !i && r ? [!1, c] : [!0] } const Ah = e => e.key || ""; function bb(e) { const t = []; return J.Children.forEach(e, i => { J.isValidElement(i) && t.push(i) }), t } const k4 = ({ children: e, custom: t, initial: i = !0, onExitComplete: r, presenceAffectsLayout: o = !0, mode: u = "sync", propagate: c = !1, anchorX: d = "left", anchorY: p = "top", root: g }) => { const [v, b] = NS(c), E = J.useMemo(() => bb(e), [e]), x = c && !v ? [] : E.map(Ah), M = J.useRef(!0), j = J.useRef(E), z = Sg(() => new Map), K = J.useRef(new Set), [it, X] = J.useState(E), [at, lt] = J.useState(E); hE(() => { M.current = !1, j.current = E; for (let A = 0; A < at.length; A++) { const C = Ah(at[A]); x.includes(C) ? (z.delete(C), K.current.delete(C)) : z.get(C) !== !0 && z.set(C, !1) } }, [at, x.length, x.join("-")]); const ht = []; if (E !== it) { let A = [...E]; for (let C = 0; C < at.length; C++) { const O = at[C], I = Ah(O); x.includes(I) || (A.splice(C, 0, O), ht.push(O)) } return u === "wait" && ht.length && (A = ht), lt(bb(A)), X(E), null } const { forceRender: R } = J.useContext(Eg); return F.jsx(F.Fragment, { children: at.map(A => { const C = Ah(A), O = c && !v ? !1 : E === at || x.includes(C), I = () => { if (K.current.has(C)) return; if (K.current.add(C), z.has(C)) z.set(C, !0); else return; let k = !0; z.forEach(D => { D || (k = !1) }), k && (R?.(), lt(j.current), c && b?.(), r && r()) }; return F.jsx(N4, { isPresent: O, initial: !M.current || i ? void 0 : !1, custom: t, presenceAffectsLayout: o, mode: u, root: g, onExitComplete: O ? void 0 : I, anchorX: d, anchorY: p, children: A }, C) }) }) }, PS = J.createContext({ strict: !1 }), Tb = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }; let Eb = !1; function L4() { if (Eb) return; const e = {}; for (const t in Tb) e[t] = { isEnabled: i => Tb[t].some(r => !!i[r]) }; cS(e), Eb = !0 } function kS() { return L4(), ED() } function z4(e) { const t = kS(); for (const i in e) t[i] = { ...t[i], ...e[i] }; cS(t) } const j4 = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "propagate", "ignoreStrict", "viewport"]); function tf(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || j4.has(e) } let LS = e => !tf(e); function U4(e) { typeof e == "function" && (LS = t => t.startsWith("on") ? !tf(t) : e(t)) } try { U4(require("@emotion/is-prop-valid").default) } catch { } function B4(e, t, i) { const r = {}; for (const o in e) o === "values" && typeof e.values == "object" || (LS(o) || i === !0 && tf(o) || !t && !tf(o) || e.draggable && o.startsWith("onDrag")) && (r[o] = e[o]); return r } const Cf = J.createContext({}); function F4(e, t) { if (xf(e)) { const { initial: i, animate: r } = e; return { initial: i === !1 || Su(i) ? i : void 0, animate: Su(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function q4(e) { const { initial: t, animate: i } = F4(e, J.useContext(Cf)); return J.useMemo(() => ({ initial: t, animate: i }), [Sb(t), Sb(i)]) } function Sb(e) { return Array.isArray(e) ? e.join(" ") : e } const Jg = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function zS(e, t, i) { for (const r in t) !hn(t[r]) && !yS(r, i) && (e[r] = t[r]) } function H4({ transformTemplate: e }, t) { return J.useMemo(() => { const i = Jg(); return Wg(i, t, e), Object.assign({}, i.vars, i.style) }, [t]) } function G4(e, t) { const i = e.style || {}, r = {}; return zS(r, i, e), Object.assign(r, H4(e, t)), r } function Y4(e, t) { const i = {}, r = G4(e, t); return e.drag && e.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0), i.style = r, i } const jS = () => ({ ...Jg(), attrs: {} }); function K4(e, t, i, r) { const o = J.useMemo(() => { const u = jS(); return vS(u, t, bS(r), e.transformTemplate, e.style), { ...u.attrs, style: { ...u.style } } }, [t]); if (e.style) { const u = {}; zS(u, e.style, e), o.style = { ...u, ...o.style } } return o } const Q4 = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function ty(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(Q4.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function X4(e, t, i, { latestValues: r }, o, u = !1, c) { const p = (c ?? ty(e) ? K4 : Y4)(t, r, o, e), g = B4(t, typeof e == "string", u), v = e !== J.Fragment ? { ...g, ...p, ref: i } : {}, { children: b } = t, E = J.useMemo(() => hn(b) ? b.get() : b, [b]); return J.createElement(e, { ...v, children: E }) } function W4({ scrapeMotionValuesFromProps: e, createRenderState: t }, i, r, o) { return { latestValues: $4(i, r, o, e), renderState: t() } } function $4(e, t, i, r) { const o = {}, u = r(e, {}); for (const E in u) o[E] = jh(u[E]); let { initial: c, animate: d } = e; const p = xf(e), g = uS(e); t && g && !p && e.inherit !== !1 && (c === void 0 && (c = t.initial), d === void 0 && (d = t.animate)); let v = i ? i.initial === !1 : !1; v = v || c === !1; const b = v ? d : c; if (b && typeof b != "boolean" && !wf(b)) { const E = Array.isArray(b) ? b : [b]; for (let x = 0; x < E.length; x++) { const M = Fg(e, E[x]); if (M) { const { transitionEnd: j, transition: z, ...K } = M; for (const it in K) { let X = K[it]; if (Array.isArray(X)) { const at = v ? X.length - 1 : 0; X = X[at] } X !== null && (o[it] = X) } for (const it in j) o[it] = j[it] } } } return o } const US = e => (t, i) => { const r = J.useContext(Cf), o = J.useContext(Af), u = () => W4(e, t, r, o); return i ? u() : Sg(u) }, Z4 = US({ scrapeMotionValuesFromProps: $g, createRenderState: Jg }), J4 = US({ scrapeMotionValuesFromProps: TS, createRenderState: jS }), tV = Symbol.for("motionComponentSymbol"); function eV(e, t, i) { const r = J.useRef(i); J.useInsertionEffect(() => { r.current = i }); const o = J.useRef(null); return J.useCallback(u => { u && e.onMount?.(u), t && (u ? t.mount(u) : t.unmount()); const c = r.current; if (typeof c == "function") if (u) { const d = c(u); typeof d == "function" && (o.current = d) } else o.current ? (o.current(), o.current = null) : c(u); else c && (c.current = u) }, [t]) } const BS = J.createContext({}); function po(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function nV(e, t, i, r, o, u) { const { visualElement: c } = J.useContext(Cf), d = J.useContext(PS), p = J.useContext(Af), g = J.useContext(Zg), v = g.reducedMotion, b = g.skipAnimations, E = J.useRef(null), x = J.useRef(!1); r = r || d.renderer, !E.current && r && (E.current = r(e, { visualState: t, parent: c, props: i, presenceContext: p, blockInitialAnimation: p ? p.initial === !1 : !1, reducedMotionConfig: v, skipAnimations: b, isSVG: u }), x.current && E.current && (E.current.manuallyAnimateOnMount = !0)); const M = E.current, j = J.useContext(BS); M && !M.projection && o && (M.type === "html" || M.type === "svg") && iV(E.current, i, o, j); const z = J.useRef(!1); J.useInsertionEffect(() => { M && z.current && M.update(i, p) }); const K = i[XE], it = J.useRef(!!K && !window.MotionHandoffIsComplete?.(K) && window.MotionHasOptimisedAnimation?.(K)); return hE(() => { x.current = !0, M && (z.current = !0, window.MotionIsMounted = !0, M.updateFeatures(), M.scheduleRenderMicrotask(), it.current && M.animationState && M.animationState.animateChanges()) }), J.useEffect(() => { M && (!it.current && M.animationState && M.animationState.animateChanges(), it.current && (queueMicrotask(() => { window.MotionHandoffMarkAsComplete?.(K) }), it.current = !1), M.enteringChildren = void 0) }), M } function iV(e, t, i, r) { const { layoutId: o, layout: u, drag: c, dragConstraints: d, layoutScroll: p, layoutRoot: g, layoutCrossfade: v } = t; e.projection = new i(e.latestValues, t["data-framer-portal-id"] ? void 0 : FS(e.parent)), e.projection.setOptions({ layoutId: o, layout: u, alwaysMeasureLayout: !!c || d && po(d), visualElement: e, animationType: typeof u == "string" ? u : "both", initialPromotionConfig: r, crossfade: v, layoutScroll: p, layoutRoot: g }) } function FS(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : FS(e.parent) } function lp(e, { forwardMotionProps: t = !1, type: i } = {}, r, o) { r && z4(r); const u = i ? i === "svg" : ty(e), c = u ? J4 : Z4; function d(g, v) { let b; const E = { ...J.useContext(Zg), ...g, layoutId: sV(g) }, { isStatic: x } = E, M = q4(g), j = c(g, x); if (!x && cE) { rV(); const z = aV(E); b = z.MeasureLayout, M.visualElement = nV(e, j, E, o, z.ProjectionNode, u) } return F.jsxs(Cf.Provider, { value: M, children: [b && M.visualElement ? F.jsx(b, { visualElement: M.visualElement, ...E }) : null, X4(e, g, eV(j, M.visualElement, v), j, x, t, u)] }) } d.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`; const p = J.forwardRef(d); return p[tV] = e, p } function sV({ layoutId: e }) { const t = J.useContext(Eg).id; return t && e !== void 0 ? t + "-" + e : e } function rV(e, t) { J.useContext(PS).strict } function aV(e) { const t = kS(), { drag: i, layout: r } = t; if (!i && !r) return {}; const o = { ...i, ...r }; return { MeasureLayout: i?.isEnabled(e) || r?.isEnabled(e) ? o.MeasureLayout : void 0, ProjectionNode: o.ProjectionNode } } function oV(e, t) { if (typeof Proxy > "u") return lp; const i = new Map, r = (u, c) => lp(u, c, e, t), o = (u, c) => r(u, c); return new Proxy(o, { get: (u, c) => c === "create" ? r : (i.has(c) || i.set(c, lp(c, void 0, e, t)), i.get(c)) }) } const lV = (e, t) => t.isSVG ?? ty(e) ? new jD(t) : new OD(t, { allowProjection: e !== J.Fragment }); class uV extends Cr { constructor(t) { super(t), t.animationState || (t.animationState = HD(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); wf(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: i } = this.node.prevProps || {}; t !== i && this.updateAnimationControlsSubscription() } unmount() { this.node.animationState.reset(), this.unmountControls?.() } } let cV = 0; class hV extends Cr { constructor() { super(...arguments), this.id = cV++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: i } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const o = this.node.animationState.setActive("exit", !t); i && !t && o.then(() => { i(this.id) }) } mount() { const { register: t, onExitComplete: i } = this.node.presenceContext || {}; i && i(this.id), t && (this.unmount = t(this.id)) } unmount() { } } const fV = { animation: { Feature: uV }, exit: { Feature: hV } }; function ju(e) { return { point: { x: e.pageX, y: e.pageY } } } const dV = e => t => Yg(t) && e(t, ju(t)); function mu(e, t, i, r) { return Au(e, t, dV(i), r) } const qS = ({ current: e }) => e ? e.ownerDocument.defaultView : null, Ab = (e, t) => Math.abs(e - t); function mV(e, t) { const i = Ab(e.x, t.x), r = Ab(e.y, t.y); return Math.sqrt(i ** 2 + r ** 2) } const wb = new Set(["auto", "scroll"]); class HS { constructor(t, i, { transformPagePoint: r, contextWindow: o = window, dragSnapToOrigin: u = !1, distanceThreshold: c = 3, element: d } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = new Map, this.removeScrollListeners = null, this.onElementScroll = x => { this.handleScroll(x.target) }, this.onWindowScroll = () => { this.handleScroll(window) }, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const x = cp(this.lastMoveEventInfo, this.history), M = this.startEvent !== null, j = mV(x.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!M && !j) return; const { point: z } = x, { timestamp: K } = en; this.history.push({ ...z, timestamp: K }); const { onStart: it, onMove: X } = this.handlers; M || (it && it(this.lastMoveEvent, x), this.startEvent = this.lastMoveEvent), X && X(this.lastMoveEvent, x) }, this.handlePointerMove = (x, M) => { this.lastMoveEvent = x, this.lastMoveEventInfo = up(M, this.transformPagePoint), le.update(this.updatePoint, !0) }, this.handlePointerUp = (x, M) => { this.end(); const { onEnd: j, onSessionEnd: z, resumeAnimation: K } = this.handlers; if ((this.dragSnapToOrigin || !this.startEvent) && K && K(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const it = cp(x.type === "pointercancel" ? this.lastMoveEventInfo : up(M, this.transformPagePoint), this.history); this.startEvent && j && j(x, it), z && z(x, it) }, !Yg(t)) return; this.dragSnapToOrigin = u, this.handlers = i, this.transformPagePoint = r, this.distanceThreshold = c, this.contextWindow = o || window; const p = ju(t), g = up(p, this.transformPagePoint), { point: v } = g, { timestamp: b } = en; this.history = [{ ...v, timestamp: b }]; const { onSessionStart: E } = i; E && E(t, cp(g, this.history)), this.removeListeners = ku(mu(this.contextWindow, "pointermove", this.handlePointerMove), mu(this.contextWindow, "pointerup", this.handlePointerUp), mu(this.contextWindow, "pointercancel", this.handlePointerUp)), d && this.startScrollTracking(d) } startScrollTracking(t) { let i = t.parentElement; for (; i;) { const r = getComputedStyle(i); (wb.has(r.overflowX) || wb.has(r.overflowY)) && this.scrollPositions.set(i, { x: i.scrollLeft, y: i.scrollTop }), i = i.parentElement } this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }), window.addEventListener("scroll", this.onElementScroll, { capture: !0, passive: !0 }), window.addEventListener("scroll", this.onWindowScroll, { passive: !0 }), this.removeScrollListeners = () => { window.removeEventListener("scroll", this.onElementScroll, { capture: !0 }), window.removeEventListener("scroll", this.onWindowScroll) } } handleScroll(t) { const i = this.scrollPositions.get(t); if (!i) return; const r = t === window, o = r ? { x: window.scrollX, y: window.scrollY } : { x: t.scrollLeft, y: t.scrollTop }, u = { x: o.x - i.x, y: o.y - i.y }; u.x === 0 && u.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += u.x, this.lastMoveEventInfo.point.y += u.y) : this.history.length > 0 && (this.history[0].x -= u.x, this.history[0].y -= u.y), this.scrollPositions.set(t, o), le.update(this.updatePoint, !0)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), vr(this.updatePoint) } } function up(e, t) { return t ? { point: t(e.point) } : e } function xb(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function cp({ point: e }, t) { return { point: e, delta: xb(e, GS(t)), offset: xb(e, pV(t)), velocity: gV(t, .1) } } function pV(e) { return e[0] } function GS(e) { return e[e.length - 1] } function gV(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let i = e.length - 1, r = null; const o = GS(e); for (; i >= 0 && (r = e[i], !(o.timestamp - r.timestamp > Hi(t)));)i--; if (!r) return { x: 0, y: 0 }; r === e[0] && e.length > 2 && o.timestamp - r.timestamp > Hi(t) * 2 && (r = e[1]); const u = $n(o.timestamp - r.timestamp); if (u === 0) return { x: 0, y: 0 }; const c = { x: (o.x - r.x) / u, y: (o.y - r.y) / u }; return c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c } function yV(e, { min: t, max: i }, r) { return t !== void 0 && e < t ? e = r ? pe(t, e, r.min) : Math.max(e, t) : i !== void 0 && e > i && (e = r ? pe(i, e, r.max) : Math.min(e, i)), e } function Cb(e, t, i) { return { min: t !== void 0 ? e.min + t : void 0, max: i !== void 0 ? e.max + i - (e.max - e.min) : void 0 } } function vV(e, { top: t, left: i, bottom: r, right: o }) { return { x: Cb(e.x, i, o), y: Cb(e.y, t, r) } } function Rb(e, t) { let i = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([i, r] = [r, i]), { min: i, max: r } } function _V(e, t) { return { x: Rb(e.x, t.x), y: Rb(e.y, t.y) } } function bV(e, t) { let i = .5; const r = gn(e), o = gn(t); return o > r ? i = bu(t.min, t.max - r, e.min) : r > o && (i = bu(e.min, e.max - o, t.min)), Xi(0, 1, i) } function TV(e, t) { const i = {}; return t.min !== void 0 && (i.min = t.min - e.min), t.max !== void 0 && (i.max = t.max - e.min), i } const Kp = .35; function EV(e = Kp) { return e === !1 ? e = 0 : e === !0 && (e = Kp), { x: Db(e, "left", "right"), y: Db(e, "top", "bottom") } } function Db(e, t, i) { return { min: Vb(e, t), max: Vb(e, i) } } function Vb(e, t) { return typeof e == "number" ? e : e[t] || 0 } const SV = new WeakMap; class AV { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = qe(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t } start(t, { snapToCursor: i = !1, distanceThreshold: r } = {}) { const { presenceContext: o } = this.visualElement; if (o && o.isPresent === !1) return; const u = b => { i && this.snapToCursor(ju(b).point), this.stopAnimation() }, c = (b, E) => { const { drag: x, dragPropagation: M, onDragStart: j } = this.getProps(); if (x && !M && (this.openDragLock && this.openDragLock(), this.openDragLock = ZR(x), !this.openDragLock)) return; this.latestPointerEvent = b, this.latestPanInfo = E, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Ui(K => { let it = this.getAxisMotionValue(K).get() || 0; if (Gi.test(it)) { const { projection: X } = this.visualElement; if (X && X.layout) { const at = X.layout.layoutBox[K]; at && (it = gn(at) * (parseFloat(it) / 100)) } } this.originPoint[K] = it }), j && le.update(() => j(b, E), !1, !0), jp(this.visualElement, "transform"); const { animationState: z } = this.visualElement; z && z.setActive("whileDrag", !0) }, d = (b, E) => { this.latestPointerEvent = b, this.latestPanInfo = E; const { dragPropagation: x, dragDirectionLock: M, onDirectionLock: j, onDrag: z } = this.getProps(); if (!x && !this.openDragLock) return; const { offset: K } = E; if (M && this.currentDirection === null) { this.currentDirection = xV(K), this.currentDirection !== null && j && j(this.currentDirection); return } this.updateAxis("x", E.point, K), this.updateAxis("y", E.point, K), this.visualElement.render(), z && le.update(() => z(b, E), !1, !0) }, p = (b, E) => { this.latestPointerEvent = b, this.latestPanInfo = E, this.stop(b, E), this.latestPointerEvent = null, this.latestPanInfo = null }, g = () => { const { dragSnapToOrigin: b } = this.getProps(); (b || this.constraints) && this.startAnimation({ x: 0, y: 0 }) }, { dragSnapToOrigin: v } = this.getProps(); this.panSession = new HS(t, { onSessionStart: u, onStart: c, onMove: d, onSessionEnd: p, resumeAnimation: g }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: v, distanceThreshold: r, contextWindow: qS(this.visualElement), element: this.visualElement.current }) } stop(t, i) { const r = t || this.latestPointerEvent, o = i || this.latestPanInfo, u = this.isDragging; if (this.cancel(), !u || !o || !r) return; const { velocity: c } = o; this.startAnimation(c); const { onDragEnd: d } = this.getProps(); d && le.postRender(() => d(r, o)) } cancel() { this.isDragging = !1; const { projection: t, animationState: i } = this.visualElement; t && (t.isAnimationBlocked = !1), this.endPanSession(); const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), i && i.setActive("whileDrag", !1) } endPanSession() { this.panSession && this.panSession.end(), this.panSession = void 0 } updateAxis(t, i, r) { const { drag: o } = this.getProps(); if (!r || !wh(t, o, this.currentDirection)) return; const u = this.getAxisMotionValue(t); let c = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (c = yV(c, this.constraints[t], this.elastic[t])), u.set(c) } resolveConstraints() { const { dragConstraints: t, dragElastic: i } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, o = this.constraints; t && po(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = vV(r.layoutBox, t) : this.constraints = !1, this.elastic = EV(i), o !== this.constraints && !po(t) && r && this.constraints && !this.hasMutatedConstraints && Ui(u => { this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = TV(r.layoutBox[u], this.constraints[u])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: i } = this.getProps(); if (!t || !po(t)) return !1; const r = t.current, { projection: o } = this.visualElement; if (!o || !o.layout) return !1; const u = CD(r, o.root, this.visualElement.getTransformPagePoint()); let c = _V(o.layout.layoutBox, u); if (i) { const d = i(AD(c)); this.hasMutatedConstraints = !!d, d && (c = fS(d)) } return c } startAnimation(t) { const { drag: i, dragMomentum: r, dragElastic: o, dragTransition: u, dragSnapToOrigin: c, onDragTransitionEnd: d } = this.getProps(), p = this.constraints || {}, g = Ui(v => { if (!wh(v, i, this.currentDirection)) return; let b = p && p[v] || {}; c && (b = { min: 0, max: 0 }); const E = o ? 200 : 1e6, x = o ? 40 : 1e7, M = { type: "inertia", velocity: r ? t[v] : 0, bounceStiffness: E, bounceDamping: x, timeConstant: 750, restDelta: 1, restSpeed: 10, ...u, ...b }; return this.startAxisValueAnimation(v, M) }); return Promise.all(g).then(d) } startAxisValueAnimation(t, i) { const r = this.getAxisMotionValue(t); return jp(this.visualElement, t), r.start(Bg(t, r, 0, i, this.visualElement, !1)) } stopAnimation() { Ui(t => this.getAxisMotionValue(t).stop()) } getAxisMotionValue(t) { const i = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), o = r[i]; return o || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { Ui(i => { const { drag: r } = this.getProps(); if (!wh(i, r, this.currentDirection)) return; const { projection: o } = this.visualElement, u = this.getAxisMotionValue(i); if (o && o.layout) { const { min: c, max: d } = o.layout.layoutBox[i], p = u.get() || 0; u.set(t[i] - pe(c, d, .5) + p) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: i } = this.getProps(), { projection: r } = this.visualElement; if (!po(i) || !r || !this.constraints) return; this.stopAnimation(); const o = { x: 0, y: 0 }; Ui(c => { const d = this.getAxisMotionValue(c); if (d && this.constraints !== !1) { const p = d.get(); o[c] = bV({ min: p, max: p }, this.constraints[c]) } }); const { transformTemplate: u } = this.visualElement.getProps(); this.visualElement.current.style.transform = u ? u({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.constraints = !1, this.resolveConstraints(), Ui(c => { if (!wh(c, t, null)) return; const d = this.getAxisMotionValue(c), { min: p, max: g } = this.constraints[c]; d.set(pe(p, g, o[c])) }), this.visualElement.render() } addListeners() { if (!this.visualElement.current) return; SV.set(this.visualElement, this); const t = this.visualElement.current, i = mu(t, "pointerdown", g => { const { drag: v, dragListener: b = !0 } = this.getProps(), E = g.target, x = E !== t && sD(E); v && b && !x && this.start(g) }); let r; const o = () => { const { dragConstraints: g } = this.getProps(); po(g) && g.current && (this.constraints = this.resolveRefConstraints(), r || (r = wV(t, g.current, () => this.scalePositionWithinConstraints()))) }, { projection: u } = this.visualElement, c = u.addEventListener("measure", o); u && !u.layout && (u.root && u.root.updateScroll(), u.updateLayout()), le.read(o); const d = Au(window, "resize", () => this.scalePositionWithinConstraints()), p = u.addEventListener("didUpdate", (({ delta: g, hasLayoutChanged: v }) => { this.isDragging && v && (Ui(b => { const E = this.getAxisMotionValue(b); E && (this.originPoint[b] += g[b].translate, E.set(E.get() + g[b].translate)) }), this.visualElement.render()) })); return () => { d(), i(), c(), p && p(), r && r() } } getProps() { const t = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: r = !1, dragPropagation: o = !1, dragConstraints: u = !1, dragElastic: c = Kp, dragMomentum: d = !0 } = t; return { ...t, drag: i, dragDirectionLock: r, dragPropagation: o, dragConstraints: u, dragElastic: c, dragMomentum: d } } } function Mb(e) { let t = !0; return () => { if (t) { t = !1; return } e() } } function wV(e, t, i) { const r = z1(e, Mb(i)), o = z1(t, Mb(i)); return () => { r(), o() } } function wh(e, t, i) { return (t === !0 || t === e) && (i === null || i === e) } function xV(e, t = 10) { let i = null; return Math.abs(e.y) > t ? i = "y" : Math.abs(e.x) > t && (i = "x"), i } class CV extends Cr { constructor(t) { super(t), this.removeGroupControls = Zn, this.removeListeners = Zn, this.controls = new AV(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Zn } update() { const { dragControls: t } = this.node.getProps(), { dragControls: i } = this.node.prevProps || {}; t !== i && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls))) } unmount() { this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession() } } const hp = e => (t, i) => { e && le.update(() => e(t, i), !1, !0) }; class RV extends Cr { constructor() { super(...arguments), this.removePointerDownListener = Zn } onPointerDown(t) { this.session = new HS(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: qS(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: i, onPan: r, onPanEnd: o } = this.node.getProps(); return { onSessionStart: hp(t), onStart: hp(i), onMove: hp(r), onEnd: (u, c) => { delete this.session, o && le.postRender(() => o(u, c)) } } } mount() { this.removePointerDownListener = mu(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } let fp = !1; class DV extends J.Component { componentDidMount() { const { visualElement: t, layoutGroup: i, switchLayoutGroup: r, layoutId: o } = this.props, { projection: u } = t; u && (i.group && i.group.add(u), r && r.register && o && r.register(u), fp && u.root.didUpdate(), u.addEventListener("animationComplete", () => { this.safeToRemove() }), u.setOptions({ ...u.options, layoutDependency: this.props.layoutDependency, onExitComplete: () => this.safeToRemove() })), Uh.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: i, visualElement: r, drag: o, isPresent: u } = this.props, { projection: c } = r; return c && (c.isPresent = u, t.layoutDependency !== i && c.setOptions({ ...c.options, layoutDependency: i }), fp = !0, o || t.layoutDependency !== i || i === void 0 || t.isPresent !== u ? c.willUpdate() : this.safeToRemove(), t.isPresent !== u && (u ? c.promote() : c.relegate() || le.postRender(() => { const d = c.getStack(); (!d || !d.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Gg.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: i, switchLayoutGroup: r } = this.props, { projection: o } = t; fp = !0, o && (o.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(o), r && r.deregister && r.deregister(o)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function YS(e) { const [t, i] = NS(), r = J.useContext(Eg); return F.jsx(DV, { ...e, layoutGroup: r, switchLayoutGroup: J.useContext(BS), isPresent: t, safeToRemove: i }) } const VV = { pan: { Feature: RV }, drag: { Feature: CV, ProjectionNode: OS, MeasureLayout: YS } }; function Ib(e, t, i) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", i === "Start"); const o = "onHover" + i, u = r[o]; u && le.postRender(() => u(t, ju(t))) } class MV extends Cr { mount() { const { current: t } = this.node; t && (this.unmount = tD(t, (i, r) => (Ib(this.node, r, "Start"), o => Ib(this.node, o, "End")))) } unmount() { } } class IV extends Cr { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = ku(Au(this.node.current, "focus", () => this.onFocus()), Au(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function Ob(e, t, i) { const { props: r } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && r.whileTap && e.animationState.setActive("whileTap", i === "Start"); const o = "onTap" + (i === "End" ? "" : i), u = r[o]; u && le.postRender(() => u(t, ju(t))) } class OV extends Cr { mount() { const { current: t } = this.node; if (!t) return; const { globalTapTarget: i, propagate: r } = this.node.props; this.unmount = aD(t, (o, u) => (Ob(this.node, u, "Start"), (c, { success: d }) => Ob(this.node, c, d ? "End" : "Cancel")), { useGlobalTarget: i, stopPropagation: r?.tap === !1 }) } unmount() { } } const Qp = new WeakMap, dp = new WeakMap, NV = e => { const t = Qp.get(e.target); t && t(e) }, PV = e => { e.forEach(NV) }; function kV({ root: e, ...t }) { const i = e || document; dp.has(i) || dp.set(i, {}); const r = dp.get(i), o = JSON.stringify(t); return r[o] || (r[o] = new IntersectionObserver(PV, { root: e, ...t })), r[o] } function LV(e, t, i) { const r = kV(t); return Qp.set(e, i), r.observe(e), () => { Qp.delete(e), r.unobserve(e) } } const zV = { some: 0, all: 1 }; class jV extends Cr { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: i, margin: r, amount: o = "some", once: u } = t, c = { root: i ? i.current : void 0, rootMargin: r, threshold: typeof o == "number" ? o : zV[o] }, d = p => { const { isIntersecting: g } = p; if (this.isInView === g || (this.isInView = g, u && !g && this.hasEnteredView)) return; g && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", g); const { onViewportEnter: v, onViewportLeave: b } = this.node.getProps(), E = g ? v : b; E && E(p) }; return LV(this.node.current, c, d) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: i } = this.node;["amount", "margin", "root"].some(UV(t, i)) && this.startObserver() } unmount() { } } function UV({ viewport: e = {} }, { viewport: t = {} } = {}) { return i => e[i] !== t[i] } const BV = { inView: { Feature: jV }, tap: { Feature: OV }, focus: { Feature: IV }, hover: { Feature: MV } }, FV = { layout: { ProjectionNode: OS, MeasureLayout: YS } }, qV = { ...fV, ...BV, ...VV, ...FV }, dr = oV(qV, lV); function HV({ onEnter: e }) { return F.jsxs("div", { className: "flex flex-col items-center justify-center min-h-screen text-center p-6 bg-gradient-to-b from-slate-950 to-slate-900", children: [F.jsxs(dr.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .8 }, className: "space-y-6 max-w-2xl", children: [F.jsx("span", { className: "text-tesla-red uppercase tracking-[0.2em] text-sm font-bold", children: "Weekly Event" }), F.jsxs("h1", { className: "text-5xl md:text-7xl font-bold tracking-tight text-white mb-4", children: ["Open Mic ", F.jsx("span", { className: "text-slate-500", children: "Night" })] }), F.jsx("div", { className: "h-px w-24 bg-tesla-red mx-auto my-8" }), F.jsxs("p", { className: "text-lg text-slate-300 leading-relaxed max-w-lg mx-auto", children: ["Every Sunday at ", F.jsx("span", { className: "text-white font-semibold", children: "My Cafe Buzz" }), ". Join us for a night of music, comedy, and poetry."] }), F.jsxs("div", { className: "grid grid-cols-2 gap-4 text-left text-sm text-slate-400 bg-white/5 p-6 rounded-lg border border-white/10 backdrop-blur-sm", children: [F.jsxs("div", { children: [F.jsx("p", { className: "uppercase tracking-wider text-xs mb-1 text-slate-500", children: "Host" }), F.jsx("p", { className: "text-white", children: 'Anthony K' })] }), F.jsxs("div", { children: [F.jsx("p", { className: "uppercase tracking-wider text-xs mb-1 text-slate-500", children: "Time" }), F.jsx("p", { className: "text-white", children: "2:00 PM - 5:00 PM" })] }), F.jsxs("div", { children: [F.jsx("p", { className: "uppercase tracking-wider text-xs mb-1 text-slate-500", children: "Location" }), F.jsx("p", { className: "text-white", children: "My Cafe Buzz, Bellefonte" })] }), F.jsxs("div", { children: [F.jsx("p", { className: "uppercase tracking-wider text-xs mb-1 text-slate-500", children: "Equipment" }), F.jsx("p", { className: "text-white", children: "1 x microphone, 1 x PA speaker, 1 x floor monitor" })] })] }), F.jsx(dr.button, { whileHover: { scale: 1.02 }, whileTap: { scale: .98 }, onClick: e, className: "bg-white text-slate-900 px-8 py-4 rounded font-bold uppercase tracking-widest hover:bg-slate-200 transition-colors mt-8 w-full md:w-auto", children: "Sign Up / View Schedule" })] }), F.jsx(dr.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, transition: { delay: 1, duration: 1 }, className: "absolute bottom-6 text-xs text-slate-600 uppercase tracking-widest", children: "Free Parking behind the venue" })] }) } let GV = { data: "" }, YV = e => { if (typeof window == "object") { let t = (e ? e.querySelector("#_goober") : window._goober) || Object.assign(document.createElement("style"), { innerHTML: " ", id: "_goober" }); return t.nonce = window.__nonce__, t.parentNode || (e || document.head).appendChild(t), t.firstChild } return e || GV }, KV = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, QV = /\/\*[^]*?\*\/|  +/g, Nb = /\n+/g, ur = (e, t) => { let i = "", r = "", o = ""; for (let u in e) { let c = e[u]; u[0] == "@" ? u[1] == "i" ? i = u + " " + c + ";" : r += u[1] == "f" ? ur(c, u) : u + "{" + ur(c, u[1] == "k" ? "" : t) + "}" : typeof c == "object" ? r += ur(c, t ? t.replace(/([^,])+/g, d => u.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, p => /&/.test(p) ? p.replace(/&/g, d) : d ? d + " " + p : p)) : u) : c != null && (u = /^--/.test(u) ? u : u.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ur.p ? ur.p(u, c) : u + ":" + c + ";") } return i + (t && o ? t + "{" + o + "}" : o) + r }, vs = {}, KS = e => { if (typeof e == "object") { let t = ""; for (let i in e) t += i + KS(e[i]); return t } return e }, XV = (e, t, i, r, o) => { let u = KS(e), c = vs[u] || (vs[u] = (p => { let g = 0, v = 11; for (; g < p.length;)v = 101 * v + p.charCodeAt(g++) >>> 0; return "go" + v })(u)); if (!vs[c]) { let p = u !== e ? e : (g => { let v, b, E = [{}]; for (; v = KV.exec(g.replace(QV, ""));)v[4] ? E.shift() : v[3] ? (b = v[3].replace(Nb, " ").trim(), E.unshift(E[0][b] = E[0][b] || {})) : E[0][v[1]] = v[2].replace(Nb, " ").trim(); return E[0] })(e); vs[c] = ur(o ? { ["@keyframes " + c]: p } : p, i ? "" : "." + c) } let d = i && vs.g ? vs.g : null; return i && (vs.g = vs[c]), ((p, g, v, b) => { b ? g.data = g.data.replace(b, p) : g.data.indexOf(p) === -1 && (g.data = v ? p + g.data : g.data + p) })(vs[c], t, r, d), c }, WV = (e, t, i) => e.reduce((r, o, u) => { let c = t[u]; if (c && c.call) { let d = c(i), p = d && d.props && d.props.className || /^go/.test(d) && d; c = p ? "." + p : d && typeof d == "object" ? d.props ? "" : ur(d, "") : d === !1 ? "" : d } return r + o + (c ?? "") }, ""); function Rf(e) { let t = this || {}, i = e.call ? e(t.p) : e; return XV(i.unshift ? i.raw ? WV(i, [].slice.call(arguments, 1), t.p) : i.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : i, YV(t.target), t.g, t.o, t.k) } let QS, Xp, Wp; Rf.bind({ g: 1 }); let Ss = Rf.bind({ k: 1 }); function $V(e, t, i, r) { ur.p = t, QS = e, Xp = i, Wp = r } function Rr(e, t) { let i = this || {}; return function () { let r = arguments; function o(u, c) { let d = Object.assign({}, u), p = d.className || o.className; i.p = Object.assign({ theme: Xp && Xp() }, d), i.o = / *go\d+/.test(p), d.className = Rf.apply(i, r) + (p ? " " + p : ""); let g = e; return e[0] && (g = d.as || e, delete d.as), Wp && g[0] && Wp(d), QS(g, d) } return o } } var ZV = e => typeof e == "function", ef = (e, t) => ZV(e) ? e(t) : e, JV = (() => { let e = 0; return () => (++e).toString() })(), XS = (() => { let e; return () => { if (e === void 0 && typeof window < "u") { let t = matchMedia("(prefers-reduced-motion: reduce)"); e = !t || t.matches } return e } })(), tM = 20, ey = "default", WS = (e, t) => { let { toastLimit: i } = e.settings; switch (t.type) { case 0: return { ...e, toasts: [t.toast, ...e.toasts].slice(0, i) }; case 1: return { ...e, toasts: e.toasts.map(c => c.id === t.toast.id ? { ...c, ...t.toast } : c) }; case 2: let { toast: r } = t; return WS(e, { type: e.toasts.find(c => c.id === r.id) ? 1 : 0, toast: r }); case 3: let { toastId: o } = t; return { ...e, toasts: e.toasts.map(c => c.id === o || o === void 0 ? { ...c, dismissed: !0, visible: !1 } : c) }; case 4: return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter(c => c.id !== t.toastId) }; case 5: return { ...e, pausedAt: t.time }; case 6: let u = t.time - (e.pausedAt || 0); return { ...e, pausedAt: void 0, toasts: e.toasts.map(c => ({ ...c, pauseDuration: c.pauseDuration + u })) } } }, Bh = [], $S = { toasts: [], pausedAt: void 0, settings: { toastLimit: tM } }, qi = {}, ZS = (e, t = ey) => { qi[t] = WS(qi[t] || $S, e), Bh.forEach(([i, r]) => { i === t && r(qi[t]) }) }, JS = e => Object.keys(qi).forEach(t => ZS(e, t)), eM = e => Object.keys(qi).find(t => qi[t].toasts.some(i => i.id === e)), Df = (e = ey) => t => { ZS(t, e) }, nM = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, iM = (e = {}, t = ey) => { let [i, r] = J.useState(qi[t] || $S), o = J.useRef(qi[t]); J.useEffect(() => (o.current !== qi[t] && r(qi[t]), Bh.push([t, r]), () => { let c = Bh.findIndex(([d]) => d === t); c > -1 && Bh.splice(c, 1) }), [t]); let u = i.toasts.map(c => { var d, p, g; return { ...e, ...e[c.type], ...c, removeDelay: c.removeDelay || ((d = e[c.type]) == null ? void 0 : d.removeDelay) || e?.removeDelay, duration: c.duration || ((p = e[c.type]) == null ? void 0 : p.duration) || e?.duration || nM[c.type], style: { ...e.style, ...(g = e[c.type]) == null ? void 0 : g.style, ...c.style } } }); return { ...i, toasts: u } }, sM = (e, t = "blank", i) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...i, id: i?.id || JV() }), Uu = e => (t, i) => { let r = sM(t, e, i); return Df(r.toasterId || eM(r.id))({ type: 2, toast: r }), r.id }, me = (e, t) => Uu("blank")(e, t); me.error = Uu("error"); me.success = Uu("success"); me.loading = Uu("loading"); me.custom = Uu("custom"); me.dismiss = (e, t) => { let i = { type: 3, toastId: e }; t ? Df(t)(i) : JS(i) }; me.dismissAll = e => me.dismiss(void 0, e); me.remove = (e, t) => { let i = { type: 4, toastId: e }; t ? Df(t)(i) : JS(i) }; me.removeAll = e => me.remove(void 0, e); me.promise = (e, t, i) => { let r = me.loading(t.loading, { ...i, ...i?.loading }); return typeof e == "function" && (e = e()), e.then(o => { let u = t.success ? ef(t.success, o) : void 0; return u ? me.success(u, { id: r, ...i, ...i?.success }) : me.dismiss(r), o }).catch(o => { let u = t.error ? ef(t.error, o) : void 0; u ? me.error(u, { id: r, ...i, ...i?.error }) : me.dismiss(r) }), e }; var rM = 1e3, aM = (e, t = "default") => { let { toasts: i, pausedAt: r } = iM(e, t), o = J.useRef(new Map).current, u = J.useCallback((b, E = rM) => { if (o.has(b)) return; let x = setTimeout(() => { o.delete(b), c({ type: 4, toastId: b }) }, E); o.set(b, x) }, []); J.useEffect(() => { if (r) return; let b = Date.now(), E = i.map(x => { if (x.duration === 1 / 0) return; let M = (x.duration || 0) + x.pauseDuration - (b - x.createdAt); if (M < 0) { x.visible && me.dismiss(x.id); return } return setTimeout(() => me.dismiss(x.id, t), M) }); return () => { E.forEach(x => x && clearTimeout(x)) } }, [i, r, t]); let c = J.useCallback(Df(t), [t]), d = J.useCallback(() => { c({ type: 5, time: Date.now() }) }, [c]), p = J.useCallback((b, E) => { c({ type: 1, toast: { id: b, height: E } }) }, [c]), g = J.useCallback(() => { r && c({ type: 6, time: Date.now() }) }, [r, c]), v = J.useCallback((b, E) => { let { reverseOrder: x = !1, gutter: M = 8, defaultPosition: j } = E || {}, z = i.filter(X => (X.position || j) === (b.position || j) && X.height), K = z.findIndex(X => X.id === b.id), it = z.filter((X, at) => at < K && X.visible).length; return z.filter(X => X.visible).slice(...x ? [it + 1] : [0, it]).reduce((X, at) => X + (at.height || 0) + M, 0) }, [i]); return J.useEffect(() => { i.forEach(b => { if (b.dismissed) u(b.id, b.removeDelay); else { let E = o.get(b.id); E && (clearTimeout(E), o.delete(b.id)) } }) }, [i, u]), { toasts: i, handlers: { updateHeight: p, startPause: d, endPause: g, calculateOffset: v } } }, oM = Ss`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, lM = Ss`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, uM = Ss`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, cM = Rr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oM} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${lM} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${e => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${uM} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, hM = Ss`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, fM = Rr("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${e => e.secondary || "#e0e0e0"};
  border-right-color: ${e => e.primary || "#616161"};
  animation: ${hM} 1s linear infinite;
`, dM = Ss`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, mM = Ss`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, pM = Rr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${dM} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${mM} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${e => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, gM = Rr("div")`
  position: absolute;
`, yM = Rr("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, vM = Ss`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, _M = Rr("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${vM} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, bM = ({ toast: e }) => { let { icon: t, type: i, iconTheme: r } = e; return t !== void 0 ? typeof t == "string" ? J.createElement(_M, null, t) : t : i === "blank" ? null : J.createElement(yM, null, J.createElement(fM, { ...r }), i !== "loading" && J.createElement(gM, null, i === "error" ? J.createElement(cM, { ...r }) : J.createElement(pM, { ...r }))) }, TM = e => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, EM = e => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, SM = "0%{opacity:0;} 100%{opacity:1;}", AM = "0%{opacity:1;} 100%{opacity:0;}", wM = Rr("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, xM = Rr("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, CM = (e, t) => { let i = e.includes("top") ? 1 : -1, [r, o] = XS() ? [SM, AM] : [TM(i), EM(i)]; return { animation: t ? `${Ss(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ss(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` } }, RM = J.memo(({ toast: e, position: t, style: i, children: r }) => { let o = e.height ? CM(e.position || t || "top-center", e.visible) : { opacity: 0 }, u = J.createElement(bM, { toast: e }), c = J.createElement(xM, { ...e.ariaProps }, ef(e.message, e)); return J.createElement(wM, { className: e.className, style: { ...o, ...i, ...e.style } }, typeof r == "function" ? r({ icon: u, message: c }) : J.createElement(J.Fragment, null, u, c)) }); $V(J.createElement); var DM = ({ id: e, className: t, style: i, onHeightUpdate: r, children: o }) => { let u = J.useCallback(c => { if (c) { let d = () => { let p = c.getBoundingClientRect().height; r(e, p) }; d(), new MutationObserver(d).observe(c, { subtree: !0, childList: !0, characterData: !0 }) } }, [e, r]); return J.createElement("div", { ref: u, className: t, style: i }, o) }, VM = (e, t) => { let i = e.includes("top"), r = i ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {}; return { left: 0, right: 0, display: "flex", position: "absolute", transition: XS() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (i ? 1 : -1)}px)`, ...r, ...o } }, MM = Rf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, xh = 16, IM = ({ reverseOrder: e, position: t = "top-center", toastOptions: i, gutter: r, children: o, toasterId: u, containerStyle: c, containerClassName: d }) => { let { toasts: p, handlers: g } = aM(i, u); return J.createElement("div", { "data-rht-toaster": u || "", style: { position: "fixed", zIndex: 9999, top: xh, left: xh, right: xh, bottom: xh, pointerEvents: "none", ...c }, className: d, onMouseEnter: g.startPause, onMouseLeave: g.endPause }, p.map(v => { let b = v.position || t, E = g.calculateOffset(v, { reverseOrder: e, gutter: r, defaultPosition: t }), x = VM(b, E); return J.createElement(DM, { id: v.id, key: v.id, onHeightUpdate: g.updateHeight, className: v.visible ? MM : "", style: x }, v.type === "custom" ? ef(v.message, v) : o ? o(v) : J.createElement(RM, { toast: v, position: b })) })) }, tA = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, Pb = fr.createContext && fr.createContext(tA), OM = ["attr", "size", "title"]; function NM(e, t) { if (e == null) return {}; var i = PM(e, t), r, o; if (Object.getOwnPropertySymbols) { var u = Object.getOwnPropertySymbols(e); for (o = 0; o < u.length; o++)r = u[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]) } return i } function PM(e, t) { if (e == null) return {}; var i = {}; for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) { if (t.indexOf(r) >= 0) continue; i[r] = e[r] } return i } function nf() { return nf = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t]; for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e }, nf.apply(this, arguments) } function kb(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter(function (o) { return Object.getOwnPropertyDescriptor(e, o).enumerable })), i.push.apply(i, r) } return i } function sf(e) { for (var t = 1; t < arguments.length; t++) { var i = arguments[t] != null ? arguments[t] : {}; t % 2 ? kb(Object(i), !0).forEach(function (r) { kM(e, r, i[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : kb(Object(i)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(i, r)) }) } return e } function kM(e, t, i) { return t = LM(t), t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function LM(e) { var t = zM(e, "string"); return typeof t == "symbol" ? t : t + "" } function zM(e, t) { if (typeof e != "object" || !e) return e; var i = e[Symbol.toPrimitive]; if (i !== void 0) { var r = i.call(e, t); if (typeof r != "object") return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } function eA(e) { return e && e.map((t, i) => fr.createElement(t.tag, sf({ key: i }, t.attr), eA(t.child))) } function Zi(e) { return t => fr.createElement(jM, nf({ attr: sf({}, e.attr) }, t), eA(e.child)) } function jM(e) { var t = i => { var { attr: r, size: o, title: u } = e, c = NM(e, OM), d = o || i.size || "1em", p; return i.className && (p = i.className), e.className && (p = (p ? p + " " : "") + e.className), fr.createElement("svg", nf({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, i.attr, r, c, { className: p, style: sf(sf({ color: e.color || i.color }, i.style), e.style), height: d, width: d, xmlns: "http://www.w3.org/2000/svg" }), u && fr.createElement("title", null, u), e.children) }; return Pb !== void 0 ? fr.createElement(Pb.Consumer, null, i => t(i)) : t(tA) } function UM(e) { return Zi({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" }, child: [] }] })(e) } function BM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256,8C119,8,8,119,8,256S119,504,256,504,504,393,504,256,393,8,256,8Zm92.49,313h0l-20,25a16,16,0,0,1-22.49,2.5h0l-67-49.72a40,40,0,0,1-15-31.23V112a16,16,0,0,1,16-16h32a16,16,0,0,1,16,16V256l58,42.5A16,16,0,0,1,348.49,321Z" }, child: [] }] })(e) } function FM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z" }, child: [] }] })(e) } function qM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M504 255.531c.253 136.64-111.18 248.372-247.82 248.468-59.015.042-113.223-20.53-155.822-54.911-11.077-8.94-11.905-25.541-1.839-35.607l11.267-11.267c8.609-8.609 22.353-9.551 31.891-1.984C173.062 425.135 212.781 440 256 440c101.705 0 184-82.311 184-184 0-101.705-82.311-184-184-184-48.814 0-93.149 18.969-126.068 49.932l50.754 50.754c10.08 10.08 2.941 27.314-11.313 27.314H24c-8.837 0-16-7.163-16-16V38.627c0-14.254 17.234-21.393 27.314-11.314l49.372 49.372C129.209 34.136 189.552 8 256 8c136.81 0 247.747 110.78 248 247.531zm-180.912 78.784l9.823-12.63c8.138-10.463 6.253-25.542-4.21-33.679L288 256.349V152c0-13.255-10.745-24-24-24h-16c-13.255 0-24 10.745-24 24v135.651l65.409 50.874c10.463 8.137 25.541 6.253 33.679-4.21z" }, child: [] }] })(e) } function HM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z" }, child: [] }] })(e) } function GM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z" }, child: [] }] })(e) } function YM(e) { return Zi({ attr: { viewBox: "0 0 352 512" }, child: [{ tag: "path", attr: { d: "M336 192h-16c-8.84 0-16 7.16-16 16v48c0 74.8-64.49 134.82-140.79 127.38C96.71 376.89 48 317.11 48 250.3V208c0-8.84-7.16-16-16-16H16c-8.84 0-16 7.16-16 16v40.16c0 89.64 63.97 169.55 152 181.69V464H96c-8.84 0-16 7.16-16 16v16c0 8.84 7.16 16 16 16h160c8.84 0 16-7.16 16-16v-16c0-8.84-7.16-16-16-16h-56v-33.77C285.71 418.47 352 344.9 352 256v-48c0-8.84-7.16-16-16-16zM176 352c53.02 0 96-42.98 96-96h-85.33c-5.89 0-10.67-3.58-10.67-8v-16c0-4.42 4.78-8 10.67-8H272v-32h-85.33c-5.89 0-10.67-3.58-10.67-8v-16c0-4.42 4.78-8 10.67-8H272v-32h-85.33c-5.89 0-10.67-3.58-10.67-8v-16c0-4.42 4.78-8 10.67-8H272c0-53.02-42.98-96-96-96S80 42.98 80 96v160c0 53.02 42.98 96 96 96z" }, child: [] }] })(e) } function KM(e) { return Zi({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z" }, child: [] }] })(e) } function QM(e) { return Zi({ attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z" }, child: [] }] })(e) } function rf(e) { return Zi({ attr: { viewBox: "0 0 352 512" }, child: [{ tag: "path", attr: { d: "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z" }, child: [] }] })(e) } function nA(e) { var t, i, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var o = e.length; for (t = 0; t < o; t++)e[t] && (i = nA(e[t])) && (r && (r += " "), r += i) } else for (i in e) e[i] && (r && (r += " "), r += i); return r } function XM() { for (var e, t, i = 0, r = "", o = arguments.length; i < o; i++)(e = arguments[i]) && (t = nA(e)) && (r && (r += " "), r += t); return r } const WM = (e, t) => { const i = new Array(e.length + t.length); for (let r = 0; r < e.length; r++)i[r] = e[r]; for (let r = 0; r < t.length; r++)i[e.length + r] = t[r]; return i }, $M = (e, t) => ({ classGroupId: e, validator: t }), iA = (e = new Map, t = null, i) => ({ nextPart: e, validators: t, classGroupId: i }), af = "-", Lb = [], ZM = "arbitrary..", JM = e => { const t = e6(e), { conflictingClassGroups: i, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: c => { if (c.startsWith("[") && c.endsWith("]")) return t6(c); const d = c.split(af), p = d[0] === "" && d.length > 1 ? 1 : 0; return sA(d, p, t) }, getConflictingClassGroupIds: (c, d) => { if (d) { const p = r[c], g = i[c]; return p ? g ? WM(g, p) : p : g || Lb } return i[c] || Lb } } }, sA = (e, t, i) => { if (e.length - t === 0) return i.classGroupId; const o = e[t], u = i.nextPart.get(o); if (u) { const g = sA(e, t + 1, u); if (g) return g } const c = i.validators; if (c === null) return; const d = t === 0 ? e.join(af) : e.slice(t).join(af), p = c.length; for (let g = 0; g < p; g++) { const v = c[g]; if (v.validator(d)) return v.classGroupId } }, t6 = e => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => { const t = e.slice(1, -1), i = t.indexOf(":"), r = t.slice(0, i); return r ? ZM + r : void 0 })(), e6 = e => { const { theme: t, classGroups: i } = e; return n6(i, t) }, n6 = (e, t) => { const i = iA(); for (const r in e) { const o = e[r]; ny(o, i, r, t) } return i }, ny = (e, t, i, r) => { const o = e.length; for (let u = 0; u < o; u++) { const c = e[u]; i6(c, t, i, r) } }, i6 = (e, t, i, r) => { if (typeof e == "string") { s6(e, t, i); return } if (typeof e == "function") { r6(e, t, i, r); return } a6(e, t, i, r) }, s6 = (e, t, i) => { const r = e === "" ? t : rA(t, e); r.classGroupId = i }, r6 = (e, t, i, r) => { if (o6(e)) { ny(e(r), t, i, r); return } t.validators === null && (t.validators = []), t.validators.push($M(i, e)) }, a6 = (e, t, i, r) => { const o = Object.entries(e), u = o.length; for (let c = 0; c < u; c++) { const [d, p] = o[c]; ny(p, rA(t, d), i, r) } }, rA = (e, t) => { let i = e; const r = t.split(af), o = r.length; for (let u = 0; u < o; u++) { const c = r[u]; let d = i.nextPart.get(c); d || (d = iA(), i.nextPart.set(c, d)), i = d } return i }, o6 = e => "isThemeGetter" in e && e.isThemeGetter === !0, l6 = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, i = Object.create(null), r = Object.create(null); const o = (u, c) => { i[u] = c, t++, t > e && (t = 0, r = i, i = Object.create(null)) }; return { get(u) { let c = i[u]; if (c !== void 0) return c; if ((c = r[u]) !== void 0) return o(u, c), c }, set(u, c) { u in i ? i[u] = c : o(u, c) } } }, $p = "!", zb = ":", u6 = [], jb = (e, t, i, r, o) => ({ modifiers: e, hasImportantModifier: t, baseClassName: i, maybePostfixModifierPosition: r, isExternal: o }), c6 = e => { const { prefix: t, experimentalParseClassName: i } = e; let r = o => { const u = []; let c = 0, d = 0, p = 0, g; const v = o.length; for (let j = 0; j < v; j++) { const z = o[j]; if (c === 0 && d === 0) { if (z === zb) { u.push(o.slice(p, j)), p = j + 1; continue } if (z === "/") { g = j; continue } } z === "[" ? c++ : z === "]" ? c-- : z === "(" ? d++ : z === ")" && d-- } const b = u.length === 0 ? o : o.slice(p); let E = b, x = !1; b.endsWith($p) ? (E = b.slice(0, -1), x = !0) : b.startsWith($p) && (E = b.slice(1), x = !0); const M = g && g > p ? g - p : void 0; return jb(u, x, E, M) }; if (t) { const o = t + zb, u = r; r = c => c.startsWith(o) ? u(c.slice(o.length)) : jb(u6, !1, c, void 0, !0) } if (i) { const o = r; r = u => i({ className: u, parseClassName: o }) } return r }, h6 = e => { const t = new Map; return e.orderSensitiveModifiers.forEach((i, r) => { t.set(i, 1e6 + r) }), i => { const r = []; let o = []; for (let u = 0; u < i.length; u++) { const c = i[u], d = c[0] === "[", p = t.has(c); d || p ? (o.length > 0 && (o.sort(), r.push(...o), o = []), r.push(c)) : o.push(c) } return o.length > 0 && (o.sort(), r.push(...o)), r } }, f6 = e => ({ cache: l6(e.cacheSize), parseClassName: c6(e), sortModifiers: h6(e), ...JM(e) }), d6 = /\s+/, m6 = (e, t) => { const { parseClassName: i, getClassGroupId: r, getConflictingClassGroupIds: o, sortModifiers: u } = t, c = [], d = e.trim().split(d6); let p = ""; for (let g = d.length - 1; g >= 0; g -= 1) { const v = d[g], { isExternal: b, modifiers: E, hasImportantModifier: x, baseClassName: M, maybePostfixModifierPosition: j } = i(v); if (b) { p = v + (p.length > 0 ? " " + p : p); continue } let z = !!j, K = r(z ? M.substring(0, j) : M); if (!K) { if (!z) { p = v + (p.length > 0 ? " " + p : p); continue } if (K = r(M), !K) { p = v + (p.length > 0 ? " " + p : p); continue } z = !1 } const it = E.length === 0 ? "" : E.length === 1 ? E[0] : u(E).join(":"), X = x ? it + $p : it, at = X + K; if (c.indexOf(at) > -1) continue; c.push(at); const lt = o(K, z); for (let ht = 0; ht < lt.length; ++ht) { const R = lt[ht]; c.push(X + R) } p = v + (p.length > 0 ? " " + p : p) } return p }, p6 = (...e) => { let t = 0, i, r, o = ""; for (; t < e.length;)(i = e[t++]) && (r = aA(i)) && (o && (o += " "), o += r); return o }, aA = e => { if (typeof e == "string") return e; let t, i = ""; for (let r = 0; r < e.length; r++)e[r] && (t = aA(e[r])) && (i && (i += " "), i += t); return i }, g6 = (e, ...t) => { let i, r, o, u; const c = p => { const g = t.reduce((v, b) => b(v), e()); return i = f6(g), r = i.cache.get, o = i.cache.set, u = d, d(p) }, d = p => { const g = r(p); if (g) return g; const v = m6(p, i); return o(p, v), v }; return u = c, (...p) => u(p6(...p)) }, y6 = [], Fe = e => { const t = i => i[e] || y6; return t.isThemeGetter = !0, t }, oA = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, lA = /^\((?:(\w[\w-]*):)?(.+)\)$/i, v6 = /^\d+\/\d+$/, _6 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, b6 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, T6 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, E6 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, S6 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, fo = e => v6.test(e), Nt = e => !!e && !Number.isNaN(Number(e)), ar = e => !!e && Number.isInteger(Number(e)), mp = e => e.endsWith("%") && Nt(e.slice(0, -1)), _s = e => _6.test(e), A6 = () => !0, w6 = e => b6.test(e) && !T6.test(e), uA = () => !1, x6 = e => E6.test(e), C6 = e => S6.test(e), R6 = e => !pt(e) && !gt(e), D6 = e => Bo(e, fA, uA), pt = e => oA.test(e), ua = e => Bo(e, dA, w6), pp = e => Bo(e, N6, Nt), Ub = e => Bo(e, cA, uA), V6 = e => Bo(e, hA, C6), Ch = e => Bo(e, mA, x6), gt = e => lA.test(e), nu = e => Fo(e, dA), M6 = e => Fo(e, P6), Bb = e => Fo(e, cA), I6 = e => Fo(e, fA), O6 = e => Fo(e, hA), Rh = e => Fo(e, mA, !0), Bo = (e, t, i) => { const r = oA.exec(e); return r ? r[1] ? t(r[1]) : i(r[2]) : !1 }, Fo = (e, t, i = !1) => { const r = lA.exec(e); return r ? r[1] ? t(r[1]) : i : !1 }, cA = e => e === "position" || e === "percentage", hA = e => e === "image" || e === "url", fA = e => e === "length" || e === "size" || e === "bg-size", dA = e => e === "length", N6 = e => e === "number", P6 = e => e === "family-name", mA = e => e === "shadow", k6 = () => { const e = Fe("color"), t = Fe("font"), i = Fe("text"), r = Fe("font-weight"), o = Fe("tracking"), u = Fe("leading"), c = Fe("breakpoint"), d = Fe("container"), p = Fe("spacing"), g = Fe("radius"), v = Fe("shadow"), b = Fe("inset-shadow"), E = Fe("text-shadow"), x = Fe("drop-shadow"), M = Fe("blur"), j = Fe("perspective"), z = Fe("aspect"), K = Fe("ease"), it = Fe("animate"), X = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], at = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], lt = () => [...at(), gt, pt], ht = () => ["auto", "hidden", "clip", "visible", "scroll"], R = () => ["auto", "contain", "none"], A = () => [gt, pt, p], C = () => [fo, "full", "auto", ...A()], O = () => [ar, "none", "subgrid", gt, pt], I = () => ["auto", { span: ["full", ar, gt, pt] }, ar, gt, pt], k = () => [ar, "auto", gt, pt], D = () => ["auto", "min", "max", "fr", gt, pt], Yt = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], Wt = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], Q = () => ["auto", ...A()], rt = () => [fo, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...A()], et = () => [e, gt, pt], xt = () => [...at(), Bb, Ub, { position: [gt, pt] }], Ot = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], N = () => ["auto", "cover", "contain", I6, D6, { size: [gt, pt] }], Z = () => [mp, nu, ua], ot = () => ["", "none", "full", g, gt, pt], ct = () => ["", Nt, nu, ua], Et = () => ["solid", "dashed", "dotted", "double"], Ct = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], Tt = () => [Nt, mp, Bb, Ub], ye = () => ["", "none", M, gt, pt], $t = () => ["none", Nt, gt, pt], kn = () => ["none", Nt, gt, pt], yi = () => [Nt, gt, pt], Jn = () => [fo, "full", ...A()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [_s], breakpoint: [_s], color: [A6], container: [_s], "drop-shadow": [_s], ease: ["in", "out", "in-out"], font: [R6], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [_s], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [_s], shadow: [_s], spacing: ["px", Nt], text: [_s], "text-shadow": [_s], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", fo, pt, gt, z] }], container: ["container"], columns: [{ columns: [Nt, pt, gt, d] }], "break-after": [{ "break-after": X() }], "break-before": [{ "break-before": X() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: lt() }], overflow: [{ overflow: ht() }], "overflow-x": [{ "overflow-x": ht() }], "overflow-y": [{ "overflow-y": ht() }], overscroll: [{ overscroll: R() }], "overscroll-x": [{ "overscroll-x": R() }], "overscroll-y": [{ "overscroll-y": R() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: C() }], "inset-x": [{ "inset-x": C() }], "inset-y": [{ "inset-y": C() }], start: [{ start: C() }], end: [{ end: C() }], top: [{ top: C() }], right: [{ right: C() }], bottom: [{ bottom: C() }], left: [{ left: C() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [ar, "auto", gt, pt] }], basis: [{ basis: [fo, "full", "auto", d, ...A()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [Nt, fo, "auto", "initial", "none", pt] }], grow: [{ grow: ["", Nt, gt, pt] }], shrink: [{ shrink: ["", Nt, gt, pt] }], order: [{ order: [ar, "first", "last", "none", gt, pt] }], "grid-cols": [{ "grid-cols": O() }], "col-start-end": [{ col: I() }], "col-start": [{ "col-start": k() }], "col-end": [{ "col-end": k() }], "grid-rows": [{ "grid-rows": O() }], "row-start-end": [{ row: I() }], "row-start": [{ "row-start": k() }], "row-end": [{ "row-end": k() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": D() }], "auto-rows": [{ "auto-rows": D() }], gap: [{ gap: A() }], "gap-x": [{ "gap-x": A() }], "gap-y": [{ "gap-y": A() }], "justify-content": [{ justify: [...Yt(), "normal"] }], "justify-items": [{ "justify-items": [...Wt(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...Wt()] }], "align-content": [{ content: ["normal", ...Yt()] }], "align-items": [{ items: [...Wt(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...Wt(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": Yt() }], "place-items": [{ "place-items": [...Wt(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...Wt()] }], p: [{ p: A() }], px: [{ px: A() }], py: [{ py: A() }], ps: [{ ps: A() }], pe: [{ pe: A() }], pt: [{ pt: A() }], pr: [{ pr: A() }], pb: [{ pb: A() }], pl: [{ pl: A() }], m: [{ m: Q() }], mx: [{ mx: Q() }], my: [{ my: Q() }], ms: [{ ms: Q() }], me: [{ me: Q() }], mt: [{ mt: Q() }], mr: [{ mr: Q() }], mb: [{ mb: Q() }], ml: [{ ml: Q() }], "space-x": [{ "space-x": A() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": A() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: rt() }], w: [{ w: [d, "screen", ...rt()] }], "min-w": [{ "min-w": [d, "screen", "none", ...rt()] }], "max-w": [{ "max-w": [d, "screen", "none", "prose", { screen: [c] }, ...rt()] }], h: [{ h: ["screen", "lh", ...rt()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...rt()] }], "max-h": [{ "max-h": ["screen", "lh", ...rt()] }], "font-size": [{ text: ["base", i, nu, ua] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [r, gt, pp] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", mp, pt] }], "font-family": [{ font: [M6, pt, t] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [o, gt, pt] }], "line-clamp": [{ "line-clamp": [Nt, "none", gt, pp] }], leading: [{ leading: [u, ...A()] }], "list-image": [{ "list-image": ["none", gt, pt] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", gt, pt] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: et() }], "text-color": [{ text: et() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...Et(), "wavy"] }], "text-decoration-thickness": [{ decoration: [Nt, "from-font", "auto", gt, ua] }], "text-decoration-color": [{ decoration: et() }], "underline-offset": [{ "underline-offset": [Nt, "auto", gt, pt] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: A() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", gt, pt] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", gt, pt] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: xt() }], "bg-repeat": [{ bg: Ot() }], "bg-size": [{ bg: N() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, ar, gt, pt], radial: ["", gt, pt], conic: [ar, gt, pt] }, O6, V6] }], "bg-color": [{ bg: et() }], "gradient-from-pos": [{ from: Z() }], "gradient-via-pos": [{ via: Z() }], "gradient-to-pos": [{ to: Z() }], "gradient-from": [{ from: et() }], "gradient-via": [{ via: et() }], "gradient-to": [{ to: et() }], rounded: [{ rounded: ot() }], "rounded-s": [{ "rounded-s": ot() }], "rounded-e": [{ "rounded-e": ot() }], "rounded-t": [{ "rounded-t": ot() }], "rounded-r": [{ "rounded-r": ot() }], "rounded-b": [{ "rounded-b": ot() }], "rounded-l": [{ "rounded-l": ot() }], "rounded-ss": [{ "rounded-ss": ot() }], "rounded-se": [{ "rounded-se": ot() }], "rounded-ee": [{ "rounded-ee": ot() }], "rounded-es": [{ "rounded-es": ot() }], "rounded-tl": [{ "rounded-tl": ot() }], "rounded-tr": [{ "rounded-tr": ot() }], "rounded-br": [{ "rounded-br": ot() }], "rounded-bl": [{ "rounded-bl": ot() }], "border-w": [{ border: ct() }], "border-w-x": [{ "border-x": ct() }], "border-w-y": [{ "border-y": ct() }], "border-w-s": [{ "border-s": ct() }], "border-w-e": [{ "border-e": ct() }], "border-w-t": [{ "border-t": ct() }], "border-w-r": [{ "border-r": ct() }], "border-w-b": [{ "border-b": ct() }], "border-w-l": [{ "border-l": ct() }], "divide-x": [{ "divide-x": ct() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": ct() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...Et(), "hidden", "none"] }], "divide-style": [{ divide: [...Et(), "hidden", "none"] }], "border-color": [{ border: et() }], "border-color-x": [{ "border-x": et() }], "border-color-y": [{ "border-y": et() }], "border-color-s": [{ "border-s": et() }], "border-color-e": [{ "border-e": et() }], "border-color-t": [{ "border-t": et() }], "border-color-r": [{ "border-r": et() }], "border-color-b": [{ "border-b": et() }], "border-color-l": [{ "border-l": et() }], "divide-color": [{ divide: et() }], "outline-style": [{ outline: [...Et(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [Nt, gt, pt] }], "outline-w": [{ outline: ["", Nt, nu, ua] }], "outline-color": [{ outline: et() }], shadow: [{ shadow: ["", "none", v, Rh, Ch] }], "shadow-color": [{ shadow: et() }], "inset-shadow": [{ "inset-shadow": ["none", b, Rh, Ch] }], "inset-shadow-color": [{ "inset-shadow": et() }], "ring-w": [{ ring: ct() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: et() }], "ring-offset-w": [{ "ring-offset": [Nt, ua] }], "ring-offset-color": [{ "ring-offset": et() }], "inset-ring-w": [{ "inset-ring": ct() }], "inset-ring-color": [{ "inset-ring": et() }], "text-shadow": [{ "text-shadow": ["none", E, Rh, Ch] }], "text-shadow-color": [{ "text-shadow": et() }], opacity: [{ opacity: [Nt, gt, pt] }], "mix-blend": [{ "mix-blend": [...Ct(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": Ct() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [Nt] }], "mask-image-linear-from-pos": [{ "mask-linear-from": Tt() }], "mask-image-linear-to-pos": [{ "mask-linear-to": Tt() }], "mask-image-linear-from-color": [{ "mask-linear-from": et() }], "mask-image-linear-to-color": [{ "mask-linear-to": et() }], "mask-image-t-from-pos": [{ "mask-t-from": Tt() }], "mask-image-t-to-pos": [{ "mask-t-to": Tt() }], "mask-image-t-from-color": [{ "mask-t-from": et() }], "mask-image-t-to-color": [{ "mask-t-to": et() }], "mask-image-r-from-pos": [{ "mask-r-from": Tt() }], "mask-image-r-to-pos": [{ "mask-r-to": Tt() }], "mask-image-r-from-color": [{ "mask-r-from": et() }], "mask-image-r-to-color": [{ "mask-r-to": et() }], "mask-image-b-from-pos": [{ "mask-b-from": Tt() }], "mask-image-b-to-pos": [{ "mask-b-to": Tt() }], "mask-image-b-from-color": [{ "mask-b-from": et() }], "mask-image-b-to-color": [{ "mask-b-to": et() }], "mask-image-l-from-pos": [{ "mask-l-from": Tt() }], "mask-image-l-to-pos": [{ "mask-l-to": Tt() }], "mask-image-l-from-color": [{ "mask-l-from": et() }], "mask-image-l-to-color": [{ "mask-l-to": et() }], "mask-image-x-from-pos": [{ "mask-x-from": Tt() }], "mask-image-x-to-pos": [{ "mask-x-to": Tt() }], "mask-image-x-from-color": [{ "mask-x-from": et() }], "mask-image-x-to-color": [{ "mask-x-to": et() }], "mask-image-y-from-pos": [{ "mask-y-from": Tt() }], "mask-image-y-to-pos": [{ "mask-y-to": Tt() }], "mask-image-y-from-color": [{ "mask-y-from": et() }], "mask-image-y-to-color": [{ "mask-y-to": et() }], "mask-image-radial": [{ "mask-radial": [gt, pt] }], "mask-image-radial-from-pos": [{ "mask-radial-from": Tt() }], "mask-image-radial-to-pos": [{ "mask-radial-to": Tt() }], "mask-image-radial-from-color": [{ "mask-radial-from": et() }], "mask-image-radial-to-color": [{ "mask-radial-to": et() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": at() }], "mask-image-conic-pos": [{ "mask-conic": [Nt] }], "mask-image-conic-from-pos": [{ "mask-conic-from": Tt() }], "mask-image-conic-to-pos": [{ "mask-conic-to": Tt() }], "mask-image-conic-from-color": [{ "mask-conic-from": et() }], "mask-image-conic-to-color": [{ "mask-conic-to": et() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: xt() }], "mask-repeat": [{ mask: Ot() }], "mask-size": [{ mask: N() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", gt, pt] }], filter: [{ filter: ["", "none", gt, pt] }], blur: [{ blur: ye() }], brightness: [{ brightness: [Nt, gt, pt] }], contrast: [{ contrast: [Nt, gt, pt] }], "drop-shadow": [{ "drop-shadow": ["", "none", x, Rh, Ch] }], "drop-shadow-color": [{ "drop-shadow": et() }], grayscale: [{ grayscale: ["", Nt, gt, pt] }], "hue-rotate": [{ "hue-rotate": [Nt, gt, pt] }], invert: [{ invert: ["", Nt, gt, pt] }], saturate: [{ saturate: [Nt, gt, pt] }], sepia: [{ sepia: ["", Nt, gt, pt] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", gt, pt] }], "backdrop-blur": [{ "backdrop-blur": ye() }], "backdrop-brightness": [{ "backdrop-brightness": [Nt, gt, pt] }], "backdrop-contrast": [{ "backdrop-contrast": [Nt, gt, pt] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", Nt, gt, pt] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [Nt, gt, pt] }], "backdrop-invert": [{ "backdrop-invert": ["", Nt, gt, pt] }], "backdrop-opacity": [{ "backdrop-opacity": [Nt, gt, pt] }], "backdrop-saturate": [{ "backdrop-saturate": [Nt, gt, pt] }], "backdrop-sepia": [{ "backdrop-sepia": ["", Nt, gt, pt] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": A() }], "border-spacing-x": [{ "border-spacing-x": A() }], "border-spacing-y": [{ "border-spacing-y": A() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", gt, pt] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [Nt, "initial", gt, pt] }], ease: [{ ease: ["linear", "initial", K, gt, pt] }], delay: [{ delay: [Nt, gt, pt] }], animate: [{ animate: ["none", it, gt, pt] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [j, gt, pt] }], "perspective-origin": [{ "perspective-origin": lt() }], rotate: [{ rotate: $t() }], "rotate-x": [{ "rotate-x": $t() }], "rotate-y": [{ "rotate-y": $t() }], "rotate-z": [{ "rotate-z": $t() }], scale: [{ scale: kn() }], "scale-x": [{ "scale-x": kn() }], "scale-y": [{ "scale-y": kn() }], "scale-z": [{ "scale-z": kn() }], "scale-3d": ["scale-3d"], skew: [{ skew: yi() }], "skew-x": [{ "skew-x": yi() }], "skew-y": [{ "skew-y": yi() }], transform: [{ transform: [gt, pt, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: lt() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: Jn() }], "translate-x": [{ "translate-x": Jn() }], "translate-y": [{ "translate-y": Jn() }], "translate-z": [{ "translate-z": Jn() }], "translate-none": ["translate-none"], accent: [{ accent: et() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: et() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", gt, pt] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": A() }], "scroll-mx": [{ "scroll-mx": A() }], "scroll-my": [{ "scroll-my": A() }], "scroll-ms": [{ "scroll-ms": A() }], "scroll-me": [{ "scroll-me": A() }], "scroll-mt": [{ "scroll-mt": A() }], "scroll-mr": [{ "scroll-mr": A() }], "scroll-mb": [{ "scroll-mb": A() }], "scroll-ml": [{ "scroll-ml": A() }], "scroll-p": [{ "scroll-p": A() }], "scroll-px": [{ "scroll-px": A() }], "scroll-py": [{ "scroll-py": A() }], "scroll-ps": [{ "scroll-ps": A() }], "scroll-pe": [{ "scroll-pe": A() }], "scroll-pt": [{ "scroll-pt": A() }], "scroll-pr": [{ "scroll-pr": A() }], "scroll-pb": [{ "scroll-pb": A() }], "scroll-pl": [{ "scroll-pl": A() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", gt, pt] }], fill: [{ fill: ["none", ...et()] }], "stroke-w": [{ stroke: [Nt, nu, ua, pp] }], stroke: [{ stroke: ["none", ...et()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, L6 = g6(k6); function bs(...e) { return L6(XM(e)) } function z6({ slots: e, updateSlot: t }) { const [i, r] = J.useState(!1), [o, u] = J.useState(null), [c, d] = J.useState(""), [p, g] = J.useState(""), [v, b] = J.useState("add"), E = M => { u(M), M.performer ? (b("remove"), d(M.performer), g(M.contact || "")) : (b("add"), d(""), g("")), r(!0) }, x = async () => { if (v === "add") { if (!c.trim()) { me.error("Please enter a name"); return } if (e.some(j => j.performer && j.performer.toLowerCase() === c.toLowerCase()) && !window.confirm(`"${c}" is already on the list. Are you sure you want to add another slot?`)) return; await t(o.id, { performer: c, contact: p }), me.success("Slot reserved!") } else { if (!window.confirm(`Are you sure you want to cancel the slot for ${o.performer}?`)) return; await t(o.id, { performer: null, contact: null }), me.success("Slot cleared") } r(!1) }; return F.jsxs("div", { className: "bg-slate-900/50 rounded-2xl border border-white/5 backdrop-blur-md p-6 overflow-hidden relative", children: [F.jsx("div", { className: "absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-tesla-red to-transparent opacity-50" }), F.jsxs("h2", { className: "text-xl font-semibold mb-6 flex items-center gap-2 text-slate-100", children: [F.jsx(YM, { className: "text-tesla-red" }), F.jsx("span", { children: "Performance Schedule" })] }), F.jsx("div", { className: "space-y-3", children: e.map((M, j) => F.jsxs(dr.div, { initial: { opacity: 0, x: -20 }, animate: { opacity: 1, x: 0 }, transition: { delay: j * .05 }, onClick: () => E(M), className: bs("group relative flex items-center justify-between p-4 rounded-lg border transition-all duration-300", M.performer ? "bg-slate-800/80 border-slate-700 hover:border-slate-600" : "bg-transparent border-slate-800 hover:border-slate-600 hover:bg-white/5 cursor-pointer"), children: [F.jsxs("div", { className: "flex items-center gap-4", children: [F.jsx("span", { className: bs("text-sm font-mono tracking-wider", M.performer ? "text-slate-500" : "text-tesla-red font-bold"), children: M.time }), F.jsx("span", { className: bs("text-lg font-medium", M.performer ? "text-white" : "text-slate-600 group-hover:text-slate-400"), children: M.performer || "Open Slot" })] }), F.jsx("div", { className: "opacity-0 group-hover:opacity-100 transition-opacity", children: M.performer ? F.jsx("button", { className: "p-2 text-slate-400 hover:text-red-500 transition-colors", children: F.jsx(rf, {}) }) : F.jsx("button", { className: "p-2 text-tesla-red hover:text-white transition-colors", children: F.jsx(QM, {}) }) })] }, M.id)) }), i && F.jsx("div", { className: "fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4", children: F.jsxs("div", { className: "bg-slate-900 p-8 rounded-2xl border border-slate-700 w-full max-w-md shadow-2xl relative", children: [F.jsx("button", { onClick: () => r(!1), className: "absolute top-4 right-4 text-slate-500 hover:text-white", children: F.jsx(rf, {}) }), F.jsx("h3", { className: "text-2xl font-bold mb-4 text-white", children: v === "add" ? "Reserve Slot" : "Cancel Slot" }), F.jsxs("div", { className: "mb-6", children: [F.jsx("p", { className: "text-tesla-red text-sm font-bold uppercase tracking-widest mb-2", children: "Time" }), F.jsx("p", { className: "text-3xl text-white font-mono", children: o?.time })] }), v === "add" && F.jsxs(F.Fragment, { children: [F.jsxs("div", { className: "mb-4", children: [F.jsx("label", { className: "block text-slate-400 text-sm mb-2", children: "Performer Name" }), F.jsx("input", { type: "text", value: c, onChange: M => d(M.target.value), className: "w-full bg-slate-800 border border-slate-700 rounded p-4 text-white focus:outline-none focus:border-tesla-red transition-colors", placeholder: "Enter stage name...", autoFocus: !0 }), e.some(M => M.performer && M.performer.toLowerCase() === c.toLowerCase() && c.trim() !== "") && F.jsx("p", { className: "mt-2 text-yellow-500 text-xs", children: "Note: This name is already registered for another slot." })] }), F.jsxs("div", { className: "mb-6", children: [F.jsxs("label", { className: "block text-slate-400 text-sm mb-2", children: ["Contact Info ", F.jsx("span", { className: "text-xs text-slate-600", children: "(Optional for reminders)" })] }), F.jsx("input", { type: "text", value: p, onChange: M => g(M.target.value), className: "w-full bg-slate-800 border border-slate-700 rounded p-4 text-white focus:outline-none focus:border-tesla-red transition-colors", placeholder: "Phone or Email..." })] })] }), v === "remove" && F.jsxs("p", { className: "mb-6 text-slate-300", children: ["Are you sure you want to remove ", F.jsx("span", { className: "text-white font-bold", children: o?.performer }), " from this slot?"] }), F.jsxs("div", { className: "flex gap-4", children: [F.jsx("button", { onClick: () => r(!1), className: "flex-1 py-3 rounded border border-slate-700 text-slate-300 hover:bg-slate-800 transition-colors uppercase tracking-wider text-sm font-semibold", children: "Cancel" }), F.jsx("button", { onClick: x, className: bs("flex-1 py-3 rounded text-white uppercase tracking-wider text-sm font-semibold transition-colors", v === "add" ? "bg-tesla-red hover:bg-red-700" : "bg-red-900/50 text-red-200 border border-red-900 hover:bg-red-900"), children: v === "add" ? "Confirm" : "Remove" })] })] }) })] }) } const pA = 6048e5, j6 = 864e5, U6 = 6e4, Fb = Symbol.for("constructDateFrom"); function br(e, t) { return typeof e == "function" ? e(t) : e && typeof e == "object" && Fb in e ? e[Fb](t) : e instanceof Date ? new e.constructor(t) : new Date(t) } function rn(e, t) { return br(t || e, e) } let B6 = {}; function Vf() { return B6 } function wu(e, t) { const i = Vf(), r = t?.weekStartsOn ?? t?.locale?.options?.weekStartsOn ?? i.weekStartsOn ?? i.locale?.options?.weekStartsOn ?? 0, o = rn(e, t?.in), u = o.getDay(), c = (u < r ? 7 : 0) + u - r; return o.setDate(o.getDate() - c), o.setHours(0, 0, 0, 0), o } function of(e, t) { return wu(e, { ...t, weekStartsOn: 1 }) } function gA(e, t) { const i = rn(e, t?.in), r = i.getFullYear(), o = br(i, 0); o.setFullYear(r + 1, 0, 4), o.setHours(0, 0, 0, 0); const u = of(o), c = br(i, 0); c.setFullYear(r, 0, 4), c.setHours(0, 0, 0, 0); const d = of(c); return i.getTime() >= u.getTime() ? r + 1 : i.getTime() >= d.getTime() ? r : r - 1 } function qb(e) { const t = rn(e), i = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())); return i.setUTCFullYear(t.getFullYear()), +e - +i } function F6(e, ...t) { const i = br.bind(null, t.find(r => typeof r == "object")); return t.map(i) } function Hb(e, t) { const i = rn(e, t?.in); return i.setHours(0, 0, 0, 0), i } function q6(e, t, i) { const [r, o] = F6(i?.in, e, t), u = Hb(r), c = Hb(o), d = +u - qb(u), p = +c - qb(c); return Math.round((d - p) / j6) } function H6(e, t) { const i = gA(e, t), r = br(e, 0); return r.setFullYear(i, 0, 4), r.setHours(0, 0, 0, 0), of(r) } function Gb(e, t, i) { const r = rn(e, i?.in); return r.setTime(r.getTime() + t * U6), r } function G6(e) { return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]" } function Y6(e) { return !(!G6(e) && typeof e != "number" || isNaN(+rn(e))) } function K6(e) { return t => { const r = (e ? Math[e] : Math.trunc)(t); return r === 0 ? 0 : r } } function Q6(e, t) { return +rn(e) - +rn(t) } function X6(e, t, i) { const r = Q6(e, t) / 1e3; return K6(i?.roundingMethod)(r) } function W6(e, t) { const i = rn(e, t?.in); return i.setFullYear(i.getFullYear(), 0, 1), i.setHours(0, 0, 0, 0), i } const $6 = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, Z6 = (e, t, i) => { let r; const o = $6[e]; return typeof o == "string" ? r = o : t === 1 ? r = o.one : r = o.other.replace("{{count}}", t.toString()), i?.addSuffix ? i.comparison && i.comparison > 0 ? "in " + r : r + " ago" : r }; function gp(e) { return (t = {}) => { const i = t.width ? String(t.width) : e.defaultWidth; return e.formats[i] || e.formats[e.defaultWidth] } } const J6 = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, t3 = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, e3 = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, n3 = { date: gp({ formats: J6, defaultWidth: "full" }), time: gp({ formats: t3, defaultWidth: "full" }), dateTime: gp({ formats: e3, defaultWidth: "full" }) }, i3 = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, s3 = (e, t, i, r) => i3[e]; function iu(e) { return (t, i) => { const r = i?.context ? String(i.context) : "standalone"; let o; if (r === "formatting" && e.formattingValues) { const c = e.defaultFormattingWidth || e.defaultWidth, d = i?.width ? String(i.width) : c; o = e.formattingValues[d] || e.formattingValues[c] } else { const c = e.defaultWidth, d = i?.width ? String(i.width) : e.defaultWidth; o = e.values[d] || e.values[c] } const u = e.argumentCallback ? e.argumentCallback(t) : t; return o[u] } } const r3 = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, a3 = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, o3 = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, l3 = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, u3 = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, c3 = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, h3 = (e, t) => { const i = Number(e), r = i % 100; if (r > 20 || r < 10) switch (r % 10) { case 1: return i + "st"; case 2: return i + "nd"; case 3: return i + "rd" }return i + "th" }, f3 = { ordinalNumber: h3, era: iu({ values: r3, defaultWidth: "wide" }), quarter: iu({ values: a3, defaultWidth: "wide", argumentCallback: e => e - 1 }), month: iu({ values: o3, defaultWidth: "wide" }), day: iu({ values: l3, defaultWidth: "wide" }), dayPeriod: iu({ values: u3, defaultWidth: "wide", formattingValues: c3, defaultFormattingWidth: "wide" }) }; function su(e) { return (t, i = {}) => { const r = i.width, o = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], u = t.match(o); if (!u) return null; const c = u[0], d = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], p = Array.isArray(d) ? m3(d, b => b.test(c)) : d3(d, b => b.test(c)); let g; g = e.valueCallback ? e.valueCallback(p) : p, g = i.valueCallback ? i.valueCallback(g) : g; const v = t.slice(c.length); return { value: g, rest: v } } } function d3(e, t) { for (const i in e) if (Object.prototype.hasOwnProperty.call(e, i) && t(e[i])) return i } function m3(e, t) { for (let i = 0; i < e.length; i++)if (t(e[i])) return i } function p3(e) { return (t, i = {}) => { const r = t.match(e.matchPattern); if (!r) return null; const o = r[0], u = t.match(e.parsePattern); if (!u) return null; let c = e.valueCallback ? e.valueCallback(u[0]) : u[0]; c = i.valueCallback ? i.valueCallback(c) : c; const d = t.slice(o.length); return { value: c, rest: d } } } const g3 = /^(\d+)(th|st|nd|rd)?/i, y3 = /\d+/i, v3 = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, _3 = { any: [/^b/i, /^(a|c)/i] }, b3 = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, T3 = { any: [/1/i, /2/i, /3/i, /4/i] }, E3 = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, S3 = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, A3 = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, w3 = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, x3 = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, C3 = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, R3 = { ordinalNumber: p3({ matchPattern: g3, parsePattern: y3, valueCallback: e => parseInt(e, 10) }), era: su({ matchPatterns: v3, defaultMatchWidth: "wide", parsePatterns: _3, defaultParseWidth: "any" }), quarter: su({ matchPatterns: b3, defaultMatchWidth: "wide", parsePatterns: T3, defaultParseWidth: "any", valueCallback: e => e + 1 }), month: su({ matchPatterns: E3, defaultMatchWidth: "wide", parsePatterns: S3, defaultParseWidth: "any" }), day: su({ matchPatterns: A3, defaultMatchWidth: "wide", parsePatterns: w3, defaultParseWidth: "any" }), dayPeriod: su({ matchPatterns: x3, defaultMatchWidth: "any", parsePatterns: C3, defaultParseWidth: "any" }) }, D3 = { code: "en-US", formatDistance: Z6, formatLong: n3, formatRelative: s3, localize: f3, match: R3, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }; function V3(e, t) { const i = rn(e, t?.in); return q6(i, W6(i)) + 1 } function M3(e, t) { const i = rn(e, t?.in), r = +of(i) - +H6(i); return Math.round(r / pA) + 1 } function yA(e, t) { const i = rn(e, t?.in), r = i.getFullYear(), o = Vf(), u = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? o.firstWeekContainsDate ?? o.locale?.options?.firstWeekContainsDate ?? 1, c = br(t?.in || e, 0); c.setFullYear(r + 1, 0, u), c.setHours(0, 0, 0, 0); const d = wu(c, t), p = br(t?.in || e, 0); p.setFullYear(r, 0, u), p.setHours(0, 0, 0, 0); const g = wu(p, t); return +i >= +d ? r + 1 : +i >= +g ? r : r - 1 } function I3(e, t) { const i = Vf(), r = t?.firstWeekContainsDate ?? t?.locale?.options?.firstWeekContainsDate ?? i.firstWeekContainsDate ?? i.locale?.options?.firstWeekContainsDate ?? 1, o = yA(e, t), u = br(t?.in || e, 0); return u.setFullYear(o, 0, r), u.setHours(0, 0, 0, 0), wu(u, t) } function O3(e, t) { const i = rn(e, t?.in), r = +wu(i, t) - +I3(i, t); return Math.round(r / pA) + 1 } function ee(e, t) { const i = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0"); return i + r } const or = { y(e, t) { const i = e.getFullYear(), r = i > 0 ? i : 1 - i; return ee(t === "yy" ? r % 100 : r, t.length) }, M(e, t) { const i = e.getMonth(); return t === "M" ? String(i + 1) : ee(i + 1, 2) }, d(e, t) { return ee(e.getDate(), t.length) }, a(e, t) { const i = e.getHours() / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return i.toUpperCase(); case "aaa": return i; case "aaaaa": return i[0]; default: return i === "am" ? "a.m." : "p.m." } }, h(e, t) { return ee(e.getHours() % 12 || 12, t.length) }, H(e, t) { return ee(e.getHours(), t.length) }, m(e, t) { return ee(e.getMinutes(), t.length) }, s(e, t) { return ee(e.getSeconds(), t.length) }, S(e, t) { const i = t.length, r = e.getMilliseconds(), o = Math.trunc(r * Math.pow(10, i - 3)); return ee(o, t.length) } }, mo = { midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, Yb = { G: function (e, t, i) { const r = e.getFullYear() > 0 ? 1 : 0; switch (t) { case "G": case "GG": case "GGG": return i.era(r, { width: "abbreviated" }); case "GGGGG": return i.era(r, { width: "narrow" }); default: return i.era(r, { width: "wide" }) } }, y: function (e, t, i) { if (t === "yo") { const r = e.getFullYear(), o = r > 0 ? r : 1 - r; return i.ordinalNumber(o, { unit: "year" }) } return or.y(e, t) }, Y: function (e, t, i, r) { const o = yA(e, r), u = o > 0 ? o : 1 - o; if (t === "YY") { const c = u % 100; return ee(c, 2) } return t === "Yo" ? i.ordinalNumber(u, { unit: "year" }) : ee(u, t.length) }, R: function (e, t) { const i = gA(e); return ee(i, t.length) }, u: function (e, t) { const i = e.getFullYear(); return ee(i, t.length) }, Q: function (e, t, i) { const r = Math.ceil((e.getMonth() + 1) / 3); switch (t) { case "Q": return String(r); case "QQ": return ee(r, 2); case "Qo": return i.ordinalNumber(r, { unit: "quarter" }); case "QQQ": return i.quarter(r, { width: "abbreviated", context: "formatting" }); case "QQQQQ": return i.quarter(r, { width: "narrow", context: "formatting" }); default: return i.quarter(r, { width: "wide", context: "formatting" }) } }, q: function (e, t, i) { const r = Math.ceil((e.getMonth() + 1) / 3); switch (t) { case "q": return String(r); case "qq": return ee(r, 2); case "qo": return i.ordinalNumber(r, { unit: "quarter" }); case "qqq": return i.quarter(r, { width: "abbreviated", context: "standalone" }); case "qqqqq": return i.quarter(r, { width: "narrow", context: "standalone" }); default: return i.quarter(r, { width: "wide", context: "standalone" }) } }, M: function (e, t, i) { const r = e.getMonth(); switch (t) { case "M": case "MM": return or.M(e, t); case "Mo": return i.ordinalNumber(r + 1, { unit: "month" }); case "MMM": return i.month(r, { width: "abbreviated", context: "formatting" }); case "MMMMM": return i.month(r, { width: "narrow", context: "formatting" }); default: return i.month(r, { width: "wide", context: "formatting" }) } }, L: function (e, t, i) { const r = e.getMonth(); switch (t) { case "L": return String(r + 1); case "LL": return ee(r + 1, 2); case "Lo": return i.ordinalNumber(r + 1, { unit: "month" }); case "LLL": return i.month(r, { width: "abbreviated", context: "standalone" }); case "LLLLL": return i.month(r, { width: "narrow", context: "standalone" }); default: return i.month(r, { width: "wide", context: "standalone" }) } }, w: function (e, t, i, r) { const o = O3(e, r); return t === "wo" ? i.ordinalNumber(o, { unit: "week" }) : ee(o, t.length) }, I: function (e, t, i) { const r = M3(e); return t === "Io" ? i.ordinalNumber(r, { unit: "week" }) : ee(r, t.length) }, d: function (e, t, i) { return t === "do" ? i.ordinalNumber(e.getDate(), { unit: "date" }) : or.d(e, t) }, D: function (e, t, i) { const r = V3(e); return t === "Do" ? i.ordinalNumber(r, { unit: "dayOfYear" }) : ee(r, t.length) }, E: function (e, t, i) { const r = e.getDay(); switch (t) { case "E": case "EE": case "EEE": return i.day(r, { width: "abbreviated", context: "formatting" }); case "EEEEE": return i.day(r, { width: "narrow", context: "formatting" }); case "EEEEEE": return i.day(r, { width: "short", context: "formatting" }); default: return i.day(r, { width: "wide", context: "formatting" }) } }, e: function (e, t, i, r) { const o = e.getDay(), u = (o - r.weekStartsOn + 8) % 7 || 7; switch (t) { case "e": return String(u); case "ee": return ee(u, 2); case "eo": return i.ordinalNumber(u, { unit: "day" }); case "eee": return i.day(o, { width: "abbreviated", context: "formatting" }); case "eeeee": return i.day(o, { width: "narrow", context: "formatting" }); case "eeeeee": return i.day(o, { width: "short", context: "formatting" }); default: return i.day(o, { width: "wide", context: "formatting" }) } }, c: function (e, t, i, r) { const o = e.getDay(), u = (o - r.weekStartsOn + 8) % 7 || 7; switch (t) { case "c": return String(u); case "cc": return ee(u, t.length); case "co": return i.ordinalNumber(u, { unit: "day" }); case "ccc": return i.day(o, { width: "abbreviated", context: "standalone" }); case "ccccc": return i.day(o, { width: "narrow", context: "standalone" }); case "cccccc": return i.day(o, { width: "short", context: "standalone" }); default: return i.day(o, { width: "wide", context: "standalone" }) } }, i: function (e, t, i) { const r = e.getDay(), o = r === 0 ? 7 : r; switch (t) { case "i": return String(o); case "ii": return ee(o, t.length); case "io": return i.ordinalNumber(o, { unit: "day" }); case "iii": return i.day(r, { width: "abbreviated", context: "formatting" }); case "iiiii": return i.day(r, { width: "narrow", context: "formatting" }); case "iiiiii": return i.day(r, { width: "short", context: "formatting" }); default: return i.day(r, { width: "wide", context: "formatting" }) } }, a: function (e, t, i) { const o = e.getHours() / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return i.dayPeriod(o, { width: "abbreviated", context: "formatting" }); case "aaa": return i.dayPeriod(o, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "aaaaa": return i.dayPeriod(o, { width: "narrow", context: "formatting" }); default: return i.dayPeriod(o, { width: "wide", context: "formatting" }) } }, b: function (e, t, i) { const r = e.getHours(); let o; switch (r === 12 ? o = mo.noon : r === 0 ? o = mo.midnight : o = r / 12 >= 1 ? "pm" : "am", t) { case "b": case "bb": return i.dayPeriod(o, { width: "abbreviated", context: "formatting" }); case "bbb": return i.dayPeriod(o, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "bbbbb": return i.dayPeriod(o, { width: "narrow", context: "formatting" }); default: return i.dayPeriod(o, { width: "wide", context: "formatting" }) } }, B: function (e, t, i) { const r = e.getHours(); let o; switch (r >= 17 ? o = mo.evening : r >= 12 ? o = mo.afternoon : r >= 4 ? o = mo.morning : o = mo.night, t) { case "B": case "BB": case "BBB": return i.dayPeriod(o, { width: "abbreviated", context: "formatting" }); case "BBBBB": return i.dayPeriod(o, { width: "narrow", context: "formatting" }); default: return i.dayPeriod(o, { width: "wide", context: "formatting" }) } }, h: function (e, t, i) { if (t === "ho") { let r = e.getHours() % 12; return r === 0 && (r = 12), i.ordinalNumber(r, { unit: "hour" }) } return or.h(e, t) }, H: function (e, t, i) { return t === "Ho" ? i.ordinalNumber(e.getHours(), { unit: "hour" }) : or.H(e, t) }, K: function (e, t, i) { const r = e.getHours() % 12; return t === "Ko" ? i.ordinalNumber(r, { unit: "hour" }) : ee(r, t.length) }, k: function (e, t, i) { let r = e.getHours(); return r === 0 && (r = 24), t === "ko" ? i.ordinalNumber(r, { unit: "hour" }) : ee(r, t.length) }, m: function (e, t, i) { return t === "mo" ? i.ordinalNumber(e.getMinutes(), { unit: "minute" }) : or.m(e, t) }, s: function (e, t, i) { return t === "so" ? i.ordinalNumber(e.getSeconds(), { unit: "second" }) : or.s(e, t) }, S: function (e, t) { return or.S(e, t) }, X: function (e, t, i) { const r = e.getTimezoneOffset(); if (r === 0) return "Z"; switch (t) { case "X": return Qb(r); case "XXXX": case "XX": return ha(r); default: return ha(r, ":") } }, x: function (e, t, i) { const r = e.getTimezoneOffset(); switch (t) { case "x": return Qb(r); case "xxxx": case "xx": return ha(r); default: return ha(r, ":") } }, O: function (e, t, i) { const r = e.getTimezoneOffset(); switch (t) { case "O": case "OO": case "OOO": return "GMT" + Kb(r, ":"); default: return "GMT" + ha(r, ":") } }, z: function (e, t, i) { const r = e.getTimezoneOffset(); switch (t) { case "z": case "zz": case "zzz": return "GMT" + Kb(r, ":"); default: return "GMT" + ha(r, ":") } }, t: function (e, t, i) { const r = Math.trunc(+e / 1e3); return ee(r, t.length) }, T: function (e, t, i) { return ee(+e, t.length) } }; function Kb(e, t = "") { const i = e > 0 ? "-" : "+", r = Math.abs(e), o = Math.trunc(r / 60), u = r % 60; return u === 0 ? i + String(o) : i + String(o) + t + ee(u, 2) } function Qb(e, t) { return e % 60 === 0 ? (e > 0 ? "-" : "+") + ee(Math.abs(e) / 60, 2) : ha(e, t) } function ha(e, t = "") { const i = e > 0 ? "-" : "+", r = Math.abs(e), o = ee(Math.trunc(r / 60), 2), u = ee(r % 60, 2); return i + o + t + u } const Xb = (e, t) => { switch (e) { case "P": return t.date({ width: "short" }); case "PP": return t.date({ width: "medium" }); case "PPP": return t.date({ width: "long" }); default: return t.date({ width: "full" }) } }, vA = (e, t) => { switch (e) { case "p": return t.time({ width: "short" }); case "pp": return t.time({ width: "medium" }); case "ppp": return t.time({ width: "long" }); default: return t.time({ width: "full" }) } }, N3 = (e, t) => { const i = e.match(/(P+)(p+)?/) || [], r = i[1], o = i[2]; if (!o) return Xb(e, t); let u; switch (r) { case "P": u = t.dateTime({ width: "short" }); break; case "PP": u = t.dateTime({ width: "medium" }); break; case "PPP": u = t.dateTime({ width: "long" }); break; default: u = t.dateTime({ width: "full" }); break }return u.replace("{{date}}", Xb(r, t)).replace("{{time}}", vA(o, t)) }, P3 = { p: vA, P: N3 }, k3 = /^D+$/, L3 = /^Y+$/, z3 = ["D", "DD", "YY", "YYYY"]; function j3(e) { return k3.test(e) } function U3(e) { return L3.test(e) } function B3(e, t, i) { const r = F3(e, t, i); if (console.warn(r), z3.includes(e)) throw new RangeError(r) } function F3(e, t, i) { const r = e[0] === "Y" ? "years" : "days of the month"; return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${i}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md` } const q3 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, H3 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, G3 = /^'([^]*?)'?$/, Y3 = /''/g, K3 = /[a-zA-Z]/; function lf(e, t, i) { const r = Vf(), o = r.locale ?? D3, u = r.firstWeekContainsDate ?? r.locale?.options?.firstWeekContainsDate ?? 1, c = r.weekStartsOn ?? r.locale?.options?.weekStartsOn ?? 0, d = rn(e, i?.in); if (!Y6(d)) throw new RangeError("Invalid time value"); let p = t.match(H3).map(v => { const b = v[0]; if (b === "p" || b === "P") { const E = P3[b]; return E(v, o.formatLong) } return v }).join("").match(q3).map(v => { if (v === "''") return { isToken: !1, value: "'" }; const b = v[0]; if (b === "'") return { isToken: !1, value: Q3(v) }; if (Yb[b]) return { isToken: !0, value: v }; if (b.match(K3)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + b + "`"); return { isToken: !1, value: v } }); o.localize.preprocessor && (p = o.localize.preprocessor(d, p)); const g = { firstWeekContainsDate: u, weekStartsOn: c, locale: o }; return p.map(v => { if (!v.isToken) return v.value; const b = v.value; (U3(b) || j3(b)) && B3(b, t, String(e)); const E = Yb[b[0]]; return E(d, b, o.localize, g) }).join("") } function Q3(e) { const t = e.match(G3); return t ? t[1].replace(Y3, "'") : e } function X3(e, t, i) { const r = +rn(e, i?.in), [o, u] = [+rn(t.start, i?.in), +rn(t.end, i?.in)].sort((c, d) => c - d); return r >= o && r <= u } const W3 = () => { }; var Wb = {}; const _A = function (e) { const t = []; let i = 0; for (let r = 0; r < e.length; r++) { let o = e.charCodeAt(r); o < 128 ? t[i++] = o : o < 2048 ? (t[i++] = o >> 6 | 192, t[i++] = o & 63 | 128) : (o & 64512) === 55296 && r + 1 < e.length && (e.charCodeAt(r + 1) & 64512) === 56320 ? (o = 65536 + ((o & 1023) << 10) + (e.charCodeAt(++r) & 1023), t[i++] = o >> 18 | 240, t[i++] = o >> 12 & 63 | 128, t[i++] = o >> 6 & 63 | 128, t[i++] = o & 63 | 128) : (t[i++] = o >> 12 | 224, t[i++] = o >> 6 & 63 | 128, t[i++] = o & 63 | 128) } return t }, $3 = function (e) { const t = []; let i = 0, r = 0; for (; i < e.length;) { const o = e[i++]; if (o < 128) t[r++] = String.fromCharCode(o); else if (o > 191 && o < 224) { const u = e[i++]; t[r++] = String.fromCharCode((o & 31) << 6 | u & 63) } else if (o > 239 && o < 365) { const u = e[i++], c = e[i++], d = e[i++], p = ((o & 7) << 18 | (u & 63) << 12 | (c & 63) << 6 | d & 63) - 65536; t[r++] = String.fromCharCode(55296 + (p >> 10)), t[r++] = String.fromCharCode(56320 + (p & 1023)) } else { const u = e[i++], c = e[i++]; t[r++] = String.fromCharCode((o & 15) << 12 | (u & 63) << 6 | c & 63) } } return t.join("") }, bA = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: typeof atob == "function", encodeByteArray(e, t) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const i = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = []; for (let o = 0; o < e.length; o += 3) { const u = e[o], c = o + 1 < e.length, d = c ? e[o + 1] : 0, p = o + 2 < e.length, g = p ? e[o + 2] : 0, v = u >> 2, b = (u & 3) << 4 | d >> 4; let E = (d & 15) << 2 | g >> 6, x = g & 63; p || (x = 64, c || (E = 64)), r.push(i[v], i[b], i[E], i[x]) } return r.join("") }, encodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(_A(e), t) }, decodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : $3(this.decodeStringToByteArray(e, t)) }, decodeStringToByteArray(e, t) { this.init_(); const i = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = []; for (let o = 0; o < e.length;) { const u = i[e.charAt(o++)], d = o < e.length ? i[e.charAt(o)] : 0; ++o; const g = o < e.length ? i[e.charAt(o)] : 64; ++o; const b = o < e.length ? i[e.charAt(o)] : 64; if (++o, u == null || d == null || g == null || b == null) throw new Z3; const E = u << 2 | d >> 4; if (r.push(E), g !== 64) { const x = d << 4 & 240 | g >> 2; if (r.push(x), b !== 64) { const M = g << 6 & 192 | b; r.push(M) } } } return r }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }; class Z3 extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } const J3 = function (e) { const t = _A(e); return bA.encodeByteArray(t, !0) }, uf = function (e) { return J3(e).replace(/\./g, "") }, tI = function (e) { try { return bA.decodeString(e, !0) } catch (t) { console.error("base64Decode failed: ", t) } return null }; function eI() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("Unable to locate global object.") } const nI = () => eI().__FIREBASE_DEFAULTS__, iI = () => { if (typeof process > "u" || typeof Wb > "u") return; const e = Wb.__FIREBASE_DEFAULTS__; if (e) return JSON.parse(e) }, sI = () => { if (typeof document > "u") return; let e; try { e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch { return } const t = e && tI(e[1]); return t && JSON.parse(t) }, iy = () => { try { return W3() || nI() || iI() || sI() } catch (e) { console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`); return } }, rI = e => iy()?.emulatorHosts?.[e], aI = e => { const t = rI(e); if (!t) return; const i = t.lastIndexOf(":"); if (i <= 0 || i + 1 === t.length) throw new Error(`Invalid host ${t} with no separate hostname and port!`); const r = parseInt(t.substring(i + 1), 10); return t[0] === "[" ? [t.substring(1, i - 1), r] : [t.substring(0, i), r] }, TA = () => iy()?.config; class oI { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((t, i) => { this.resolve = t, this.reject = i }) } wrapCallback(t) { return (i, r) => { i ? this.reject(i) : this.resolve(r), typeof t == "function" && (this.promise.catch(() => { }), t.length === 1 ? t(i) : t(i, r)) } } } function sy(e) { try { return (e.startsWith("http://") || e.startsWith("https://") ? new URL(e).hostname : e).endsWith(".cloudworkstations.dev") } catch { return !1 } } async function lI(e) { return (await fetch(e, { credentials: "include" })).ok } function uI(e, t) { if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const i = { alg: "none", type: "JWT" }, r = t || "demo-project", o = e.iat || 0, u = e.sub || e.user_id; if (!u) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const c = { iss: `https://securetoken.google.com/${r}`, aud: r, iat: o, exp: o + 3600, auth_time: o, sub: u, user_id: u, firebase: { sign_in_provider: "custom", identities: {} }, ...e }; return [uf(JSON.stringify(i)), uf(JSON.stringify(c)), ""].join(".") } const pu = {}; function cI() { const e = { prod: [], emulator: [] }; for (const t of Object.keys(pu)) pu[t] ? e.emulator.push(t) : e.prod.push(t); return e } function hI(e) { let t = document.getElementById(e), i = !1; return t || (t = document.createElement("div"), t.setAttribute("id", e), i = !0), { created: i, element: t } } let $b = !1; function fI(e, t) {
  if (typeof window > "u" || typeof document > "u" || !sy(window.location.host) || pu[e] === t || pu[e] || $b) return; pu[e] = t; function i(E) { return `__firebase__banner__${E}` } const r = "__firebase__banner", u = cI().prod.length > 0; function c() { const E = document.getElementById(r); E && E.remove() } function d(E) { E.style.display = "flex", E.style.background = "#7faaf0", E.style.position = "fixed", E.style.bottom = "5px", E.style.left = "5px", E.style.padding = ".5em", E.style.borderRadius = "5px", E.style.alignItems = "center" } function p(E, x) { E.setAttribute("width", "24"), E.setAttribute("id", x), E.setAttribute("height", "24"), E.setAttribute("viewBox", "0 0 24 24"), E.setAttribute("fill", "none"), E.style.marginLeft = "-6px" } function g() { const E = document.createElement("span"); return E.style.cursor = "pointer", E.style.marginLeft = "16px", E.style.fontSize = "24px", E.innerHTML = " &times;", E.onclick = () => { $b = !0, c() }, E } function v(E, x) { E.setAttribute("id", x), E.innerText = "Learn more", E.href = "https://firebase.google.com/docs/studio/preview-apps#preview-backend", E.setAttribute("target", "__blank"), E.style.paddingLeft = "5px", E.style.textDecoration = "underline" } function b() {
    const E = hI(r), x = i("text"), M = document.getElementById(x) || document.createElement("span"), j = i("learnmore"), z = document.getElementById(j) || document.createElement("a"), K = i("preprendIcon"), it = document.getElementById(K) || document.createElementNS("http://www.w3.org/2000/svg", "svg"); if (E.created) { const X = E.element; d(X), v(z, j); const at = g(); p(it, K), X.append(it, M, z, at), document.body.appendChild(X) } u ? (M.innerText = "Preview backend disconnected.", it.innerHTML = `<g clip-path="url(#clip0_6013_33858)">
<path d="M4.8 17.6L12 5.6L19.2 17.6H4.8ZM6.91667 16.4H17.0833L12 7.93333L6.91667 16.4ZM12 15.6C12.1667 15.6 12.3056 15.5444 12.4167 15.4333C12.5389 15.3111 12.6 15.1667 12.6 15C12.6 14.8333 12.5389 14.6944 12.4167 14.5833C12.3056 14.4611 12.1667 14.4 12 14.4C11.8333 14.4 11.6889 14.4611 11.5667 14.5833C11.4556 14.6944 11.4 14.8333 11.4 15C11.4 15.1667 11.4556 15.3111 11.5667 15.4333C11.6889 15.5444 11.8333 15.6 12 15.6ZM11.4 13.6H12.6V10.4H11.4V13.6Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6013_33858">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`) : (it.innerHTML = `<g clip-path="url(#clip0_6083_34804)">
<path d="M11.4 15.2H12.6V11.2H11.4V15.2ZM12 10C12.1667 10 12.3056 9.94444 12.4167 9.83333C12.5389 9.71111 12.6 9.56667 12.6 9.4C12.6 9.23333 12.5389 9.09444 12.4167 8.98333C12.3056 8.86111 12.1667 8.8 12 8.8C11.8333 8.8 11.6889 8.86111 11.5667 8.98333C11.4556 9.09444 11.4 9.23333 11.4 9.4C11.4 9.56667 11.4556 9.71111 11.5667 9.83333C11.6889 9.94444 11.8333 10 12 10ZM12 18.4C11.1222 18.4 10.2944 18.2333 9.51667 17.9C8.73889 17.5667 8.05556 17.1111 7.46667 16.5333C6.88889 15.9444 6.43333 15.2611 6.1 14.4833C5.76667 13.7056 5.6 12.8778 5.6 12C5.6 11.1111 5.76667 10.2833 6.1 9.51667C6.43333 8.73889 6.88889 8.06111 7.46667 7.48333C8.05556 6.89444 8.73889 6.43333 9.51667 6.1C10.2944 5.76667 11.1222 5.6 12 5.6C12.8889 5.6 13.7167 5.76667 14.4833 6.1C15.2611 6.43333 15.9389 6.89444 16.5167 7.48333C17.1056 8.06111 17.5667 8.73889 17.9 9.51667C18.2333 10.2833 18.4 11.1111 18.4 12C18.4 12.8778 18.2333 13.7056 17.9 14.4833C17.5667 15.2611 17.1056 15.9444 16.5167 16.5333C15.9389 17.1111 15.2611 17.5667 14.4833 17.9C13.7167 18.2333 12.8889 18.4 12 18.4ZM12 17.2C13.4444 17.2 14.6722 16.6944 15.6833 15.6833C16.6944 14.6722 17.2 13.4444 17.2 12C17.2 10.5556 16.6944 9.32778 15.6833 8.31667C14.6722 7.30555 13.4444 6.8 12 6.8C10.5556 6.8 9.32778 7.30555 8.31667 8.31667C7.30556 9.32778 6.8 10.5556 6.8 12C6.8 13.4444 7.30556 14.6722 8.31667 15.6833C9.32778 16.6944 10.5556 17.2 12 17.2Z" fill="#212121"/>
</g>
<defs>
<clipPath id="clip0_6083_34804">
<rect width="24" height="24" fill="white"/>
</clipPath>
</defs>`, M.innerText = "Preview backend running in this workspace."), M.setAttribute("id", x)
  } document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", b) : b()
} function dI() { return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : "" } function mI() { const e = iy()?.forceEnvironment; if (e === "node") return !0; if (e === "browser") return !1; try { return Object.prototype.toString.call(global.process) === "[object process]" } catch { return !1 } } function pI() { return !mI() && !!navigator.userAgent && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function gI() { try { return typeof indexedDB == "object" } catch { return !1 } } function yI() { return new Promise((e, t) => { try { let i = !0; const r = "validate-browser-context-for-indexeddb-analytics-module", o = self.indexedDB.open(r); o.onsuccess = () => { o.result.close(), i || self.indexedDB.deleteDatabase(r), e(!0) }, o.onupgradeneeded = () => { i = !1 }, o.onerror = () => { t(o.error?.message || "") } } catch (i) { t(i) } }) } const vI = "FirebaseError"; class qo extends Error { constructor(t, i, r) { super(i), this.code = t, this.customData = r, this.name = vI, Object.setPrototypeOf(this, qo.prototype), Error.captureStackTrace && Error.captureStackTrace(this, EA.prototype.create) } } class EA { constructor(t, i, r) { this.service = t, this.serviceName = i, this.errors = r } create(t, ...i) { const r = i[0] || {}, o = `${this.service}/${t}`, u = this.errors[t], c = u ? _I(u, r) : "Error", d = `${this.serviceName}: ${c} (${o}).`; return new qo(o, d, r) } } function _I(e, t) { return e.replace(bI, (i, r) => { const o = t[r]; return o != null ? String(o) : `<${r}?>` }) } const bI = /\{\$([^}]+)}/g; function cf(e, t) { if (e === t) return !0; const i = Object.keys(e), r = Object.keys(t); for (const o of i) { if (!r.includes(o)) return !1; const u = e[o], c = t[o]; if (Zb(u) && Zb(c)) { if (!cf(u, c)) return !1 } else if (u !== c) return !1 } for (const o of r) if (!i.includes(o)) return !1; return !0 } function Zb(e) { return e !== null && typeof e == "object" } function Wi(e) { return e && e._delegate ? e._delegate : e } class xu { constructor(t, i, r) { this.name = t, this.instanceFactory = i, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(t) { return this.instantiationMode = t, this } setMultipleInstances(t) { return this.multipleInstances = t, this } setServiceProps(t) { return this.serviceProps = t, this } setInstanceCreatedCallback(t) { return this.onInstanceCreated = t, this } } const fa = "[DEFAULT]"; class TI { constructor(t, i) { this.name = t, this.container = i, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(t) { const i = this.normalizeInstanceIdentifier(t); if (!this.instancesDeferred.has(i)) { const r = new oI; if (this.instancesDeferred.set(i, r), this.isInitialized(i) || this.shouldAutoInitialize()) try { const o = this.getOrInitializeService({ instanceIdentifier: i }); o && r.resolve(o) } catch { } } return this.instancesDeferred.get(i).promise } getImmediate(t) { const i = this.normalizeInstanceIdentifier(t?.identifier), r = t?.optional ?? !1; if (this.isInitialized(i) || this.shouldAutoInitialize()) try { return this.getOrInitializeService({ instanceIdentifier: i }) } catch (o) { if (r) return null; throw o } else { if (r) return null; throw Error(`Service ${this.name} is not available`) } } getComponent() { return this.component } setComponent(t) { if (t.name !== this.name) throw Error(`Mismatching Component ${t.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = t, !!this.shouldAutoInitialize()) { if (SI(t)) try { this.getOrInitializeService({ instanceIdentifier: fa }) } catch { } for (const [i, r] of this.instancesDeferred.entries()) { const o = this.normalizeInstanceIdentifier(i); try { const u = this.getOrInitializeService({ instanceIdentifier: o }); r.resolve(u) } catch { } } } } clearInstance(t = fa) { this.instancesDeferred.delete(t), this.instancesOptions.delete(t), this.instances.delete(t) } async delete() { const t = Array.from(this.instances.values()); await Promise.all([...t.filter(i => "INTERNAL" in i).map(i => i.INTERNAL.delete()), ...t.filter(i => "_delete" in i).map(i => i._delete())]) } isComponentSet() { return this.component != null } isInitialized(t = fa) { return this.instances.has(t) } getOptions(t = fa) { return this.instancesOptions.get(t) || {} } initialize(t = {}) { const { options: i = {} } = t, r = this.normalizeInstanceIdentifier(t.instanceIdentifier); if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const o = this.getOrInitializeService({ instanceIdentifier: r, options: i }); for (const [u, c] of this.instancesDeferred.entries()) { const d = this.normalizeInstanceIdentifier(u); r === d && c.resolve(o) } return o } onInit(t, i) { const r = this.normalizeInstanceIdentifier(i), o = this.onInitCallbacks.get(r) ?? new Set; o.add(t), this.onInitCallbacks.set(r, o); const u = this.instances.get(r); return u && t(u, r), () => { o.delete(t) } } invokeOnInitCallbacks(t, i) { const r = this.onInitCallbacks.get(i); if (r) for (const o of r) try { o(t, i) } catch { } } getOrInitializeService({ instanceIdentifier: t, options: i = {} }) { let r = this.instances.get(t); if (!r && this.component && (r = this.component.instanceFactory(this.container, { instanceIdentifier: EI(t), options: i }), this.instances.set(t, r), this.instancesOptions.set(t, i), this.invokeOnInitCallbacks(r, t), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, t, r) } catch { } return r || null } normalizeInstanceIdentifier(t = fa) { return this.component ? this.component.multipleInstances ? t : fa : t } shouldAutoInitialize() { return !!this.component && this.component.instantiationMode !== "EXPLICIT" } } function EI(e) { return e === fa ? void 0 : e } function SI(e) { return e.instantiationMode === "EAGER" } class AI { constructor(t) { this.name = t, this.providers = new Map } addComponent(t) { const i = this.getProvider(t.name); if (i.isComponentSet()) throw new Error(`Component ${t.name} has already been registered with ${this.name}`); i.setComponent(t) } addOrOverwriteComponent(t) { this.getProvider(t.name).isComponentSet() && this.providers.delete(t.name), this.addComponent(t) } getProvider(t) { if (this.providers.has(t)) return this.providers.get(t); const i = new TI(t, this); return this.providers.set(t, i), i } getProviders() { return Array.from(this.providers.values()) } } var qt; (function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" })(qt || (qt = {})); const wI = { debug: qt.DEBUG, verbose: qt.VERBOSE, info: qt.INFO, warn: qt.WARN, error: qt.ERROR, silent: qt.SILENT }, xI = qt.INFO, CI = { [qt.DEBUG]: "log", [qt.VERBOSE]: "log", [qt.INFO]: "info", [qt.WARN]: "warn", [qt.ERROR]: "error" }, RI = (e, t, ...i) => { if (t < e.logLevel) return; const r = new Date().toISOString(), o = CI[t]; if (o) console[o](`[${r}]  ${e.name}:`, ...i); else throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`) }; class SA { constructor(t) { this.name = t, this._logLevel = xI, this._logHandler = RI, this._userLogHandler = null } get logLevel() { return this._logLevel } set logLevel(t) { if (!(t in qt)) throw new TypeError(`Invalid value "${t}" assigned to \`logLevel\``); this._logLevel = t } setLogLevel(t) { this._logLevel = typeof t == "string" ? wI[t] : t } get logHandler() { return this._logHandler } set logHandler(t) { if (typeof t != "function") throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = t } get userLogHandler() { return this._userLogHandler } set userLogHandler(t) { this._userLogHandler = t } debug(...t) { this._userLogHandler && this._userLogHandler(this, qt.DEBUG, ...t), this._logHandler(this, qt.DEBUG, ...t) } log(...t) { this._userLogHandler && this._userLogHandler(this, qt.VERBOSE, ...t), this._logHandler(this, qt.VERBOSE, ...t) } info(...t) { this._userLogHandler && this._userLogHandler(this, qt.INFO, ...t), this._logHandler(this, qt.INFO, ...t) } warn(...t) { this._userLogHandler && this._userLogHandler(this, qt.WARN, ...t), this._logHandler(this, qt.WARN, ...t) } error(...t) { this._userLogHandler && this._userLogHandler(this, qt.ERROR, ...t), this._logHandler(this, qt.ERROR, ...t) } } const DI = (e, t) => t.some(i => e instanceof i); let Jb, tT; function VI() { return Jb || (Jb = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) } function MI() { return tT || (tT = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) } const AA = new WeakMap, Zp = new WeakMap, wA = new WeakMap, yp = new WeakMap, ry = new WeakMap; function II(e) { const t = new Promise((i, r) => { const o = () => { e.removeEventListener("success", u), e.removeEventListener("error", c) }, u = () => { i(mr(e.result)), o() }, c = () => { r(e.error), o() }; e.addEventListener("success", u), e.addEventListener("error", c) }); return t.then(i => { i instanceof IDBCursor && AA.set(i, e) }).catch(() => { }), ry.set(t, e), t } function OI(e) { if (Zp.has(e)) return; const t = new Promise((i, r) => { const o = () => { e.removeEventListener("complete", u), e.removeEventListener("error", c), e.removeEventListener("abort", c) }, u = () => { i(), o() }, c = () => { r(e.error || new DOMException("AbortError", "AbortError")), o() }; e.addEventListener("complete", u), e.addEventListener("error", c), e.addEventListener("abort", c) }); Zp.set(e, t) } let Jp = { get(e, t, i) { if (e instanceof IDBTransaction) { if (t === "done") return Zp.get(e); if (t === "objectStoreNames") return e.objectStoreNames || wA.get(e); if (t === "store") return i.objectStoreNames[1] ? void 0 : i.objectStore(i.objectStoreNames[0]) } return mr(e[t]) }, set(e, t, i) { return e[t] = i, !0 }, has(e, t) { return e instanceof IDBTransaction && (t === "done" || t === "store") ? !0 : t in e } }; function NI(e) { Jp = e(Jp) } function PI(e) { return e === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function (t, ...i) { const r = e.call(vp(this), t, ...i); return wA.set(r, t.sort ? t.sort() : [t]), mr(r) } : MI().includes(e) ? function (...t) { return e.apply(vp(this), t), mr(AA.get(this)) } : function (...t) { return mr(e.apply(vp(this), t)) } } function kI(e) { return typeof e == "function" ? PI(e) : (e instanceof IDBTransaction && OI(e), DI(e, VI()) ? new Proxy(e, Jp) : e) } function mr(e) { if (e instanceof IDBRequest) return II(e); if (yp.has(e)) return yp.get(e); const t = kI(e); return t !== e && (yp.set(e, t), ry.set(t, e)), t } const vp = e => ry.get(e); function LI(e, t, { blocked: i, upgrade: r, blocking: o, terminated: u } = {}) { const c = indexedDB.open(e, t), d = mr(c); return r && c.addEventListener("upgradeneeded", p => { r(mr(c.result), p.oldVersion, p.newVersion, mr(c.transaction), p) }), i && c.addEventListener("blocked", p => i(p.oldVersion, p.newVersion, p)), d.then(p => { u && p.addEventListener("close", () => u()), o && p.addEventListener("versionchange", g => o(g.oldVersion, g.newVersion, g)) }).catch(() => { }), d } const zI = ["get", "getKey", "getAll", "getAllKeys", "count"], jI = ["put", "add", "delete", "clear"], _p = new Map; function eT(e, t) { if (!(e instanceof IDBDatabase && !(t in e) && typeof t == "string")) return; if (_p.get(t)) return _p.get(t); const i = t.replace(/FromIndex$/, ""), r = t !== i, o = jI.includes(i); if (!(i in (r ? IDBIndex : IDBObjectStore).prototype) || !(o || zI.includes(i))) return; const u = async function (c, ...d) { const p = this.transaction(c, o ? "readwrite" : "readonly"); let g = p.store; return r && (g = g.index(d.shift())), (await Promise.all([g[i](...d), o && p.done]))[0] }; return _p.set(t, u), u } NI(e => ({ ...e, get: (t, i, r) => eT(t, i) || e.get(t, i, r), has: (t, i) => !!eT(t, i) || e.has(t, i) })); class UI { constructor(t) { this.container = t } getPlatformInfoString() { return this.container.getProviders().map(i => { if (BI(i)) { const r = i.getImmediate(); return `${r.library}/${r.version}` } else return null }).filter(i => i).join(" ") } } function BI(e) { return e.getComponent()?.type === "VERSION" } const tg = "@firebase/app", nT = "0.14.8"; const As = new SA("@firebase/app"), FI = "@firebase/app-compat", qI = "@firebase/analytics-compat", HI = "@firebase/analytics", GI = "@firebase/app-check-compat", YI = "@firebase/app-check", KI = "@firebase/auth", QI = "@firebase/auth-compat", XI = "@firebase/database", WI = "@firebase/data-connect", $I = "@firebase/database-compat", ZI = "@firebase/functions", JI = "@firebase/functions-compat", tO = "@firebase/installations", eO = "@firebase/installations-compat", nO = "@firebase/messaging", iO = "@firebase/messaging-compat", sO = "@firebase/performance", rO = "@firebase/performance-compat", aO = "@firebase/remote-config", oO = "@firebase/remote-config-compat", lO = "@firebase/storage", uO = "@firebase/storage-compat", cO = "@firebase/firestore", hO = "@firebase/ai", fO = "@firebase/firestore-compat", dO = "firebase", mO = "12.9.0"; const eg = "[DEFAULT]", pO = { [tg]: "fire-core", [FI]: "fire-core-compat", [HI]: "fire-analytics", [qI]: "fire-analytics-compat", [YI]: "fire-app-check", [GI]: "fire-app-check-compat", [KI]: "fire-auth", [QI]: "fire-auth-compat", [XI]: "fire-rtdb", [WI]: "fire-data-connect", [$I]: "fire-rtdb-compat", [ZI]: "fire-fn", [JI]: "fire-fn-compat", [tO]: "fire-iid", [eO]: "fire-iid-compat", [nO]: "fire-fcm", [iO]: "fire-fcm-compat", [sO]: "fire-perf", [rO]: "fire-perf-compat", [aO]: "fire-rc", [oO]: "fire-rc-compat", [lO]: "fire-gcs", [uO]: "fire-gcs-compat", [cO]: "fire-fst", [fO]: "fire-fst-compat", [hO]: "fire-vertex", "fire-js": "fire-js", [dO]: "fire-js-all" }; const hf = new Map, gO = new Map, ng = new Map; function iT(e, t) { try { e.container.addComponent(t) } catch (i) { As.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, i) } } function ff(e) { const t = e.name; if (ng.has(t)) return As.debug(`There were multiple attempts to register component ${t}.`), !1; ng.set(t, e); for (const i of hf.values()) iT(i, e); for (const i of gO.values()) iT(i, e); return !0 } function yO(e, t) { const i = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return i && i.triggerHeartbeat(), e.container.getProvider(t) } function vO(e) { return e == null ? !1 : e.settings !== void 0 } const _O = { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}'", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "server-app-deleted": "Firebase Server App has been deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.", "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.", "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments." }, pr = new EA("app", "Firebase", _O); class bO { constructor(t, i, r) { this._isDeleted = !1, this._options = { ...t }, this._config = { ...i }, this._name = i.name, this._automaticDataCollectionEnabled = i.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new xu("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(t) { this.checkDestroyed(), this._automaticDataCollectionEnabled = t } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(t) { this._isDeleted = t } checkDestroyed() { if (this.isDeleted) throw pr.create("app-deleted", { appName: this._name }) } } const TO = mO; function xA(e, t = {}) { let i = e; typeof t != "object" && (t = { name: t }); const r = { name: eg, automaticDataCollectionEnabled: !0, ...t }, o = r.name; if (typeof o != "string" || !o) throw pr.create("bad-app-name", { appName: String(o) }); if (i || (i = TA()), !i) throw pr.create("no-options"); const u = hf.get(o); if (u) { if (cf(i, u.options) && cf(r, u.config)) return u; throw pr.create("duplicate-app", { appName: o }) } const c = new AI(o); for (const p of ng.values()) c.addComponent(p); const d = new bO(i, r, c); return hf.set(o, d), d } function EO(e = eg) { const t = hf.get(e); if (!t && e === eg && TA()) return xA(); if (!t) throw pr.create("no-app", { appName: e }); return t } function xo(e, t, i) { let r = pO[e] ?? e; i && (r += `-${i}`); const o = r.match(/\s|\//), u = t.match(/\s|\//); if (o || u) { const c = [`Unable to register library "${r}" with version "${t}":`]; o && c.push(`library name "${r}" contains illegal characters (whitespace or "/")`), o && u && c.push("and"), u && c.push(`version name "${t}" contains illegal characters (whitespace or "/")`), As.warn(c.join(" ")); return } ff(new xu(`${r}-version`, () => ({ library: r, version: t }), "VERSION")) } const SO = "firebase-heartbeat-database", AO = 1, Cu = "firebase-heartbeat-store"; let bp = null; function CA() { return bp || (bp = LI(SO, AO, { upgrade: (e, t) => { switch (t) { case 0: try { e.createObjectStore(Cu) } catch (i) { console.warn(i) } } } }).catch(e => { throw pr.create("idb-open", { originalErrorMessage: e.message }) })), bp } async function wO(e) { try { const i = (await CA()).transaction(Cu), r = await i.objectStore(Cu).get(RA(e)); return await i.done, r } catch (t) { if (t instanceof qo) As.warn(t.message); else { const i = pr.create("idb-get", { originalErrorMessage: t?.message }); As.warn(i.message) } } } async function sT(e, t) { try { const r = (await CA()).transaction(Cu, "readwrite"); await r.objectStore(Cu).put(t, RA(e)), await r.done } catch (i) { if (i instanceof qo) As.warn(i.message); else { const r = pr.create("idb-set", { originalErrorMessage: i?.message }); As.warn(r.message) } } } function RA(e) { return `${e.name}!${e.options.appId}` } const xO = 1024, CO = 30; class RO { constructor(t) { this.container = t, this._heartbeatsCache = null; const i = this.container.getProvider("app").getImmediate(); this._storage = new VO(i), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r)) } async triggerHeartbeat() { try { const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), r = rT(); if (this._heartbeatsCache?.heartbeats == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, this._heartbeatsCache?.heartbeats == null) || this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some(o => o.date === r)) return; if (this._heartbeatsCache.heartbeats.push({ date: r, agent: i }), this._heartbeatsCache.heartbeats.length > CO) { const o = MO(this._heartbeatsCache.heartbeats); this._heartbeatsCache.heartbeats.splice(o, 1) } return this._storage.overwrite(this._heartbeatsCache) } catch (t) { As.warn(t) } } async getHeartbeatsHeader() { try { if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache?.heartbeats == null || this._heartbeatsCache.heartbeats.length === 0) return ""; const t = rT(), { heartbeatsToSend: i, unsentEntries: r } = DO(this._heartbeatsCache.heartbeats), o = uf(JSON.stringify({ version: 2, heartbeats: i })); return this._heartbeatsCache.lastSentHeartbeatDate = t, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), o } catch (t) { return As.warn(t), "" } } } function rT() { return new Date().toISOString().substring(0, 10) } function DO(e, t = xO) { const i = []; let r = e.slice(); for (const o of e) { const u = i.find(c => c.agent === o.agent); if (u) { if (u.dates.push(o.date), aT(i) > t) { u.dates.pop(); break } } else if (i.push({ agent: o.agent, dates: [o.date] }), aT(i) > t) { i.pop(); break } r = r.slice(1) } return { heartbeatsToSend: i, unsentEntries: r } } class VO { constructor(t) { this.app = t, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return gI() ? yI().then(() => !0).catch(() => !1) : !1 } async read() { if (await this._canUseIndexedDBPromise) { const i = await wO(this.app); return i?.heartbeats ? i : { heartbeats: [] } } else return { heartbeats: [] } } async overwrite(t) { if (await this._canUseIndexedDBPromise) { const r = await this.read(); return sT(this.app, { lastSentHeartbeatDate: t.lastSentHeartbeatDate ?? r.lastSentHeartbeatDate, heartbeats: t.heartbeats }) } else return } async add(t) { if (await this._canUseIndexedDBPromise) { const r = await this.read(); return sT(this.app, { lastSentHeartbeatDate: t.lastSentHeartbeatDate ?? r.lastSentHeartbeatDate, heartbeats: [...r.heartbeats, ...t.heartbeats] }) } else return } } function aT(e) { return uf(JSON.stringify({ version: 2, heartbeats: e })).length } function MO(e) { if (e.length === 0) return -1; let t = 0, i = e[0].date; for (let r = 1; r < e.length; r++)e[r].date < i && (i = e[r].date, t = r); return t } function IO(e) { ff(new xu("platform-logger", t => new UI(t), "PRIVATE")), ff(new xu("heartbeat", t => new RO(t), "PRIVATE")), xo(tg, nT, e), xo(tg, nT, "esm2020"), xo("fire-js", "") } IO(""); var OO = "firebase", NO = "12.9.0"; xo(OO, NO, "app"); var oT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; var gr, DA; (function () { var e; function t(R, A) { function C() { } C.prototype = A.prototype, R.F = A.prototype, R.prototype = new C, R.prototype.constructor = R, R.D = function (O, I, k) { for (var D = Array(arguments.length - 2), Yt = 2; Yt < arguments.length; Yt++)D[Yt - 2] = arguments[Yt]; return A.prototype[I].apply(O, D) } } function i() { this.blockSize = -1 } function r() { this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.C = Array(this.blockSize), this.o = this.h = 0, this.u() } t(r, i), r.prototype.u = function () { this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.o = this.h = 0 }; function o(R, A, C) { C || (C = 0); const O = Array(16); if (typeof A == "string") for (var I = 0; I < 16; ++I)O[I] = A.charCodeAt(C++) | A.charCodeAt(C++) << 8 | A.charCodeAt(C++) << 16 | A.charCodeAt(C++) << 24; else for (I = 0; I < 16; ++I)O[I] = A[C++] | A[C++] << 8 | A[C++] << 16 | A[C++] << 24; A = R.g[0], C = R.g[1], I = R.g[2]; let k = R.g[3], D; D = A + (k ^ C & (I ^ k)) + O[0] + 3614090360 & 4294967295, A = C + (D << 7 & 4294967295 | D >>> 25), D = k + (I ^ A & (C ^ I)) + O[1] + 3905402710 & 4294967295, k = A + (D << 12 & 4294967295 | D >>> 20), D = I + (C ^ k & (A ^ C)) + O[2] + 606105819 & 4294967295, I = k + (D << 17 & 4294967295 | D >>> 15), D = C + (A ^ I & (k ^ A)) + O[3] + 3250441966 & 4294967295, C = I + (D << 22 & 4294967295 | D >>> 10), D = A + (k ^ C & (I ^ k)) + O[4] + 4118548399 & 4294967295, A = C + (D << 7 & 4294967295 | D >>> 25), D = k + (I ^ A & (C ^ I)) + O[5] + 1200080426 & 4294967295, k = A + (D << 12 & 4294967295 | D >>> 20), D = I + (C ^ k & (A ^ C)) + O[6] + 2821735955 & 4294967295, I = k + (D << 17 & 4294967295 | D >>> 15), D = C + (A ^ I & (k ^ A)) + O[7] + 4249261313 & 4294967295, C = I + (D << 22 & 4294967295 | D >>> 10), D = A + (k ^ C & (I ^ k)) + O[8] + 1770035416 & 4294967295, A = C + (D << 7 & 4294967295 | D >>> 25), D = k + (I ^ A & (C ^ I)) + O[9] + 2336552879 & 4294967295, k = A + (D << 12 & 4294967295 | D >>> 20), D = I + (C ^ k & (A ^ C)) + O[10] + 4294925233 & 4294967295, I = k + (D << 17 & 4294967295 | D >>> 15), D = C + (A ^ I & (k ^ A)) + O[11] + 2304563134 & 4294967295, C = I + (D << 22 & 4294967295 | D >>> 10), D = A + (k ^ C & (I ^ k)) + O[12] + 1804603682 & 4294967295, A = C + (D << 7 & 4294967295 | D >>> 25), D = k + (I ^ A & (C ^ I)) + O[13] + 4254626195 & 4294967295, k = A + (D << 12 & 4294967295 | D >>> 20), D = I + (C ^ k & (A ^ C)) + O[14] + 2792965006 & 4294967295, I = k + (D << 17 & 4294967295 | D >>> 15), D = C + (A ^ I & (k ^ A)) + O[15] + 1236535329 & 4294967295, C = I + (D << 22 & 4294967295 | D >>> 10), D = A + (I ^ k & (C ^ I)) + O[1] + 4129170786 & 4294967295, A = C + (D << 5 & 4294967295 | D >>> 27), D = k + (C ^ I & (A ^ C)) + O[6] + 3225465664 & 4294967295, k = A + (D << 9 & 4294967295 | D >>> 23), D = I + (A ^ C & (k ^ A)) + O[11] + 643717713 & 4294967295, I = k + (D << 14 & 4294967295 | D >>> 18), D = C + (k ^ A & (I ^ k)) + O[0] + 3921069994 & 4294967295, C = I + (D << 20 & 4294967295 | D >>> 12), D = A + (I ^ k & (C ^ I)) + O[5] + 3593408605 & 4294967295, A = C + (D << 5 & 4294967295 | D >>> 27), D = k + (C ^ I & (A ^ C)) + O[10] + 38016083 & 4294967295, k = A + (D << 9 & 4294967295 | D >>> 23), D = I + (A ^ C & (k ^ A)) + O[15] + 3634488961 & 4294967295, I = k + (D << 14 & 4294967295 | D >>> 18), D = C + (k ^ A & (I ^ k)) + O[4] + 3889429448 & 4294967295, C = I + (D << 20 & 4294967295 | D >>> 12), D = A + (I ^ k & (C ^ I)) + O[9] + 568446438 & 4294967295, A = C + (D << 5 & 4294967295 | D >>> 27), D = k + (C ^ I & (A ^ C)) + O[14] + 3275163606 & 4294967295, k = A + (D << 9 & 4294967295 | D >>> 23), D = I + (A ^ C & (k ^ A)) + O[3] + 4107603335 & 4294967295, I = k + (D << 14 & 4294967295 | D >>> 18), D = C + (k ^ A & (I ^ k)) + O[8] + 1163531501 & 4294967295, C = I + (D << 20 & 4294967295 | D >>> 12), D = A + (I ^ k & (C ^ I)) + O[13] + 2850285829 & 4294967295, A = C + (D << 5 & 4294967295 | D >>> 27), D = k + (C ^ I & (A ^ C)) + O[2] + 4243563512 & 4294967295, k = A + (D << 9 & 4294967295 | D >>> 23), D = I + (A ^ C & (k ^ A)) + O[7] + 1735328473 & 4294967295, I = k + (D << 14 & 4294967295 | D >>> 18), D = C + (k ^ A & (I ^ k)) + O[12] + 2368359562 & 4294967295, C = I + (D << 20 & 4294967295 | D >>> 12), D = A + (C ^ I ^ k) + O[5] + 4294588738 & 4294967295, A = C + (D << 4 & 4294967295 | D >>> 28), D = k + (A ^ C ^ I) + O[8] + 2272392833 & 4294967295, k = A + (D << 11 & 4294967295 | D >>> 21), D = I + (k ^ A ^ C) + O[11] + 1839030562 & 4294967295, I = k + (D << 16 & 4294967295 | D >>> 16), D = C + (I ^ k ^ A) + O[14] + 4259657740 & 4294967295, C = I + (D << 23 & 4294967295 | D >>> 9), D = A + (C ^ I ^ k) + O[1] + 2763975236 & 4294967295, A = C + (D << 4 & 4294967295 | D >>> 28), D = k + (A ^ C ^ I) + O[4] + 1272893353 & 4294967295, k = A + (D << 11 & 4294967295 | D >>> 21), D = I + (k ^ A ^ C) + O[7] + 4139469664 & 4294967295, I = k + (D << 16 & 4294967295 | D >>> 16), D = C + (I ^ k ^ A) + O[10] + 3200236656 & 4294967295, C = I + (D << 23 & 4294967295 | D >>> 9), D = A + (C ^ I ^ k) + O[13] + 681279174 & 4294967295, A = C + (D << 4 & 4294967295 | D >>> 28), D = k + (A ^ C ^ I) + O[0] + 3936430074 & 4294967295, k = A + (D << 11 & 4294967295 | D >>> 21), D = I + (k ^ A ^ C) + O[3] + 3572445317 & 4294967295, I = k + (D << 16 & 4294967295 | D >>> 16), D = C + (I ^ k ^ A) + O[6] + 76029189 & 4294967295, C = I + (D << 23 & 4294967295 | D >>> 9), D = A + (C ^ I ^ k) + O[9] + 3654602809 & 4294967295, A = C + (D << 4 & 4294967295 | D >>> 28), D = k + (A ^ C ^ I) + O[12] + 3873151461 & 4294967295, k = A + (D << 11 & 4294967295 | D >>> 21), D = I + (k ^ A ^ C) + O[15] + 530742520 & 4294967295, I = k + (D << 16 & 4294967295 | D >>> 16), D = C + (I ^ k ^ A) + O[2] + 3299628645 & 4294967295, C = I + (D << 23 & 4294967295 | D >>> 9), D = A + (I ^ (C | ~k)) + O[0] + 4096336452 & 4294967295, A = C + (D << 6 & 4294967295 | D >>> 26), D = k + (C ^ (A | ~I)) + O[7] + 1126891415 & 4294967295, k = A + (D << 10 & 4294967295 | D >>> 22), D = I + (A ^ (k | ~C)) + O[14] + 2878612391 & 4294967295, I = k + (D << 15 & 4294967295 | D >>> 17), D = C + (k ^ (I | ~A)) + O[5] + 4237533241 & 4294967295, C = I + (D << 21 & 4294967295 | D >>> 11), D = A + (I ^ (C | ~k)) + O[12] + 1700485571 & 4294967295, A = C + (D << 6 & 4294967295 | D >>> 26), D = k + (C ^ (A | ~I)) + O[3] + 2399980690 & 4294967295, k = A + (D << 10 & 4294967295 | D >>> 22), D = I + (A ^ (k | ~C)) + O[10] + 4293915773 & 4294967295, I = k + (D << 15 & 4294967295 | D >>> 17), D = C + (k ^ (I | ~A)) + O[1] + 2240044497 & 4294967295, C = I + (D << 21 & 4294967295 | D >>> 11), D = A + (I ^ (C | ~k)) + O[8] + 1873313359 & 4294967295, A = C + (D << 6 & 4294967295 | D >>> 26), D = k + (C ^ (A | ~I)) + O[15] + 4264355552 & 4294967295, k = A + (D << 10 & 4294967295 | D >>> 22), D = I + (A ^ (k | ~C)) + O[6] + 2734768916 & 4294967295, I = k + (D << 15 & 4294967295 | D >>> 17), D = C + (k ^ (I | ~A)) + O[13] + 1309151649 & 4294967295, C = I + (D << 21 & 4294967295 | D >>> 11), D = A + (I ^ (C | ~k)) + O[4] + 4149444226 & 4294967295, A = C + (D << 6 & 4294967295 | D >>> 26), D = k + (C ^ (A | ~I)) + O[11] + 3174756917 & 4294967295, k = A + (D << 10 & 4294967295 | D >>> 22), D = I + (A ^ (k | ~C)) + O[2] + 718787259 & 4294967295, I = k + (D << 15 & 4294967295 | D >>> 17), D = C + (k ^ (I | ~A)) + O[9] + 3951481745 & 4294967295, R.g[0] = R.g[0] + A & 4294967295, R.g[1] = R.g[1] + (I + (D << 21 & 4294967295 | D >>> 11)) & 4294967295, R.g[2] = R.g[2] + I & 4294967295, R.g[3] = R.g[3] + k & 4294967295 } r.prototype.v = function (R, A) { A === void 0 && (A = R.length); const C = A - this.blockSize, O = this.C; let I = this.h, k = 0; for (; k < A;) { if (I == 0) for (; k <= C;)o(this, R, k), k += this.blockSize; if (typeof R == "string") { for (; k < A;)if (O[I++] = R.charCodeAt(k++), I == this.blockSize) { o(this, O), I = 0; break } } else for (; k < A;)if (O[I++] = R[k++], I == this.blockSize) { o(this, O), I = 0; break } } this.h = I, this.o += A }, r.prototype.A = function () { var R = Array((this.h < 56 ? this.blockSize : this.blockSize * 2) - this.h); R[0] = 128; for (var A = 1; A < R.length - 8; ++A)R[A] = 0; A = this.o * 8; for (var C = R.length - 8; C < R.length; ++C)R[C] = A & 255, A /= 256; for (this.v(R), R = Array(16), A = 0, C = 0; C < 4; ++C)for (let O = 0; O < 32; O += 8)R[A++] = this.g[C] >>> O & 255; return R }; function u(R, A) { var C = d; return Object.prototype.hasOwnProperty.call(C, R) ? C[R] : C[R] = A(R) } function c(R, A) { this.h = A; const C = []; let O = !0; for (let I = R.length - 1; I >= 0; I--) { const k = R[I] | 0; O && k == A || (C[I] = k, O = !1) } this.g = C } var d = {}; function p(R) { return -128 <= R && R < 128 ? u(R, function (A) { return new c([A | 0], A < 0 ? -1 : 0) }) : new c([R | 0], R < 0 ? -1 : 0) } function g(R) { if (isNaN(R) || !isFinite(R)) return b; if (R < 0) return z(g(-R)); const A = []; let C = 1; for (let O = 0; R >= C; O++)A[O] = R / C | 0, C *= 4294967296; return new c(A, 0) } function v(R, A) { if (R.length == 0) throw Error("number format error: empty string"); if (A = A || 10, A < 2 || 36 < A) throw Error("radix out of range: " + A); if (R.charAt(0) == "-") return z(v(R.substring(1), A)); if (R.indexOf("-") >= 0) throw Error('number format error: interior "-" character'); const C = g(Math.pow(A, 8)); let O = b; for (let k = 0; k < R.length; k += 8) { var I = Math.min(8, R.length - k); const D = parseInt(R.substring(k, k + I), A); I < 8 ? (I = g(Math.pow(A, I)), O = O.j(I).add(g(D))) : (O = O.j(C), O = O.add(g(D))) } return O } var b = p(0), E = p(1), x = p(16777216); e = c.prototype, e.m = function () { if (j(this)) return -z(this).m(); let R = 0, A = 1; for (let C = 0; C < this.g.length; C++) { const O = this.i(C); R += (O >= 0 ? O : 4294967296 + O) * A, A *= 4294967296 } return R }, e.toString = function (R) { if (R = R || 10, R < 2 || 36 < R) throw Error("radix out of range: " + R); if (M(this)) return "0"; if (j(this)) return "-" + z(this).toString(R); const A = g(Math.pow(R, 6)); var C = this; let O = ""; for (; ;) { const I = at(C, A).g; C = K(C, I.j(A)); let k = ((C.g.length > 0 ? C.g[0] : C.h) >>> 0).toString(R); if (C = I, M(C)) return k + O; for (; k.length < 6;)k = "0" + k; O = k + O } }, e.i = function (R) { return R < 0 ? 0 : R < this.g.length ? this.g[R] : this.h }; function M(R) { if (R.h != 0) return !1; for (let A = 0; A < R.g.length; A++)if (R.g[A] != 0) return !1; return !0 } function j(R) { return R.h == -1 } e.l = function (R) { return R = K(this, R), j(R) ? -1 : M(R) ? 0 : 1 }; function z(R) { const A = R.g.length, C = []; for (let O = 0; O < A; O++)C[O] = ~R.g[O]; return new c(C, ~R.h).add(E) } e.abs = function () { return j(this) ? z(this) : this }, e.add = function (R) { const A = Math.max(this.g.length, R.g.length), C = []; let O = 0; for (let I = 0; I <= A; I++) { let k = O + (this.i(I) & 65535) + (R.i(I) & 65535), D = (k >>> 16) + (this.i(I) >>> 16) + (R.i(I) >>> 16); O = D >>> 16, k &= 65535, D &= 65535, C[I] = D << 16 | k } return new c(C, C[C.length - 1] & -2147483648 ? -1 : 0) }; function K(R, A) { return R.add(z(A)) } e.j = function (R) { if (M(this) || M(R)) return b; if (j(this)) return j(R) ? z(this).j(z(R)) : z(z(this).j(R)); if (j(R)) return z(this.j(z(R))); if (this.l(x) < 0 && R.l(x) < 0) return g(this.m() * R.m()); const A = this.g.length + R.g.length, C = []; for (var O = 0; O < 2 * A; O++)C[O] = 0; for (O = 0; O < this.g.length; O++)for (let I = 0; I < R.g.length; I++) { const k = this.i(O) >>> 16, D = this.i(O) & 65535, Yt = R.i(I) >>> 16, Wt = R.i(I) & 65535; C[2 * O + 2 * I] += D * Wt, it(C, 2 * O + 2 * I), C[2 * O + 2 * I + 1] += k * Wt, it(C, 2 * O + 2 * I + 1), C[2 * O + 2 * I + 1] += D * Yt, it(C, 2 * O + 2 * I + 1), C[2 * O + 2 * I + 2] += k * Yt, it(C, 2 * O + 2 * I + 2) } for (R = 0; R < A; R++)C[R] = C[2 * R + 1] << 16 | C[2 * R]; for (R = A; R < 2 * A; R++)C[R] = 0; return new c(C, 0) }; function it(R, A) { for (; (R[A] & 65535) != R[A];)R[A + 1] += R[A] >>> 16, R[A] &= 65535, A++ } function X(R, A) { this.g = R, this.h = A } function at(R, A) { if (M(A)) throw Error("division by zero"); if (M(R)) return new X(b, b); if (j(R)) return A = at(z(R), A), new X(z(A.g), z(A.h)); if (j(A)) return A = at(R, z(A)), new X(z(A.g), A.h); if (R.g.length > 30) { if (j(R) || j(A)) throw Error("slowDivide_ only works with positive integers."); for (var C = E, O = A; O.l(R) <= 0;)C = lt(C), O = lt(O); var I = ht(C, 1), k = ht(O, 1); for (O = ht(O, 2), C = ht(C, 2); !M(O);) { var D = k.add(O); D.l(R) <= 0 && (I = I.add(C), k = D), O = ht(O, 1), C = ht(C, 1) } return A = K(R, I.j(A)), new X(I, A) } for (I = b; R.l(A) >= 0;) { for (C = Math.max(1, Math.floor(R.m() / A.m())), O = Math.ceil(Math.log(C) / Math.LN2), O = O <= 48 ? 1 : Math.pow(2, O - 48), k = g(C), D = k.j(A); j(D) || D.l(R) > 0;)C -= O, k = g(C), D = k.j(A); M(k) && (k = E), I = I.add(k), R = K(R, D) } return new X(I, R) } e.B = function (R) { return at(this, R).h }, e.and = function (R) { const A = Math.max(this.g.length, R.g.length), C = []; for (let O = 0; O < A; O++)C[O] = this.i(O) & R.i(O); return new c(C, this.h & R.h) }, e.or = function (R) { const A = Math.max(this.g.length, R.g.length), C = []; for (let O = 0; O < A; O++)C[O] = this.i(O) | R.i(O); return new c(C, this.h | R.h) }, e.xor = function (R) { const A = Math.max(this.g.length, R.g.length), C = []; for (let O = 0; O < A; O++)C[O] = this.i(O) ^ R.i(O); return new c(C, this.h ^ R.h) }; function lt(R) { const A = R.g.length + 1, C = []; for (let O = 0; O < A; O++)C[O] = R.i(O) << 1 | R.i(O - 1) >>> 31; return new c(C, R.h) } function ht(R, A) { const C = A >> 5; A %= 32; const O = R.g.length - C, I = []; for (let k = 0; k < O; k++)I[k] = A > 0 ? R.i(k + C) >>> A | R.i(k + C + 1) << 32 - A : R.i(k + C); return new c(I, R.h) } r.prototype.digest = r.prototype.A, r.prototype.reset = r.prototype.u, r.prototype.update = r.prototype.v, DA = r, c.prototype.add = c.prototype.add, c.prototype.multiply = c.prototype.j, c.prototype.modulo = c.prototype.B, c.prototype.compare = c.prototype.l, c.prototype.toNumber = c.prototype.m, c.prototype.toString = c.prototype.toString, c.prototype.getBits = c.prototype.i, c.fromNumber = g, c.fromString = v, gr = c }).apply(typeof oT < "u" ? oT : typeof self < "u" ? self : typeof window < "u" ? window : {}); var Dh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; var VA, ou, MA, Fh, ig, IA, OA, NA; (function () {
  var e, t = Object.defineProperty; function i(h) { h = [typeof globalThis == "object" && globalThis, h, typeof window == "object" && window, typeof self == "object" && self, typeof Dh == "object" && Dh]; for (var y = 0; y < h.length; ++y) { var T = h[y]; if (T && T.Math == Math) return T } throw Error("Cannot find global object") } var r = i(this); function o(h, y) { if (y) t: { var T = r; h = h.split("."); for (var w = 0; w < h.length - 1; w++) { var U = h[w]; if (!(U in T)) break t; T = T[U] } h = h[h.length - 1], w = T[h], y = y(w), y != w && y != null && t(T, h, { configurable: !0, writable: !0, value: y }) } } o("Symbol.dispose", function (h) { return h || Symbol("Symbol.dispose") }), o("Array.prototype.values", function (h) { return h || function () { return this[Symbol.iterator]() } }), o("Object.entries", function (h) { return h || function (y) { var T = [], w; for (w in y) Object.prototype.hasOwnProperty.call(y, w) && T.push([w, y[w]]); return T } }); var u = u || {}, c = this || self; function d(h) { var y = typeof h; return y == "object" && h != null || y == "function" } function p(h, y, T) { return h.call.apply(h.bind, arguments) } function g(h, y, T) { return g = p, g.apply(null, arguments) } function v(h, y) { var T = Array.prototype.slice.call(arguments, 1); return function () { var w = T.slice(); return w.push.apply(w, arguments), h.apply(this, w) } } function b(h, y) { function T() { } T.prototype = y.prototype, h.Z = y.prototype, h.prototype = new T, h.prototype.constructor = h, h.Ob = function (w, U, G) { for (var ut = Array(arguments.length - 2), Vt = 2; Vt < arguments.length; Vt++)ut[Vt - 2] = arguments[Vt]; return y.prototype[U].apply(w, ut) } } var E = typeof AsyncContext < "u" && typeof AsyncContext.Snapshot == "function" ? h => h && AsyncContext.Snapshot.wrap(h) : h => h; function x(h) { const y = h.length; if (y > 0) { const T = Array(y); for (let w = 0; w < y; w++)T[w] = h[w]; return T } return [] } function M(h, y) { for (let w = 1; w < arguments.length; w++) { const U = arguments[w]; var T = typeof U; if (T = T != "object" ? T : U ? Array.isArray(U) ? "array" : T : "null", T == "array" || T == "object" && typeof U.length == "number") { T = h.length || 0; const G = U.length || 0; h.length = T + G; for (let ut = 0; ut < G; ut++)h[T + ut] = U[ut] } else h.push(U) } } class j { constructor(y, T) { this.i = y, this.j = T, this.h = 0, this.g = null } get() { let y; return this.h > 0 ? (this.h--, y = this.g, this.g = y.next, y.next = null) : y = this.i(), y } } function z(h) { c.setTimeout(() => { throw h }, 0) } function K() { var h = R; let y = null; return h.g && (y = h.g, h.g = h.g.next, h.g || (h.h = null), y.next = null), y } class it { constructor() { this.h = this.g = null } add(y, T) { const w = X.get(); w.set(y, T), this.h ? this.h.next = w : this.g = w, this.h = w } } var X = new j(() => new at, h => h.reset()); class at { constructor() { this.next = this.g = this.h = null } set(y, T) { this.h = y, this.g = T, this.next = null } reset() { this.next = this.g = this.h = null } } let lt, ht = !1, R = new it, A = () => { const h = Promise.resolve(void 0); lt = () => { h.then(C) } }; function C() { for (var h; h = K();) { try { h.h.call(h.g) } catch (T) { z(T) } var y = X; y.j(h), y.h < 100 && (y.h++, h.next = y.g, y.g = h) } ht = !1 } function O() { this.u = this.u, this.C = this.C } O.prototype.u = !1, O.prototype.dispose = function () { this.u || (this.u = !0, this.N()) }, O.prototype[Symbol.dispose] = function () { this.dispose() }, O.prototype.N = function () { if (this.C) for (; this.C.length;)this.C.shift()() }; function I(h, y) { this.type = h, this.g = this.target = y, this.defaultPrevented = !1 } I.prototype.h = function () { this.defaultPrevented = !0 }; var k = (function () { if (!c.addEventListener || !Object.defineProperty) return !1; var h = !1, y = Object.defineProperty({}, "passive", { get: function () { h = !0 } }); try { const T = () => { }; c.addEventListener("test", T, y), c.removeEventListener("test", T, y) } catch { } return h })(); function D(h) { return /^[\s\xa0]*$/.test(h) } function Yt(h, y) { I.call(this, h ? h.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, h && this.init(h, y) } b(Yt, I), Yt.prototype.init = function (h, y) { const T = this.type = h.type, w = h.changedTouches && h.changedTouches.length ? h.changedTouches[0] : null; this.target = h.target || h.srcElement, this.g = y, y = h.relatedTarget, y || (T == "mouseover" ? y = h.fromElement : T == "mouseout" && (y = h.toElement)), this.relatedTarget = y, w ? (this.clientX = w.clientX !== void 0 ? w.clientX : w.pageX, this.clientY = w.clientY !== void 0 ? w.clientY : w.pageY, this.screenX = w.screenX || 0, this.screenY = w.screenY || 0) : (this.clientX = h.clientX !== void 0 ? h.clientX : h.pageX, this.clientY = h.clientY !== void 0 ? h.clientY : h.pageY, this.screenX = h.screenX || 0, this.screenY = h.screenY || 0), this.button = h.button, this.key = h.key || "", this.ctrlKey = h.ctrlKey, this.altKey = h.altKey, this.shiftKey = h.shiftKey, this.metaKey = h.metaKey, this.pointerId = h.pointerId || 0, this.pointerType = h.pointerType, this.state = h.state, this.i = h, h.defaultPrevented && Yt.Z.h.call(this) }, Yt.prototype.h = function () { Yt.Z.h.call(this); const h = this.i; h.preventDefault ? h.preventDefault() : h.returnValue = !1 }; var Wt = "closure_listenable_" + (Math.random() * 1e6 | 0), Q = 0; function rt(h, y, T, w, U) { this.listener = h, this.proxy = null, this.src = y, this.type = T, this.capture = !!w, this.ha = U, this.key = ++Q, this.da = this.fa = !1 } function et(h) { h.da = !0, h.listener = null, h.proxy = null, h.src = null, h.ha = null } function xt(h, y, T) { for (const w in h) y.call(T, h[w], w, h) } function Ot(h, y) { for (const T in h) y.call(void 0, h[T], T, h) } function N(h) { const y = {}; for (const T in h) y[T] = h[T]; return y } const Z = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function ot(h, y) { let T, w; for (let U = 1; U < arguments.length; U++) { w = arguments[U]; for (T in w) h[T] = w[T]; for (let G = 0; G < Z.length; G++)T = Z[G], Object.prototype.hasOwnProperty.call(w, T) && (h[T] = w[T]) } } function ct(h) { this.src = h, this.g = {}, this.h = 0 } ct.prototype.add = function (h, y, T, w, U) { const G = h.toString(); h = this.g[G], h || (h = this.g[G] = [], this.h++); const ut = Ct(h, y, w, U); return ut > -1 ? (y = h[ut], T || (y.fa = !1)) : (y = new rt(y, this.src, G, !!w, U), y.fa = T, h.push(y)), y }; function Et(h, y) { const T = y.type; if (T in h.g) { var w = h.g[T], U = Array.prototype.indexOf.call(w, y, void 0), G; (G = U >= 0) && Array.prototype.splice.call(w, U, 1), G && (et(y), h.g[T].length == 0 && (delete h.g[T], h.h--)) } } function Ct(h, y, T, w) { for (let U = 0; U < h.length; ++U) { const G = h[U]; if (!G.da && G.listener == y && G.capture == !!T && G.ha == w) return U } return -1 } var Tt = "closure_lm_" + (Math.random() * 1e6 | 0), ye = {}; function $t(h, y, T, w, U) { if (Array.isArray(y)) { for (let G = 0; G < y.length; G++)$t(h, y[G], T, w, U); return null } return T = $o(T), h && h[Wt] ? h.J(y, T, d(w) ? !!w.capture : !1, U) : kn(h, y, T, !1, w, U) } function kn(h, y, T, w, U, G) { if (!y) throw Error("Invalid event type"); const ut = d(U) ? !!U.capture : !!U; let Vt = Ir(h); if (Vt || (h[Tt] = Vt = new ct(h)), T = Vt.add(y, T, w, ut, G), T.proxy) return T; if (w = yi(), T.proxy = w, w.src = h, w.listener = T, h.addEventListener) k || (U = ut), U === void 0 && (U = !1), h.addEventListener(y.toString(), w, U); else if (h.attachEvent) h.attachEvent(vi(y.toString()), w); else if (h.addListener && h.removeListener) h.addListener(w); else throw Error("addEventListener and attachEvent are unavailable."); return T } function yi() { function h(T) { return y.call(h.src, h.listener, T) } const y = Xo; return h } function Jn(h, y, T, w, U) { if (Array.isArray(y)) for (var G = 0; G < y.length; G++)Jn(h, y[G], T, w, U); else w = d(w) ? !!w.capture : !!w, T = $o(T), h && h[Wt] ? (h = h.i, G = String(y).toString(), G in h.g && (y = h.g[G], T = Ct(y, T, w, U), T > -1 && (et(y[T]), Array.prototype.splice.call(y, T, 1), y.length == 0 && (delete h.g[G], h.h--)))) : h && (h = Ir(h)) && (y = h.g[y.toString()], h = -1, y && (h = Ct(y, T, w, U)), (T = h > -1 ? y[h] : null) && Aa(T)) } function Aa(h) { if (typeof h != "number" && h && !h.da) { var y = h.src; if (y && y[Wt]) Et(y.i, h); else { var T = h.type, w = h.proxy; y.removeEventListener ? y.removeEventListener(T, w, h.capture) : y.detachEvent ? y.detachEvent(vi(T), w) : y.addListener && y.removeListener && y.removeListener(w), (T = Ir(y)) ? (Et(T, h), T.h == 0 && (T.src = null, y[Tt] = null)) : et(h) } } } function vi(h) { return h in ye ? ye[h] : ye[h] = "on" + h } function Xo(h, y) { if (h.da) h = !0; else { y = new Yt(y, this); const T = h.listener, w = h.ha || h.src; h.fa && Aa(h), h = T.call(w, y) } return h } function Ir(h) { return h = h[Tt], h instanceof ct ? h : null } var Wo = "__closure_events_fn_" + (Math.random() * 1e9 >>> 0); function $o(h) { return typeof h == "function" ? h : (h[Wo] || (h[Wo] = function (y) { return h.handleEvent(y) }), h[Wo]) } function Ce() { O.call(this), this.i = new ct(this), this.M = this, this.G = null } b(Ce, O), Ce.prototype[Wt] = !0, Ce.prototype.removeEventListener = function (h, y, T, w) { Jn(this, h, y, T, w) }; function Ue(h, y) { var T, w = h.G; if (w) for (T = []; w; w = w.G)T.push(w); if (h = h.M, w = y.type || y, typeof y == "string") y = new I(y, h); else if (y instanceof I) y.target = y.target || h; else { var U = y; y = new I(w, h), ot(y, U) } U = !0; let G, ut; if (T) for (ut = T.length - 1; ut >= 0; ut--)G = y.g = T[ut], U = Cs(G, w, !0, y) && U; if (G = y.g = h, U = Cs(G, w, !0, y) && U, U = Cs(G, w, !1, y) && U, T) for (ut = 0; ut < T.length; ut++)G = y.g = T[ut], U = Cs(G, w, !1, y) && U } Ce.prototype.N = function () { if (Ce.Z.N.call(this), this.i) { var h = this.i; for (const y in h.g) { const T = h.g[y]; for (let w = 0; w < T.length; w++)et(T[w]); delete h.g[y], h.h-- } } this.G = null }, Ce.prototype.J = function (h, y, T, w) { return this.i.add(String(h), y, !1, T, w) }, Ce.prototype.K = function (h, y, T, w) { return this.i.add(String(h), y, !0, T, w) }; function Cs(h, y, T, w) { if (y = h.i.g[String(y)], !y) return !0; y = y.concat(); let U = !0; for (let G = 0; G < y.length; ++G) { const ut = y[G]; if (ut && !ut.da && ut.capture == T) { const Vt = ut.listener, Ee = ut.ha || ut.src; ut.fa && Et(h.i, ut), U = Vt.call(Ee, w) !== !1 && U } } return U && !w.defaultPrevented } function Kf(h, y) { if (typeof h != "function") if (h && typeof h.handleEvent == "function") h = g(h.handleEvent, h); else throw Error("Invalid listener argument"); return Number(y) > 2147483647 ? -1 : c.setTimeout(h, y || 0) } function Ku(h) { h.g = Kf(() => { h.g = null, h.i && (h.i = !1, Ku(h)) }, h.l); const y = h.h; h.h = null, h.m.apply(null, y) } class fn extends O { constructor(y, T) { super(), this.m = y, this.l = T, this.h = null, this.i = !1, this.g = null } j(y) { this.h = arguments, this.g ? this.i = !0 : Ku(this) } N() { super.N(), this.g && (c.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function Or(h) { O.call(this), this.h = h, this.g = {} } b(Or, O); var Zo = []; function Jo(h) { xt(h.g, function (y, T) { this.g.hasOwnProperty(T) && Aa(y) }, h), h.g = {} } Or.prototype.N = function () { Or.Z.N.call(this), Jo(this) }, Or.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }; var Rs = c.JSON.stringify, Qf = c.JSON.parse, Qu = class { stringify(h) { return c.JSON.stringify(h, void 0) } parse(h) { return c.JSON.parse(h, void 0) } }; function Xu() { } function Wu() { } var ti = { OPEN: "a", hb: "b", ERROR: "c", tb: "d" }; function Xe() { I.call(this, "d") } b(Xe, I); function Ln() { I.call(this, "c") } b(Ln, I); var Te = {}, $u = null; function wa() { return $u = $u || new Ce } Te.Ia = "serverreachability"; function Zu(h) { I.call(this, Te.Ia, h) } b(Zu, I); function _i(h) { const y = wa(); Ue(y, new Zu(y)) } Te.STAT_EVENT = "statevent"; function Nr(h, y) { I.call(this, Te.STAT_EVENT, h), this.stat = y } b(Nr, I); function Re(h) { const y = wa(); Ue(y, new Nr(y, h)) } Te.Ja = "timingevent"; function bi(h, y) { I.call(this, Te.Ja, h), this.size = y } b(bi, I); function Ti(h, y) { if (typeof h != "function") throw Error("Fn must not be null and must be a function"); return c.setTimeout(function () { h() }, y) } function ei() { this.g = !0 } ei.prototype.ua = function () { this.g = !1 }; function Xf(h, y, T, w, U, G) {
    h.info(function () {
      if (h.g) if (G) { var ut = "", Vt = G.split("&"); for (let Kt = 0; Kt < Vt.length; Kt++) { var Ee = Vt[Kt].split("="); if (Ee.length > 1) { const fe = Ee[0]; Ee = Ee[1]; const Bn = fe.split("_"); ut = Bn.length >= 2 && Bn[1] == "type" ? ut + (fe + "=" + Ee + "&") : ut + (fe + "=redacted&") } } } else ut = null; else ut = G; return "XMLHTTP REQ (" + w + ") [attempt " + U + "]: " + y + `
`+ T + `
`+ ut
    })
  } function Ju(h, y, T, w, U, G, ut) {
    h.info(function () {
      return "XMLHTTP RESP (" + w + ") [ attempt " + U + "]: " + y + `
`+ T + `
`+ G + " " + ut
    })
  } function Ei(h, y, T, w) { h.info(function () { return "XMLHTTP TEXT (" + y + "): " + Wf(h, T) + (w ? " " + w : "") }) } function Pr(h, y) { h.info(function () { return "TIMEOUT: " + y }) } ei.prototype.info = function () { }; function Wf(h, y) { if (!h.g) return y; if (!y) return null; try { const G = JSON.parse(y); if (G) { for (h = 0; h < G.length; h++)if (Array.isArray(G[h])) { var T = G[h]; if (!(T.length < 2)) { var w = T[1]; if (Array.isArray(w) && !(w.length < 1)) { var U = w[0]; if (U != "noop" && U != "stop" && U != "close") for (let ut = 1; ut < w.length; ut++)w[ut] = "" } } } } return Rs(G) } catch { return y } } var kr = { NO_ERROR: 0, cb: 1, qb: 2, pb: 3, kb: 4, ob: 5, rb: 6, Ga: 7, TIMEOUT: 8, ub: 9 }, tl = { ib: "complete", Fb: "success", ERROR: "error", Ga: "abort", xb: "ready", yb: "readystatechange", TIMEOUT: "timeout", sb: "incrementaldata", wb: "progress", lb: "downloadprogress", Nb: "uploadprogress" }, el; function Lr() { } b(Lr, Xu), Lr.prototype.g = function () { return new XMLHttpRequest }, el = new Lr; function Ji(h) { return encodeURIComponent(String(h)) } function tc(h) { var y = 1; h = h.split(":"); const T = []; for (; y > 0 && h.length;)T.push(h.shift()), y--; return h.length && T.push(h.join(":")), T } function ni(h, y, T, w) { this.j = h, this.i = y, this.l = T, this.S = w || 1, this.V = new Or(this), this.H = 45e3, this.J = null, this.o = !1, this.u = this.B = this.A = this.M = this.F = this.T = this.D = null, this.G = [], this.g = null, this.C = 0, this.m = this.v = null, this.X = -1, this.K = !1, this.P = 0, this.O = null, this.W = this.L = this.U = this.R = !1, this.h = new ii } function ii() { this.i = null, this.g = "", this.h = !1 } var De = {}, Ge = {}; function Si(h, y, T) { h.M = 1, h.A = zr(Me(y)), h.u = T, h.R = !0, xa(h, null) } function xa(h, y) { h.F = Date.now(), Ai(h), h.B = Me(h.A); var T = h.B, w = h.S; Array.isArray(w) || (w = [String(w)]), Va(T.i, "t", w), h.C = 0, T = h.j.L, h.h = new ii, h.g = pc(h.j, T ? y : null, !h.u), h.P > 0 && (h.O = new fn(g(h.Y, h, h.g), h.P)), y = h.V, T = h.g, w = h.ba; var U = "readystatechange"; Array.isArray(U) || (U && (Zo[0] = U.toString()), U = Zo); for (let G = 0; G < U.length; G++) { const ut = $t(T, U[G], w || y.handleEvent, !1, y.h || y); if (!ut) break; y.g[ut.key] = ut } y = h.J ? N(h.J) : {}, h.u ? (h.v || (h.v = "POST"), y["Content-Type"] = "application/x-www-form-urlencoded", h.g.ea(h.B, h.v, h.u, y)) : (h.v = "GET", h.g.ea(h.B, h.v, null, y)), _i(), Xf(h.i, h.v, h.B, h.l, h.S, h.u) } ni.prototype.ba = function (h) { h = h.target; const y = this.O; y && ai(h) == 3 ? y.j() : this.Y(h) }, ni.prototype.Y = function (h) { try { if (h == this.g) t: { const Vt = ai(this.g), Ee = this.g.ya(), Kt = this.g.ca(); if (!(Vt < 3) && (Vt != 3 || this.g && (this.h.h || this.g.la() || We(this.g)))) { this.K || Vt != 4 || Ee == 7 || (Ee == 8 || Kt <= 0 ? _i(3) : _i(2)), wi(this); var y = this.g.ca(); this.X = y; var T = $f(this); if (this.o = y == 200, Ju(this.i, this.v, this.B, this.l, this.S, Vt, y), this.o) { if (this.U && !this.L) { e: { if (this.g) { var w, U = this.g; if ((w = U.g ? U.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !D(w)) { var G = w; break e } } G = null } if (h = G) Ei(this.i, this.l, h, "Initial handshake response via X-HTTP-Initial-Response"), this.L = !0, xi(this, h); else { this.o = !1, this.m = 3, Re(12), xn(this), zn(this); break t } } if (this.R) { h = !0; let fe; for (; !this.K && this.C < T.length;)if (fe = nc(this, T), fe == Ge) { Vt == 4 && (this.m = 4, Re(14), h = !1), Ei(this.i, this.l, null, "[Incomplete Response]"); break } else if (fe == De) { this.m = 4, Re(15), Ei(this.i, this.l, T, "[Invalid Chunk]"), h = !1; break } else Ei(this.i, this.l, fe, null), xi(this, fe); if (ec(this) && this.C != 0 && (this.h.g = this.h.g.slice(this.C), this.C = 0), Vt != 4 || T.length != 0 || this.h.h || (this.m = 1, Re(16), h = !1), this.o = this.o && h, !h) Ei(this.i, this.l, T, "[Invalid Chunked Response]"), xn(this), zn(this); else if (T.length > 0 && !this.W) { this.W = !0; var ut = this.j; ut.g == this && ut.aa && !ut.P && (ut.j.info("Great, no buffering proxy detected. Bytes received: " + T.length), gl(ut), ut.P = !0, Re(11)) } } else Ei(this.i, this.l, T, null), xi(this, T); Vt == 4 && xn(this), this.o && !this.K && (Vt == 4 ? hc(this.j, this) : (this.o = !1, Ai(this))) } else es(this.g), y == 400 && T.indexOf("Unknown SID") > 0 ? (this.m = 3, Re(12)) : (this.m = 0, Re(13)), xn(this), zn(this) } } } catch { } }; function $f(h) { if (!ec(h)) return h.g.la(); const y = We(h.g); if (y === "") return ""; let T = ""; const w = y.length, U = ai(h.g) == 4; if (!h.h.i) { if (typeof TextDecoder > "u") return xn(h), zn(h), ""; h.h.i = new c.TextDecoder } for (let G = 0; G < w; G++)h.h.h = !0, T += h.h.i.decode(y[G], { stream: !(U && G == w - 1) }); return y.length = 0, h.h.g += T, h.C = 0, h.h.g } function ec(h) { return h.g ? h.v == "GET" && h.M != 2 && h.j.Aa : !1 } function nc(h, y) {
    var T = h.C, w = y.indexOf(`
`, T); return w == -1 ? Ge : (T = Number(y.substring(T, w)), isNaN(T) ? De : (w += 1, w + T > y.length ? Ge : (y = y.slice(w, w + T), h.C = w + T, y)))
  } ni.prototype.cancel = function () { this.K = !0, xn(this) }; function Ai(h) { h.T = Date.now() + h.H, Ca(h, h.H) } function Ca(h, y) { if (h.D != null) throw Error("WatchDog timer not null"); h.D = Ti(g(h.aa, h), y) } function wi(h) { h.D && (c.clearTimeout(h.D), h.D = null) } ni.prototype.aa = function () { this.D = null; const h = Date.now(); h - this.T >= 0 ? (Pr(this.i, this.B), this.M != 2 && (_i(), Re(17)), xn(this), this.m = 2, zn(this)) : Ca(this, this.T - h) }; function zn(h) { h.j.I == 0 || h.K || hc(h.j, h) } function xn(h) { wi(h); var y = h.O; y && typeof y.dispose == "function" && y.dispose(), h.O = null, Jo(h.V), h.g && (y = h.g, h.g = null, y.abort(), y.dispose()) } function xi(h, y) { try { var T = h.j; if (T.I != 0 && (T.g == h || Ri(T.h, h))) { if (!h.L && Ri(T.h, h) && T.I == 3) { try { var w = T.Ba.g.parse(y) } catch { w = null } if (Array.isArray(w) && w.length == 3) { var U = w; if (U[0] == 0) { t: if (!T.v) { if (T.g) if (T.g.F + 3e3 < h.F) Pa(T), ks(T); else break t; Gr(T), Re(18) } } else T.xa = U[1], 0 < T.xa - T.K && U[2] < 37500 && T.F && T.A == 0 && !T.C && (T.C = Ti(g(T.Va, T), 6e3)); Ci(T.h) <= 1 && T.ta && (T.ta = void 0) } else Ni(T, 11) } else if ((h.L || T.g == h) && Pa(T), !D(y)) for (U = T.Ba.g.parse(y), y = 0; y < U.length; y++) { let Kt = U[y]; const fe = Kt[0]; if (!(fe <= T.K)) if (T.K = fe, Kt = Kt[1], T.I == 2) if (Kt[0] == "c") { T.M = Kt[1], T.ba = Kt[2]; const Bn = Kt[3]; Bn != null && (T.ka = Bn, T.j.info("VER=" + T.ka)); const Pi = Kt[4]; Pi != null && (T.za = Pi, T.j.info("SVER=" + T.za)); const oi = Kt[5]; oi != null && typeof oi == "number" && oi > 0 && (w = 1.5 * oi, T.O = w, T.j.info("backChannelRequestTimeoutMs_=" + w)), w = T; const li = h.g; if (li) { const Yr = li.g ? li.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (Yr) { var G = w.h; G.g || Yr.indexOf("spdy") == -1 && Yr.indexOf("quic") == -1 && Yr.indexOf("h2") == -1 || (G.j = G.l, G.g = new Set, G.h && (sl(G, G.h), G.h = null)) } if (w.G) { const ka = li.g ? li.g.getResponseHeader("X-HTTP-Session-Id") : null; ka && (w.wa = ka, Zt(w.J, w.G, ka)) } } T.I = 3, T.l && T.l.ra(), T.aa && (T.T = Date.now() - h.F, T.j.info("Handshake RTT: " + T.T + "ms")), w = T; var ut = h; if (w.na = mc(w, w.L ? w.ba : null, w.W), ut.L) { rl(w.h, ut); var Vt = ut, Ee = w.O; Ee && (Vt.H = Ee), Vt.D && (wi(Vt), Ai(Vt)), w.g = ut } else uc(w); T.i.length > 0 && Oi(T) } else Kt[0] != "stop" && Kt[0] != "close" || Ni(T, 7); else T.I == 3 && (Kt[0] == "stop" || Kt[0] == "close" ? Kt[0] == "stop" ? Ni(T, 7) : ml(T) : Kt[0] != "noop" && T.l && T.l.qa(Kt), T.A = 0) } } _i(4) } catch { } } var Ve = class { constructor(h, y) { this.g = h, this.map = y } }; function nl(h) { this.l = h || 10, c.PerformanceNavigationTiming ? (h = c.performance.getEntriesByType("navigation"), h = h.length > 0 && (h[0].nextHopProtocol == "hq" || h[0].nextHopProtocol == "h2")) : h = !!(c.chrome && c.chrome.loadTimes && c.chrome.loadTimes() && c.chrome.loadTimes().wasFetchedViaSpdy), this.j = h ? this.l : 1, this.g = null, this.j > 1 && (this.g = new Set), this.h = null, this.i = [] } function il(h) { return h.h ? !0 : h.g ? h.g.size >= h.j : !1 } function Ci(h) { return h.h ? 1 : h.g ? h.g.size : 0 } function Ri(h, y) { return h.h ? h.h == y : h.g ? h.g.has(y) : !1 } function sl(h, y) { h.g ? h.g.add(y) : h.h = y } function rl(h, y) { h.h && h.h == y ? h.h = null : h.g && h.g.has(y) && h.g.delete(y) } nl.prototype.cancel = function () { if (this.i = al(this), this.h) this.h.cancel(), this.h = null; else if (this.g && this.g.size !== 0) { for (const h of this.g.values()) h.cancel(); this.g.clear() } }; function al(h) { if (h.h != null) return h.i.concat(h.h.G); if (h.g != null && h.g.size !== 0) { let y = h.i; for (const T of h.g.values()) y = y.concat(T.G); return y } return x(h.i) } var ic = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function Ra(h, y) { if (h) { h = h.split("&"); for (let T = 0; T < h.length; T++) { const w = h[T].indexOf("="); let U, G = null; w >= 0 ? (U = h[T].substring(0, w), G = h[T].substring(w + 1)) : U = h[T], y(U, G ? decodeURIComponent(G.replace(/\+/g, " ")) : "") } } } function Cn(h) { this.g = this.o = this.j = "", this.u = null, this.m = this.h = "", this.l = !1; let y; h instanceof Cn ? (this.l = h.l, Ye(this, h.j), this.o = h.o, this.g = h.g, Ds(this, h.u), this.h = h.h, ol(this, oc(h.i)), this.m = h.m) : h && (y = String(h).match(ic)) ? (this.l = !1, Ye(this, y[1] || "", !0), this.o = Di(y[2] || ""), this.g = Di(y[3] || "", !0), Ds(this, y[4]), this.h = Di(y[5] || "", !0), ol(this, y[6] || "", !0), this.m = Di(y[7] || "")) : (this.l = !1, this.i = new Ms(null, this.l)) } Cn.prototype.toString = function () { const h = []; var y = this.j; y && h.push(jr(y, Da, !0), ":"); var T = this.g; return (T || y == "file") && (h.push("//"), (y = this.o) && h.push(jr(y, Da, !0), "@"), h.push(Ji(T).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), T = this.u, T != null && h.push(":", String(T))), (T = this.h) && (this.g && T.charAt(0) != "/" && h.push("/"), h.push(jr(T, T.charAt(0) == "/" ? ll : sc, !0))), (T = this.i.toString()) && h.push("?", T), (T = this.m) && h.push("#", jr(T, rc)), h.join("") }, Cn.prototype.resolve = function (h) { const y = Me(this); let T = !!h.j; T ? Ye(y, h.j) : T = !!h.o, T ? y.o = h.o : T = !!h.g, T ? y.g = h.g : T = h.u != null; var w = h.h; if (T) Ds(y, h.u); else if (T = !!h.h) { if (w.charAt(0) != "/") if (this.g && !this.h) w = "/" + w; else { var U = y.h.lastIndexOf("/"); U != -1 && (w = y.h.slice(0, U + 1) + w) } if (U = w, U == ".." || U == ".") w = ""; else if (U.indexOf("./") != -1 || U.indexOf("/.") != -1) { w = U.lastIndexOf("/", 0) == 0, U = U.split("/"); const G = []; for (let ut = 0; ut < U.length;) { const Vt = U[ut++]; Vt == "." ? w && ut == U.length && G.push("") : Vt == ".." ? ((G.length > 1 || G.length == 1 && G[0] != "") && G.pop(), w && ut == U.length && G.push("")) : (G.push(Vt), w = !0) } w = G.join("/") } else w = U } return T ? y.h = w : T = h.i.toString() !== "", T ? ol(y, oc(h.i)) : T = !!h.m, T && (y.m = h.m), y }; function Me(h) { return new Cn(h) } function Ye(h, y, T) { h.j = T ? Di(y, !0) : y, h.j && (h.j = h.j.replace(/:$/, "")) } function Ds(h, y) { if (y) { if (y = Number(y), isNaN(y) || y < 0) throw Error("Bad port number " + y); h.u = y } else h.u = null } function ol(h, y, T) { y instanceof Ms ? (h.i = y, Ma(h.i, h.l)) : (T || (y = jr(y, Vs)), h.i = new Ms(y, h.l)) } function Zt(h, y, T) { h.i.set(y, T) } function zr(h) { return Zt(h, "zx", Math.floor(Math.random() * 2147483648).toString(36) + Math.abs(Math.floor(Math.random() * 2147483648) ^ Date.now()).toString(36)), h } function Di(h, y) { return h ? y ? decodeURI(h.replace(/%25/g, "%2525")) : decodeURIComponent(h) : "" } function jr(h, y, T) { return typeof h == "string" ? (h = encodeURI(h).replace(y, yn), T && (h = h.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), h) : null } function yn(h) { return h = h.charCodeAt(0), "%" + (h >> 4 & 15).toString(16) + (h & 15).toString(16) } var Da = /[#\/\?@]/g, sc = /[#\?:]/g, ll = /[#\?]/g, Vs = /[#\?@]/g, rc = /#/g; function Ms(h, y) { this.h = this.g = null, this.i = h || null, this.j = !!y } function vn(h) { h.g || (h.g = new Map, h.h = 0, h.i && Ra(h.i, function (y, T) { h.add(decodeURIComponent(y.replace(/\+/g, " ")), T) })) } e = Ms.prototype, e.add = function (h, y) { vn(this), this.i = null, h = Is(this, h); let T = this.g.get(h); return T || this.g.set(h, T = []), T.push(y), this.h += 1, this }; function ac(h, y) { vn(h), y = Is(h, y), h.g.has(y) && (h.i = null, h.h -= h.g.get(y).length, h.g.delete(y)) } function ul(h, y) { return vn(h), y = Is(h, y), h.g.has(y) } e.forEach = function (h, y) { vn(this), this.g.forEach(function (T, w) { T.forEach(function (U) { h.call(y, U, w, this) }, this) }, this) }; function cl(h, y) { vn(h); let T = []; if (typeof y == "string") ul(h, y) && (T = T.concat(h.g.get(Is(h, y)))); else for (h = Array.from(h.g.values()), y = 0; y < h.length; y++)T = T.concat(h[y]); return T } e.set = function (h, y) { return vn(this), this.i = null, h = Is(this, h), ul(this, h) && (this.h -= this.g.get(h).length), this.g.set(h, [y]), this.h += 1, this }, e.get = function (h, y) { return h ? (h = cl(this, h), h.length > 0 ? String(h[0]) : y) : y }; function Va(h, y, T) { ac(h, y), T.length > 0 && (h.i = null, h.g.set(Is(h, y), x(T)), h.h += T.length) } e.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const h = [], y = Array.from(this.g.keys()); for (let w = 0; w < y.length; w++) { var T = y[w]; const U = Ji(T); T = cl(this, T); for (let G = 0; G < T.length; G++) { let ut = U; T[G] !== "" && (ut += "=" + Ji(T[G])), h.push(ut) } } return this.i = h.join("&") }; function oc(h) { const y = new Ms; return y.i = h.i, h.g && (y.g = new Map(h.g), y.h = h.h), y } function Is(h, y) { return y = String(y), h.j && (y = y.toLowerCase()), y } function Ma(h, y) { y && !h.j && (vn(h), h.i = null, h.g.forEach(function (T, w) { const U = w.toLowerCase(); w != U && (ac(this, w), Va(this, U, T)) }, h)), h.j = y } function si(h, y) { const T = new ei; if (c.Image) { const w = new Image; w.onload = v(jn, T, "TestLoadImage: loaded", !0, y, w), w.onerror = v(jn, T, "TestLoadImage: error", !1, y, w), w.onabort = v(jn, T, "TestLoadImage: abort", !1, y, w), w.ontimeout = v(jn, T, "TestLoadImage: timeout", !1, y, w), c.setTimeout(function () { w.ontimeout && w.ontimeout() }, 1e4), w.src = h } else y(!1) } function hl(h, y) { const T = new ei, w = new AbortController, U = setTimeout(() => { w.abort(), jn(T, "TestPingServer: timeout", !1, y) }, 1e4); fetch(h, { signal: w.signal }).then(G => { clearTimeout(U), G.ok ? jn(T, "TestPingServer: ok", !0, y) : jn(T, "TestPingServer: server error", !1, y) }).catch(() => { clearTimeout(U), jn(T, "TestPingServer: error", !1, y) }) } function jn(h, y, T, w, U) { try { U && (U.onload = null, U.onerror = null, U.onabort = null, U.ontimeout = null), w(T) } catch { } } function Os() { this.g = new Qu } function Vi(h) { this.i = h.Sb || null, this.h = h.ab || !1 } b(Vi, Xu), Vi.prototype.g = function () { return new Ur(this.i, this.h) }; function Ur(h, y) { Ce.call(this), this.H = h, this.o = y, this.m = void 0, this.status = this.readyState = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.A = new Headers, this.h = null, this.F = "GET", this.D = "", this.g = !1, this.B = this.j = this.l = null, this.v = new AbortController } b(Ur, Ce), e = Ur.prototype, e.open = function (h, y) { if (this.readyState != 0) throw this.abort(), Error("Error reopening a connection"); this.F = h, this.D = y, this.readyState = 1, ri(this) }, e.send = function (h) { if (this.readyState != 1) throw this.abort(), Error("need to call open() first. "); if (this.v.signal.aborted) throw this.abort(), Error("Request was aborted."); this.g = !0; const y = { headers: this.A, method: this.F, credentials: this.m, cache: void 0, signal: this.v.signal }; h && (y.body = h), (this.H || c).fetch(new Request(this.D, y)).then(this.Pa.bind(this), this.ga.bind(this)) }, e.abort = function () { this.response = this.responseText = "", this.A = new Headers, this.status = 0, this.v.abort(), this.j && this.j.cancel("Request was aborted.").catch(() => { }), this.readyState >= 1 && this.g && this.readyState != 4 && (this.g = !1, Ns(this)), this.readyState = 0 }, e.Pa = function (h) { if (this.g && (this.l = h, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = h.headers, this.readyState = 2, ri(this)), this.g && (this.readyState = 3, ri(this), this.g))) if (this.responseType === "arraybuffer") h.arrayBuffer().then(this.Na.bind(this), this.ga.bind(this)); else if (typeof c.ReadableStream < "u" && "body" in h) { if (this.j = h.body.getReader(), this.o) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.B = new TextDecoder; Ia(this) } else h.text().then(this.Oa.bind(this), this.ga.bind(this)) }; function Ia(h) { h.j.read().then(h.Ma.bind(h)).catch(h.ga.bind(h)) } e.Ma = function (h) { if (this.g) { if (this.o && h.value) this.response.push(h.value); else if (!this.o) { var y = h.value ? h.value : new Uint8Array(0); (y = this.B.decode(y, { stream: !h.done })) && (this.response = this.responseText += y) } h.done ? Ns(this) : ri(this), this.readyState == 3 && Ia(this) } }, e.Oa = function (h) { this.g && (this.response = this.responseText = h, Ns(this)) }, e.Na = function (h) { this.g && (this.response = h, Ns(this)) }, e.ga = function () { this.g && Ns(this) }; function Ns(h) { h.readyState = 4, h.l = null, h.j = null, h.B = null, ri(h) } e.setRequestHeader = function (h, y) { this.A.append(h, y) }, e.getResponseHeader = function (h) { return this.h && this.h.get(h.toLowerCase()) || "" }, e.getAllResponseHeaders = function () {
    if (!this.h) return ""; const h = [], y = this.h.entries(); for (var T = y.next(); !T.done;)T = T.value, h.push(T[0] + ": " + T[1]), T = y.next(); return h.join(`\r
`)
  }; function ri(h) { h.onreadystatechange && h.onreadystatechange.call(h) } Object.defineProperty(Ur.prototype, "withCredentials", { get: function () { return this.m === "include" }, set: function (h) { this.m = h ? "include" : "same-origin" } }); function Un(h) {
    let y = ""; return xt(h, function (T, w) {
      y += w, y += ":", y += T, y += `\r
`}), y
  } function Br(h, y, T) { t: { for (w in T) { var w = !1; break t } w = !0 } w || (T = Un(T), typeof h == "string" ? T != null && Ji(T) : Zt(h, y, T)) } function ne(h) { Ce.call(this), this.headers = new Map, this.L = h || null, this.h = !1, this.g = null, this.D = "", this.o = 0, this.l = "", this.j = this.B = this.v = this.A = !1, this.m = null, this.F = "", this.H = !1 } b(ne, Ce); var Mi = /^https?$/i, fl = ["POST", "PUT"]; e = ne.prototype, e.Fa = function (h) { this.H = h }, e.ea = function (h, y, T, w) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.D + "; newUri=" + h); y = y ? y.toUpperCase() : "GET", this.D = h, this.l = "", this.o = 0, this.A = !1, this.h = !0, this.g = this.L ? this.L.g() : el.g(), this.g.onreadystatechange = E(g(this.Ca, this)); try { this.B = !0, this.g.open(y, String(h), !0), this.B = !1 } catch (G) { Fr(this, G); return } if (h = T || "", T = new Map(this.headers), w) if (Object.getPrototypeOf(w) === Object.prototype) for (var U in w) T.set(U, w[U]); else if (typeof w.keys == "function" && typeof w.get == "function") for (const G of w.keys()) T.set(G, w.get(G)); else throw Error("Unknown input type for opt_headers: " + String(w)); w = Array.from(T.keys()).find(G => G.toLowerCase() == "content-type"), U = c.FormData && h instanceof c.FormData, !(Array.prototype.indexOf.call(fl, y, void 0) >= 0) || w || U || T.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [G, ut] of T) this.g.setRequestHeader(G, ut); this.F && (this.g.responseType = this.F), "withCredentials" in this.g && this.g.withCredentials !== this.H && (this.g.withCredentials = this.H); try { this.m && (clearTimeout(this.m), this.m = null), this.v = !0, this.g.send(h), this.v = !1 } catch (G) { Fr(this, G) } }; function Fr(h, y) { h.h = !1, h.g && (h.j = !0, h.g.abort(), h.j = !1), h.l = y, h.o = 5, dl(h), ts(h) } function dl(h) { h.A || (h.A = !0, Ue(h, "complete"), Ue(h, "error")) } e.abort = function (h) { this.g && this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1, this.o = h || 7, Ue(this, "complete"), Ue(this, "abort"), ts(this)) }, e.N = function () { this.g && (this.h && (this.h = !1, this.j = !0, this.g.abort(), this.j = !1), ts(this, !0)), ne.Z.N.call(this) }, e.Ca = function () { this.u || (this.B || this.v || this.j ? qr(this) : this.Xa()) }, e.Xa = function () { qr(this) }; function qr(h) { if (h.h && typeof u < "u") { if (h.v && ai(h) == 4) setTimeout(h.Ca.bind(h), 0); else if (Ue(h, "readystatechange"), ai(h) == 4) { h.h = !1; try { const G = h.ca(); t: switch (G) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var y = !0; break t; default: y = !1 }var T; if (!(T = y)) { var w; if (w = G === 0) { let ut = String(h.D).match(ic)[1] || null; !ut && c.self && c.self.location && (ut = c.self.location.protocol.slice(0, -1)), w = !Mi.test(ut ? ut.toLowerCase() : "") } T = w } if (T) Ue(h, "complete"), Ue(h, "success"); else { h.o = 6; try { var U = ai(h) > 2 ? h.g.statusText : "" } catch { U = "" } h.l = U + " [" + h.ca() + "]", dl(h) } } finally { ts(h) } } } } function ts(h, y) { if (h.g) { h.m && (clearTimeout(h.m), h.m = null); const T = h.g; h.g = null, y || Ue(h, "ready"); try { T.onreadystatechange = null } catch { } } } e.isActive = function () { return !!this.g }; function ai(h) { return h.g ? h.g.readyState : 0 } e.ca = function () { try { return ai(this) > 2 ? this.g.status : -1 } catch { return -1 } }, e.la = function () { try { return this.g ? this.g.responseText : "" } catch { return "" } }, e.La = function (h) { if (this.g) { var y = this.g.responseText; return h && y.indexOf(h) == 0 && (y = y.substring(h.length)), Qf(y) } }; function We(h) { try { if (!h.g) return null; if ("response" in h.g) return h.g.response; switch (h.F) { case "": case "text": return h.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in h.g) return h.g.mozResponseArrayBuffer }return null } catch { return null } } function es(h) {
    const y = {}; h = (h.g && ai(h) >= 2 && h.g.getAllResponseHeaders() || "").split(`\r
`); for (let w = 0; w < h.length; w++) { if (D(h[w])) continue; var T = tc(h[w]); const U = T[0]; if (T = T[1], typeof T != "string") continue; T = T.trim(); const G = y[U] || []; y[U] = G, G.push(T) } Ot(y, function (w) { return w.join(", ") })
  } e.ya = function () { return this.o }, e.Ha = function () { return typeof this.l == "string" ? this.l : String(this.l) }; function Ii(h, y, T) { return T && T.internalChannelParams && T.internalChannelParams[h] || y } function Ps(h) { this.za = 0, this.i = [], this.j = new ei, this.ba = this.na = this.J = this.W = this.g = this.wa = this.G = this.H = this.u = this.U = this.o = null, this.Ya = this.V = 0, this.Sa = Ii("failFast", !1, h), this.F = this.C = this.v = this.m = this.l = null, this.X = !0, this.xa = this.K = -1, this.Y = this.A = this.D = 0, this.Qa = Ii("baseRetryDelayMs", 5e3, h), this.Za = Ii("retryDelaySeedMs", 1e4, h), this.Ta = Ii("forwardChannelMaxRetries", 2, h), this.va = Ii("forwardChannelRequestTimeoutMs", 2e4, h), this.ma = h && h.xmlHttpFactory || void 0, this.Ua = h && h.Rb || void 0, this.Aa = h && h.useFetchStreams || !1, this.O = void 0, this.L = h && h.supportsCrossDomainXhr || !1, this.M = "", this.h = new nl(h && h.concurrentRequestLimit), this.Ba = new Os, this.S = h && h.fastHandshake || !1, this.R = h && h.encodeInitMessageHeaders || !1, this.S && this.R && (this.R = !1), this.Ra = h && h.Pb || !1, h && h.ua && this.j.ua(), h && h.forceLongPolling && (this.X = !1), this.aa = !this.S && this.X && h && h.detectBufferingProxy || !1, this.ia = void 0, h && h.longPollingTimeout && h.longPollingTimeout > 0 && (this.ia = h.longPollingTimeout), this.ta = void 0, this.T = 0, this.P = !1, this.ja = this.B = null } e = Ps.prototype, e.ka = 8, e.I = 1, e.connect = function (h, y, T, w) { Re(0), this.W = h, this.H = y || {}, T && w !== void 0 && (this.H.OSID = T, this.H.OAID = w), this.F = this.X, this.J = mc(this, null, this.W), Oi(this) }; function ml(h) { if (Oa(h), h.I == 3) { var y = h.V++, T = Me(h.J); if (Zt(T, "SID", h.M), Zt(T, "RID", y), Zt(T, "TYPE", "terminate"), Hr(h, T), y = new ni(h, h.j, y), y.M = 2, y.A = zr(Me(T)), T = !1, c.navigator && c.navigator.sendBeacon) try { T = c.navigator.sendBeacon(y.A.toString(), "") } catch { } !T && c.Image && (new Image().src = y.A, T = !0), T || (y.g = pc(y.j, null), y.g.ea(y.A)), y.F = Date.now(), Ai(y) } dc(h) } function ks(h) { h.g && (gl(h), h.g.cancel(), h.g = null) } function Oa(h) { ks(h), h.v && (c.clearTimeout(h.v), h.v = null), Pa(h), h.h.cancel(), h.m && (typeof h.m == "number" && c.clearTimeout(h.m), h.m = null) } function Oi(h) { if (!il(h.h) && !h.m) { h.m = !0; var y = h.Ea; lt || A(), ht || (lt(), ht = !0), R.add(y, h), h.D = 0 } } function Na(h, y) { return Ci(h.h) >= h.h.j - (h.m ? 1 : 0) ? !1 : h.m ? (h.i = y.G.concat(h.i), !0) : h.I == 1 || h.I == 2 || h.D >= (h.Sa ? 0 : h.Ta) ? !1 : (h.m = Ti(g(h.Ea, h, y), fc(h, h.D)), h.D++, !0) } e.Ea = function (h) { if (this.m) if (this.m = null, this.I == 1) { if (!h) { this.V = Math.floor(Math.random() * 1e5), h = this.V++; const U = new ni(this, this.j, h); let G = this.o; if (this.U && (G ? (G = N(G), ot(G, this.U)) : G = this.U), this.u !== null || this.R || (U.J = G, G = null), this.S) t: { for (var y = 0, T = 0; T < this.i.length; T++) { e: { var w = this.i[T]; if ("__data__" in w.map && (w = w.map.__data__, typeof w == "string")) { w = w.length; break e } w = void 0 } if (w === void 0) break; if (y += w, y > 4096) { y = T; break t } if (y === 4096 || T === this.i.length - 1) { y = T + 1; break t } } y = 1e3 } else y = 1e3; y = lc(this, U, y), T = Me(this.J), Zt(T, "RID", h), Zt(T, "CVER", 22), this.G && Zt(T, "X-HTTP-Session-Id", this.G), Hr(this, T), G && (this.R ? y = "headers=" + Ji(Un(G)) + "&" + y : this.u && Br(T, this.u, G)), sl(this.h, U), this.Ra && Zt(T, "TYPE", "init"), this.S ? (Zt(T, "$req", y), Zt(T, "SID", "null"), U.U = !0, Si(U, T, null)) : Si(U, T, y), this.I = 2 } } else this.I == 3 && (h ? pl(this, h) : this.i.length == 0 || il(this.h) || pl(this)) }; function pl(h, y) { var T; y ? T = y.l : T = h.V++; const w = Me(h.J); Zt(w, "SID", h.M), Zt(w, "RID", T), Zt(w, "AID", h.K), Hr(h, w), h.u && h.o && Br(w, h.u, h.o), T = new ni(h, h.j, T, h.D + 1), h.u === null && (T.J = h.o), y && (h.i = y.G.concat(h.i)), y = lc(h, T, 1e3), T.H = Math.round(h.va * .5) + Math.round(h.va * .5 * Math.random()), sl(h.h, T), Si(T, w, y) } function Hr(h, y) { h.H && xt(h.H, function (T, w) { Zt(y, w, T) }), h.l && xt({}, function (T, w) { Zt(y, w, T) }) } function lc(h, y, T) { T = Math.min(h.i.length, T); const w = h.l ? g(h.l.Ka, h.l, h) : null; t: { var U = h.i; let Vt = -1; for (; ;) { const Ee = ["count=" + T]; Vt == -1 ? T > 0 ? (Vt = U[0].g, Ee.push("ofs=" + Vt)) : Vt = 0 : Ee.push("ofs=" + Vt); let Kt = !0; for (let fe = 0; fe < T; fe++) { var G = U[fe].g; const Bn = U[fe].map; if (G -= Vt, G < 0) Vt = Math.max(0, U[fe].g - 100), Kt = !1; else try { G = "req" + G + "_" || ""; try { var ut = Bn instanceof Map ? Bn : Object.entries(Bn); for (const [Pi, oi] of ut) { let li = oi; d(oi) && (li = Rs(oi)), Ee.push(G + Pi + "=" + encodeURIComponent(li)) } } catch (Pi) { throw Ee.push(G + "type=" + encodeURIComponent("_badmap")), Pi } } catch { w && w(Bn) } } if (Kt) { ut = Ee.join("&"); break t } } ut = void 0 } return h = h.i.splice(0, T), y.G = h, ut } function uc(h) { if (!h.g && !h.v) { h.Y = 1; var y = h.Da; lt || A(), ht || (lt(), ht = !0), R.add(y, h), h.A = 0 } } function Gr(h) { return h.g || h.v || h.A >= 3 ? !1 : (h.Y++, h.v = Ti(g(h.Da, h), fc(h, h.A)), h.A++, !0) } e.Da = function () { if (this.v = null, cc(this), this.aa && !(this.P || this.g == null || this.T <= 0)) { var h = 4 * this.T; this.j.info("BP detection timer enabled: " + h), this.B = Ti(g(this.Wa, this), h) } }, e.Wa = function () { this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.F = !1, this.P = !0, Re(10), ks(this), cc(this)) }; function gl(h) { h.B != null && (c.clearTimeout(h.B), h.B = null) } function cc(h) { h.g = new ni(h, h.j, "rpc", h.Y), h.u === null && (h.g.J = h.o), h.g.P = 0; var y = Me(h.na); Zt(y, "RID", "rpc"), Zt(y, "SID", h.M), Zt(y, "AID", h.K), Zt(y, "CI", h.F ? "0" : "1"), !h.F && h.ia && Zt(y, "TO", h.ia), Zt(y, "TYPE", "xmlhttp"), Hr(h, y), h.u && h.o && Br(y, h.u, h.o), h.O && (h.g.H = h.O); var T = h.g; h = h.ba, T.M = 1, T.A = zr(Me(y)), T.u = null, T.R = !0, xa(T, h) } e.Va = function () { this.C != null && (this.C = null, ks(this), Gr(this), Re(19)) }; function Pa(h) { h.C != null && (c.clearTimeout(h.C), h.C = null) } function hc(h, y) { var T = null; if (h.g == y) { Pa(h), gl(h), h.g = null; var w = 2 } else if (Ri(h.h, y)) T = y.G, rl(h.h, y), w = 1; else return; if (h.I != 0) { if (y.o) if (w == 1) { T = y.u ? y.u.length : 0, y = Date.now() - y.F; var U = h.D; w = wa(), Ue(w, new bi(w, T)), Oi(h) } else uc(h); else if (U = y.m, U == 3 || U == 0 && y.X > 0 || !(w == 1 && Na(h, y) || w == 2 && Gr(h))) switch (T && T.length > 0 && (y = h.h, y.i = y.i.concat(T)), U) { case 1: Ni(h, 5); break; case 4: Ni(h, 10); break; case 3: Ni(h, 6); break; default: Ni(h, 2) } } } function fc(h, y) { let T = h.Qa + Math.floor(Math.random() * h.Za); return h.isActive() || (T *= 2), T * y } function Ni(h, y) { if (h.j.info("Error code " + y), y == 2) { var T = g(h.bb, h), w = h.Ua; const U = !w; w = new Cn(w || "//www.google.com/images/cleardot.gif"), c.location && c.location.protocol == "http" || Ye(w, "https"), zr(w), U ? si(w.toString(), T) : hl(w.toString(), T) } else Re(2); h.I = 0, h.l && h.l.pa(y), dc(h), Oa(h) } e.bb = function (h) { h ? (this.j.info("Successfully pinged google.com"), Re(2)) : (this.j.info("Failed to ping google.com"), Re(1)) }; function dc(h) { if (h.I = 0, h.ja = [], h.l) { const y = al(h.h); (y.length != 0 || h.i.length != 0) && (M(h.ja, y), M(h.ja, h.i), h.h.i.length = 0, x(h.i), h.i.length = 0), h.l.oa() } } function mc(h, y, T) { var w = T instanceof Cn ? Me(T) : new Cn(T); if (w.g != "") y && (w.g = y + "." + w.g), Ds(w, w.u); else { var U = c.location; w = U.protocol, y = y ? y + "." + U.hostname : U.hostname, U = +U.port; const G = new Cn(null); w && Ye(G, w), y && (G.g = y), U && Ds(G, U), T && (G.h = T), w = G } return T = h.G, y = h.wa, T && y && Zt(w, T, y), Zt(w, "VER", h.ka), Hr(h, w), w } function pc(h, y, T) { if (y && !h.L) throw Error("Can't create secondary domain capable XhrIo object."); return y = h.Aa && !h.ma ? new ne(new Vi({ ab: T })) : new ne(h.ma), y.Fa(h.L), y } e.isActive = function () { return !!this.l && this.l.isActive(this) }; function gc() { } e = gc.prototype, e.ra = function () { }, e.qa = function () { }, e.pa = function () { }, e.oa = function () { }, e.isActive = function () { return !0 }, e.Ka = function () { }; function Ls() { } Ls.prototype.g = function (h, y) { return new dn(h, y) }; function dn(h, y) { Ce.call(this), this.g = new Ps(y), this.l = h, this.h = y && y.messageUrlParams || null, h = y && y.messageHeaders || null, y && y.clientProtocolHeaderRequired && (h ? h["X-Client-Protocol"] = "webchannel" : h = { "X-Client-Protocol": "webchannel" }), this.g.o = h, h = y && y.initMessageHeaders || null, y && y.messageContentType && (h ? h["X-WebChannel-Content-Type"] = y.messageContentType : h = { "X-WebChannel-Content-Type": y.messageContentType }), y && y.sa && (h ? h["X-WebChannel-Client-Profile"] = y.sa : h = { "X-WebChannel-Client-Profile": y.sa }), this.g.U = h, (h = y && y.Qb) && !D(h) && (this.g.u = h), this.A = y && y.supportsCrossDomainXhr || !1, this.v = y && y.sendRawJson || !1, (y = y && y.httpSessionIdParam) && !D(y) && (this.g.G = y, h = this.h, h !== null && y in h && (h = this.h, y in h && delete h[y])), this.j = new ns(this) } b(dn, Ce), dn.prototype.m = function () { this.g.l = this.j, this.A && (this.g.L = !0), this.g.connect(this.l, this.h || void 0) }, dn.prototype.close = function () { ml(this.g) }, dn.prototype.o = function (h) { var y = this.g; if (typeof h == "string") { var T = {}; T.__data__ = h, h = T } else this.v && (T = {}, T.__data__ = Rs(h), h = T); y.i.push(new Ve(y.Ya++, h)), y.I == 3 && Oi(y) }, dn.prototype.N = function () { this.g.l = null, delete this.j, ml(this.g), delete this.g, dn.Z.N.call(this) }; function yc(h) { Xe.call(this), h.__headers__ && (this.headers = h.__headers__, this.statusCode = h.__status__, delete h.__headers__, delete h.__status__); var y = h.__sm__; if (y) { t: { for (const T in y) { h = T; break t } h = void 0 } (this.i = h) && (h = this.i, y = y !== null && h in y ? y[h] : void 0), this.data = y } else this.data = h } b(yc, Xe); function vc() { Ln.call(this), this.status = 1 } b(vc, Ln); function ns(h) { this.g = h } b(ns, gc), ns.prototype.ra = function () { Ue(this.g, "a") }, ns.prototype.qa = function (h) { Ue(this.g, new yc(h)) }, ns.prototype.pa = function (h) { Ue(this.g, new vc) }, ns.prototype.oa = function () { Ue(this.g, "b") }, Ls.prototype.createWebChannel = Ls.prototype.g, dn.prototype.send = dn.prototype.o, dn.prototype.open = dn.prototype.m, dn.prototype.close = dn.prototype.close, NA = function () { return new Ls }, OA = function () { return wa() }, IA = Te, ig = { jb: 0, mb: 1, nb: 2, Hb: 3, Mb: 4, Jb: 5, Kb: 6, Ib: 7, Gb: 8, Lb: 9, PROXY: 10, NOPROXY: 11, Eb: 12, Ab: 13, Bb: 14, zb: 15, Cb: 16, Db: 17, fb: 18, eb: 19, gb: 20 }, kr.NO_ERROR = 0, kr.TIMEOUT = 8, kr.HTTP_ERROR = 6, Fh = kr, tl.COMPLETE = "complete", MA = tl, Wu.EventType = ti, ti.OPEN = "a", ti.CLOSE = "b", ti.ERROR = "c", ti.MESSAGE = "d", Ce.prototype.listen = Ce.prototype.J, ou = Wu, ne.prototype.listenOnce = ne.prototype.K, ne.prototype.getLastError = ne.prototype.Ha, ne.prototype.getLastErrorCode = ne.prototype.ya, ne.prototype.getStatus = ne.prototype.ca, ne.prototype.getResponseJson = ne.prototype.La, ne.prototype.getResponseText = ne.prototype.la, ne.prototype.send = ne.prototype.ea, ne.prototype.setWithCredentials = ne.prototype.Fa, VA = ne
}).apply(typeof Dh < "u" ? Dh : typeof self < "u" ? self : typeof window < "u" ? window : {}); class un { constructor(t) { this.uid = t } isAuthenticated() { return this.uid != null } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(t) { return t.uid === this.uid } } un.UNAUTHENTICATED = new un(null), un.GOOGLE_CREDENTIALS = new un("google-credentials-uid"), un.FIRST_PARTY = new un("first-party-uid"), un.MOCK_USER = new un("mock-user"); let Ho = "12.9.0"; function PO(e) { Ho = e } const _a = new SA("@firebase/firestore"); function go() { return _a.logLevel } function dt(e, ...t) { if (_a.logLevel <= qt.DEBUG) { const i = t.map(ay); _a.debug(`Firestore (${Ho}): ${e}`, ...i) } } function ws(e, ...t) { if (_a.logLevel <= qt.ERROR) { const i = t.map(ay); _a.error(`Firestore (${Ho}): ${e}`, ...i) } } function ba(e, ...t) { if (_a.logLevel <= qt.WARN) { const i = t.map(ay); _a.warn(`Firestore (${Ho}): ${e}`, ...i) } } function ay(e) { if (typeof e == "string") return e; try { return (function (i) { return JSON.stringify(i) })(e) } catch { return e } } function At(e, t, i) { let r = "Unexpected state"; typeof t == "string" ? r = t : i = t, PA(e, r, i) } function PA(e, t, i) { let r = `FIRESTORE (${Ho}) INTERNAL ASSERTION FAILED: ${t} (ID: ${e.toString(16)})`; if (i !== void 0) try { r += " CONTEXT: " + JSON.stringify(i) } catch { r += " CONTEXT: " + i } throw ws(r), new Error(r) } function Xt(e, t, i, r) { let o = "Unexpected state"; typeof i == "string" ? o = i : r = i, e || PA(t, o, r) } function Dt(e, t) { return e } const nt = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class ft extends qo { constructor(t, i) { super(t, i), this.code = t, this.message = i, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}` } } class ya { constructor() { this.promise = new Promise(((t, i) => { this.resolve = t, this.reject = i })) } } class kA { constructor(t, i) { this.user = i, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${t}`) } } class kO { getToken() { return Promise.resolve(null) } invalidateToken() { } start(t, i) { t.enqueueRetryable((() => i(un.UNAUTHENTICATED))) } shutdown() { } } class LO { constructor(t) { this.token = t, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(t, i) { this.changeListener = i, t.enqueueRetryable((() => i(this.token.user))) } shutdown() { this.changeListener = null } } class zO { constructor(t) { this.t = t, this.currentUser = un.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(t, i) { Xt(this.o === void 0, 42304); let r = this.i; const o = p => this.i !== r ? (r = this.i, i(p)) : Promise.resolve(); let u = new ya; this.o = () => { this.i++, this.currentUser = this.u(), u.resolve(), u = new ya, t.enqueueRetryable((() => o(this.currentUser))) }; const c = () => { const p = u; t.enqueueRetryable((async () => { await p.promise, await o(this.currentUser) })) }, d = p => { dt("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = p, this.o && (this.auth.addAuthTokenListener(this.o), c()) }; this.t.onInit((p => d(p))), setTimeout((() => { if (!this.auth) { const p = this.t.getImmediate({ optional: !0 }); p ? d(p) : (dt("FirebaseAuthCredentialsProvider", "Auth not yet detected"), u.resolve(), u = new ya) } }), 0), c() } getToken() { const t = this.i, i = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(i).then((r => this.i !== t ? (dt("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : r ? (Xt(typeof r.accessToken == "string", 31837, { l: r }), new kA(r.accessToken, this.currentUser)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.o && this.auth.removeAuthTokenListener(this.o), this.o = void 0 } u() { const t = this.auth && this.auth.getUid(); return Xt(t === null || typeof t == "string", 2055, { h: t }), new un(t) } } class jO { constructor(t, i, r) { this.P = t, this.T = i, this.I = r, this.type = "FirstParty", this.user = un.FIRST_PARTY, this.R = new Map } A() { return this.I ? this.I() : null } get headers() { this.R.set("X-Goog-AuthUser", this.P); const t = this.A(); return t && this.R.set("Authorization", t), this.T && this.R.set("X-Goog-Iam-Authorization-Token", this.T), this.R } } class UO { constructor(t, i, r) { this.P = t, this.T = i, this.I = r } getToken() { return Promise.resolve(new jO(this.P, this.T, this.I)) } start(t, i) { t.enqueueRetryable((() => i(un.FIRST_PARTY))) } shutdown() { } invalidateToken() { } } class lT { constructor(t) { this.value = t, this.type = "AppCheck", this.headers = new Map, t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class BO { constructor(t, i) { this.V = i, this.forceRefresh = !1, this.appCheck = null, this.m = null, this.p = null, vO(t) && t.settings.appCheckToken && (this.p = t.settings.appCheckToken) } start(t, i) { Xt(this.o === void 0, 3512); const r = u => { u.error != null && dt("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${u.error.message}`); const c = u.token !== this.m; return this.m = u.token, dt("FirebaseAppCheckTokenProvider", `Received ${c ? "new" : "existing"} token.`), c ? i(u.token) : Promise.resolve() }; this.o = u => { t.enqueueRetryable((() => r(u))) }; const o = u => { dt("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = u, this.o && this.appCheck.addTokenListener(this.o) }; this.V.onInit((u => o(u))), setTimeout((() => { if (!this.appCheck) { const u = this.V.getImmediate({ optional: !0 }); u ? o(u) : dt("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }), 0) } getToken() { if (this.p) return Promise.resolve(new lT(this.p)); const t = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(t).then((i => i ? (Xt(typeof i.token == "string", 44558, { tokenResult: i }), this.m = i.token, new lT(i.token)) : null)) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.o && this.appCheck.removeTokenListener(this.o), this.o = void 0 } } function FO(e) { const t = typeof self < "u" && (self.crypto || self.msCrypto), i = new Uint8Array(e); if (t && typeof t.getRandomValues == "function") t.getRandomValues(i); else for (let r = 0; r < e; r++)i[r] = Math.floor(256 * Math.random()); return i } class oy { static newId() { const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", i = 62 * Math.floor(4.129032258064516); let r = ""; for (; r.length < 20;) { const o = FO(40); for (let u = 0; u < o.length; ++u)r.length < 20 && o[u] < i && (r += t.charAt(o[u] % 62)) } return r } } function jt(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function sg(e, t) { const i = Math.min(e.length, t.length); for (let r = 0; r < i; r++) { const o = e.charAt(r), u = t.charAt(r); if (o !== u) return Tp(o) === Tp(u) ? jt(o, u) : Tp(o) ? 1 : -1 } return jt(e.length, t.length) } const qO = 55296, HO = 57343; function Tp(e) { const t = e.charCodeAt(0); return t >= qO && t <= HO } function Mo(e, t, i) { return e.length === t.length && e.every(((r, o) => i(r, t[o]))) } const uT = "__name__"; class Bi { constructor(t, i, r) { i === void 0 ? i = 0 : i > t.length && At(637, { offset: i, range: t.length }), r === void 0 ? r = t.length - i : r > t.length - i && At(1746, { length: r, range: t.length - i }), this.segments = t, this.offset = i, this.len = r } get length() { return this.len } isEqual(t) { return Bi.comparator(this, t) === 0 } child(t) { const i = this.segments.slice(this.offset, this.limit()); return t instanceof Bi ? t.forEach((r => { i.push(r) })) : i.push(t), this.construct(i) } limit() { return this.offset + this.length } popFirst(t) { return t = t === void 0 ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(t) { return this.segments[this.offset + t] } isEmpty() { return this.length === 0 } isPrefixOf(t) { if (t.length < this.length) return !1; for (let i = 0; i < this.length; i++)if (this.get(i) !== t.get(i)) return !1; return !0 } isImmediateParentOf(t) { if (this.length + 1 !== t.length) return !1; for (let i = 0; i < this.length; i++)if (this.get(i) !== t.get(i)) return !1; return !0 } forEach(t) { for (let i = this.offset, r = this.limit(); i < r; i++)t(this.segments[i]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(t, i) { const r = Math.min(t.length, i.length); for (let o = 0; o < r; o++) { const u = Bi.compareSegments(t.get(o), i.get(o)); if (u !== 0) return u } return jt(t.length, i.length) } static compareSegments(t, i) { const r = Bi.isNumericId(t), o = Bi.isNumericId(i); return r && !o ? -1 : !r && o ? 1 : r && o ? Bi.extractNumericId(t).compare(Bi.extractNumericId(i)) : sg(t, i) } static isNumericId(t) { return t.startsWith("__id") && t.endsWith("__") } static extractNumericId(t) { return gr.fromString(t.substring(4, t.length - 2)) } } class oe extends Bi { construct(t, i, r) { return new oe(t, i, r) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } toUriEncodedString() { return this.toArray().map(encodeURIComponent).join("/") } static fromString(...t) { const i = []; for (const r of t) { if (r.indexOf("//") >= 0) throw new ft(nt.INVALID_ARGUMENT, `Invalid segment (${r}). Paths must not contain // in them.`); i.push(...r.split("/").filter((o => o.length > 0))) } return new oe(i) } static emptyPath() { return new oe([]) } } const GO = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class sn extends Bi { construct(t, i, r) { return new sn(t, i, r) } static isValidIdentifier(t) { return GO.test(t) } canonicalString() { return this.toArray().map((t => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), sn.isValidIdentifier(t) || (t = "`" + t + "`"), t))).join(".") } toString() { return this.canonicalString() } isKeyField() { return this.length === 1 && this.get(0) === uT } static keyField() { return new sn([uT]) } static fromServerFormat(t) { const i = []; let r = "", o = 0; const u = () => { if (r.length === 0) throw new ft(nt.INVALID_ARGUMENT, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`); i.push(r), r = "" }; let c = !1; for (; o < t.length;) { const d = t[o]; if (d === "\\") { if (o + 1 === t.length) throw new ft(nt.INVALID_ARGUMENT, "Path has trailing escape character: " + t); const p = t[o + 1]; if (p !== "\\" && p !== "." && p !== "`") throw new ft(nt.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t); r += p, o += 2 } else d === "`" ? (c = !c, o++) : d !== "." || c ? (r += d, o++) : (u(), o++) } if (u(), c) throw new ft(nt.INVALID_ARGUMENT, "Unterminated ` in path: " + t); return new sn(i) } static emptyPath() { return new sn([]) } } class bt { constructor(t) { this.path = t } static fromPath(t) { return new bt(oe.fromString(t)) } static fromName(t) { return new bt(oe.fromString(t).popFirst(5)) } static empty() { return new bt(oe.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(t) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === t } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(t) { return t !== null && oe.comparator(this.path, t.path) === 0 } toString() { return this.path.toString() } static comparator(t, i) { return oe.comparator(t.path, i.path) } static isDocumentKey(t) { return t.length % 2 == 0 } static fromSegments(t) { return new bt(new oe(t.slice())) } } function LA(e, t, i) { if (!i) throw new ft(nt.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`) } function YO(e, t, i, r) { if (t === !0 && r === !0) throw new ft(nt.INVALID_ARGUMENT, `${e} and ${i} cannot be used together.`) } function cT(e) { if (!bt.isDocumentKey(e)) throw new ft(nt.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`) } function hT(e) { if (bt.isDocumentKey(e)) throw new ft(nt.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`) } function zA(e) { return typeof e == "object" && e !== null && (Object.getPrototypeOf(e) === Object.prototype || Object.getPrototypeOf(e) === null) } function Mf(e) { if (e === void 0) return "undefined"; if (e === null) return "null"; if (typeof e == "string") return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e); if (typeof e == "number" || typeof e == "boolean") return "" + e; if (typeof e == "object") { if (e instanceof Array) return "an array"; { const t = (function (r) { return r.constructor ? r.constructor.name : null })(e); return t ? `a custom ${t} object` : "an object" } } return typeof e == "function" ? "a function" : At(12329, { type: typeof e }) } function Ts(e, t) { if ("_delegate" in e && (e = e._delegate), !(e instanceof t)) { if (t.name === e.constructor.name) throw new ft(nt.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const i = Mf(e); throw new ft(nt.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${i}`) } } return e } function je(e, t) { const i = { typeString: e }; return t && (i.value = t), i } function Bu(e, t) { if (!zA(e)) throw new ft(nt.INVALID_ARGUMENT, "JSON must be an object"); let i; for (const r in t) if (t[r]) { const o = t[r].typeString, u = "value" in t[r] ? { value: t[r].value } : void 0; if (!(r in e)) { i = `JSON missing required field: '${r}'`; break } const c = e[r]; if (o && typeof c !== o) { i = `JSON field '${r}' must be a ${o}.`; break } if (u !== void 0 && c !== u.value) { i = `Expected '${r}' field to equal '${u.value}'`; break } } if (i) throw new ft(nt.INVALID_ARGUMENT, i); return !0 } const fT = -62135596800, dT = 1e6; class he { static now() { return he.fromMillis(Date.now()) } static fromDate(t) { return he.fromMillis(t.getTime()) } static fromMillis(t) { const i = Math.floor(t / 1e3), r = Math.floor((t - 1e3 * i) * dT); return new he(i, r) } constructor(t, i) { if (this.seconds = t, this.nanoseconds = i, i < 0) throw new ft(nt.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + i); if (i >= 1e9) throw new ft(nt.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + i); if (t < fT) throw new ft(nt.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t); if (t >= 253402300800) throw new ft(nt.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / dT } _compareTo(t) { return this.seconds === t.seconds ? jt(this.nanoseconds, t.nanoseconds) : jt(this.seconds, t.seconds) } isEqual(t) { return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { type: he._jsonSchemaVersion, seconds: this.seconds, nanoseconds: this.nanoseconds } } static fromJSON(t) { if (Bu(t, he._jsonSchema)) return new he(t.seconds, t.nanoseconds) } valueOf() { const t = this.seconds - fT; return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } he._jsonSchemaVersion = "firestore/timestamp/1.0", he._jsonSchema = { type: je("string", he._jsonSchemaVersion), seconds: je("number"), nanoseconds: je("number") }; class wt { static fromTimestamp(t) { return new wt(t) } static min() { return new wt(new he(0, 0)) } static max() { return new wt(new he(253402300799, 999999999)) } constructor(t) { this.timestamp = t } compareTo(t) { return this.timestamp._compareTo(t.timestamp) } isEqual(t) { return this.timestamp.isEqual(t.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } const Ru = -1; function KO(e, t) { const i = e.toTimestamp().seconds, r = e.toTimestamp().nanoseconds + 1, o = wt.fromTimestamp(r === 1e9 ? new he(i + 1, 0) : new he(i, r)); return new Tr(o, bt.empty(), t) } function QO(e) { return new Tr(e.readTime, e.key, Ru) } class Tr { constructor(t, i, r) { this.readTime = t, this.documentKey = i, this.largestBatchId = r } static min() { return new Tr(wt.min(), bt.empty(), Ru) } static max() { return new Tr(wt.max(), bt.empty(), Ru) } } function XO(e, t) { let i = e.readTime.compareTo(t.readTime); return i !== 0 ? i : (i = bt.comparator(e.documentKey, t.documentKey), i !== 0 ? i : jt(e.largestBatchId, t.largestBatchId)) } const WO = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class $O { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(t) { this.onCommittedListeners.push(t) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach((t => t())) } } async function Go(e) { if (e.code !== nt.FAILED_PRECONDITION || e.message !== WO) throw e; dt("LocalStore", "Unexpectedly lost primary lease") } class st { constructor(t) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t((i => { this.isDone = !0, this.result = i, this.nextCallback && this.nextCallback(i) }), (i => { this.isDone = !0, this.error = i, this.catchCallback && this.catchCallback(i) })) } catch(t) { return this.next(void 0, t) } next(t, i) { return this.callbackAttached && At(59440), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(i, this.error) : this.wrapSuccess(t, this.result) : new st(((r, o) => { this.nextCallback = u => { this.wrapSuccess(t, u).next(r, o) }, this.catchCallback = u => { this.wrapFailure(i, u).next(r, o) } })) } toPromise() { return new Promise(((t, i) => { this.next(t, i) })) } wrapUserFunction(t) { try { const i = t(); return i instanceof st ? i : st.resolve(i) } catch (i) { return st.reject(i) } } wrapSuccess(t, i) { return t ? this.wrapUserFunction((() => t(i))) : st.resolve(i) } wrapFailure(t, i) { return t ? this.wrapUserFunction((() => t(i))) : st.reject(i) } static resolve(t) { return new st(((i, r) => { i(t) })) } static reject(t) { return new st(((i, r) => { r(t) })) } static waitFor(t) { return new st(((i, r) => { let o = 0, u = 0, c = !1; t.forEach((d => { ++o, d.next((() => { ++u, c && u === o && i() }), (p => r(p))) })), c = !0, u === o && i() })) } static or(t) { let i = st.resolve(!1); for (const r of t) i = i.next((o => o ? st.resolve(o) : r())); return i } static forEach(t, i) { const r = []; return t.forEach(((o, u) => { r.push(i.call(this, o, u)) })), this.waitFor(r) } static mapArray(t, i) { return new st(((r, o) => { const u = t.length, c = new Array(u); let d = 0; for (let p = 0; p < u; p++) { const g = p; i(t[g]).next((v => { c[g] = v, ++d, d === u && r(c) }), (v => o(v))) } })) } static doWhile(t, i) { return new st(((r, o) => { const u = () => { t() === !0 ? i().next((() => { u() }), o) : r() }; u() })) } } function ZO(e) { const t = e.match(/Android ([\d.]+)/i), i = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(i) } function Yo(e) { return e.name === "IndexedDbTransactionError" } class If { constructor(t, i) { this.previousValue = t, i && (i.sequenceNumberHandler = r => this.ae(r), this.ue = r => i.writeSequenceNumber(r)) } ae(t) { return this.previousValue = Math.max(t, this.previousValue), this.previousValue } next() { const t = ++this.previousValue; return this.ue && this.ue(t), t } } If.ce = -1; const ly = -1; function Of(e) { return e == null } function df(e) { return e === 0 && 1 / e == -1 / 0 } function JO(e) { return typeof e == "number" && Number.isInteger(e) && !df(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER } const jA = ""; function tN(e) { let t = ""; for (let i = 0; i < e.length; i++)t.length > 0 && (t = mT(t)), t = eN(e.get(i), t); return mT(t) } function eN(e, t) { let i = t; const r = e.length; for (let o = 0; o < r; o++) { const u = e.charAt(o); switch (u) { case "\0": i += ""; break; case jA: i += ""; break; default: i += u } } return i } function mT(e) { return e + jA + "" } function pT(e) { let t = 0; for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && t++; return t } function Dr(e, t) { for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && t(i, e[i]) } function UA(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } class ge { constructor(t, i) { this.comparator = t, this.root = i || nn.EMPTY } insert(t, i) { return new ge(this.comparator, this.root.insert(t, i, this.comparator).copy(null, null, nn.BLACK, null, null)) } remove(t) { return new ge(this.comparator, this.root.remove(t, this.comparator).copy(null, null, nn.BLACK, null, null)) } get(t) { let i = this.root; for (; !i.isEmpty();) { const r = this.comparator(t, i.key); if (r === 0) return i.value; r < 0 ? i = i.left : r > 0 && (i = i.right) } return null } indexOf(t) { let i = 0, r = this.root; for (; !r.isEmpty();) { const o = this.comparator(t, r.key); if (o === 0) return i + r.left.size; o < 0 ? r = r.left : (i += r.left.size + 1, r = r.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(t) { return this.root.inorderTraversal(t) } forEach(t) { this.inorderTraversal(((i, r) => (t(i, r), !1))) } toString() { const t = []; return this.inorderTraversal(((i, r) => (t.push(`${i}:${r}`), !1))), `{${t.join(", ")}}` } reverseTraversal(t) { return this.root.reverseTraversal(t) } getIterator() { return new Vh(this.root, null, this.comparator, !1) } getIteratorFrom(t) { return new Vh(this.root, t, this.comparator, !1) } getReverseIterator() { return new Vh(this.root, null, this.comparator, !0) } getReverseIteratorFrom(t) { return new Vh(this.root, t, this.comparator, !0) } } class Vh { constructor(t, i, r, o) { this.isReverse = o, this.nodeStack = []; let u = 1; for (; !t.isEmpty();)if (u = i ? r(t.key, i) : 1, i && o && (u *= -1), u < 0) t = this.isReverse ? t.left : t.right; else { if (u === 0) { this.nodeStack.push(t); break } this.nodeStack.push(t), t = this.isReverse ? t.right : t.left } } getNext() { let t = this.nodeStack.pop(); const i = { key: t.key, value: t.value }; if (this.isReverse) for (t = t.left; !t.isEmpty();)this.nodeStack.push(t), t = t.right; else for (t = t.right; !t.isEmpty();)this.nodeStack.push(t), t = t.left; return i } hasNext() { return this.nodeStack.length > 0 } peek() { if (this.nodeStack.length === 0) return null; const t = this.nodeStack[this.nodeStack.length - 1]; return { key: t.key, value: t.value } } } class nn { constructor(t, i, r, o, u) { this.key = t, this.value = i, this.color = r ?? nn.RED, this.left = o ?? nn.EMPTY, this.right = u ?? nn.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(t, i, r, o, u) { return new nn(t ?? this.key, i ?? this.value, r ?? this.color, o ?? this.left, u ?? this.right) } isEmpty() { return !1 } inorderTraversal(t) { return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t) } reverseTraversal(t) { return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(t, i, r) { let o = this; const u = r(t, o.key); return o = u < 0 ? o.copy(null, null, null, o.left.insert(t, i, r), null) : u === 0 ? o.copy(null, i, null, null, null) : o.copy(null, null, null, null, o.right.insert(t, i, r)), o.fixUp() } removeMin() { if (this.left.isEmpty()) return nn.EMPTY; let t = this; return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp() } remove(t, i) { let r, o = this; if (i(t, o.key) < 0) o.left.isEmpty() || o.left.isRed() || o.left.left.isRed() || (o = o.moveRedLeft()), o = o.copy(null, null, null, o.left.remove(t, i), null); else { if (o.left.isRed() && (o = o.rotateRight()), o.right.isEmpty() || o.right.isRed() || o.right.left.isRed() || (o = o.moveRedRight()), i(t, o.key) === 0) { if (o.right.isEmpty()) return nn.EMPTY; r = o.right.min(), o = o.copy(r.key, r.value, null, null, o.right.removeMin()) } o = o.copy(null, null, null, null, o.right.remove(t, i)) } return o.fixUp() } isRed() { return this.color } fixUp() { let t = this; return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t } moveRedLeft() { let t = this.colorFlip(); return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t } moveRedRight() { let t = this.colorFlip(); return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t } rotateLeft() { const t = this.copy(null, null, nn.RED, null, this.right.left); return this.right.copy(null, null, this.color, t, null) } rotateRight() { const t = this.copy(null, null, nn.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, t) } colorFlip() { const t = this.left.copy(null, null, !this.left.color, null, null), i = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, t, i) } checkMaxDepth() { const t = this.check(); return Math.pow(2, t) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed()) throw At(43730, { key: this.key, value: this.value }); if (this.right.isRed()) throw At(14113, { key: this.key, value: this.value }); const t = this.left.check(); if (t !== this.right.check()) throw At(27949); return t + (this.isRed() ? 0 : 1) } } nn.EMPTY = null, nn.RED = !0, nn.BLACK = !1; nn.EMPTY = new class { constructor() { this.size = 0 } get key() { throw At(57766) } get value() { throw At(16141) } get color() { throw At(16727) } get left() { throw At(29726) } get right() { throw At(36894) } copy(t, i, r, o, u) { return this } insert(t, i, r) { return new nn(t, i) } remove(t, i) { return this } isEmpty() { return !0 } inorderTraversal(t) { return !1 } reverseTraversal(t) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class He { constructor(t) { this.comparator = t, this.data = new ge(this.comparator) } has(t) { return this.data.get(t) !== null } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(t) { return this.data.indexOf(t) } forEach(t) { this.data.inorderTraversal(((i, r) => (t(i), !1))) } forEachInRange(t, i) { const r = this.data.getIteratorFrom(t[0]); for (; r.hasNext();) { const o = r.getNext(); if (this.comparator(o.key, t[1]) >= 0) return; i(o.key) } } forEachWhile(t, i) { let r; for (r = i !== void 0 ? this.data.getIteratorFrom(i) : this.data.getIterator(); r.hasNext();)if (!t(r.getNext().key)) return } firstAfterOrEqual(t) { const i = this.data.getIteratorFrom(t); return i.hasNext() ? i.getNext().key : null } getIterator() { return new gT(this.data.getIterator()) } getIteratorFrom(t) { return new gT(this.data.getIteratorFrom(t)) } add(t) { return this.copy(this.data.remove(t).insert(t, !0)) } delete(t) { return this.has(t) ? this.copy(this.data.remove(t)) : this } isEmpty() { return this.data.isEmpty() } unionWith(t) { let i = this; return i.size < t.size && (i = t, t = this), t.forEach((r => { i = i.add(r) })), i } isEqual(t) { if (!(t instanceof He) || this.size !== t.size) return !1; const i = this.data.getIterator(), r = t.data.getIterator(); for (; i.hasNext();) { const o = i.getNext().key, u = r.getNext().key; if (this.comparator(o, u) !== 0) return !1 } return !0 } toArray() { const t = []; return this.forEach((i => { t.push(i) })), t } toString() { const t = []; return this.forEach((i => t.push(i))), "SortedSet(" + t.toString() + ")" } copy(t) { const i = new He(this.comparator); return i.data = t, i } } class gT { constructor(t) { this.iter = t } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } class Pn { constructor(t) { this.fields = t, t.sort(sn.comparator) } static empty() { return new Pn([]) } unionWith(t) { let i = new He(sn.comparator); for (const r of this.fields) i = i.add(r); for (const r of t) i = i.add(r); return new Pn(i.toArray()) } covers(t) { for (const i of this.fields) if (i.isPrefixOf(t)) return !0; return !1 } isEqual(t) { return Mo(this.fields, t.fields, ((i, r) => i.isEqual(r))) } } class BA extends Error { constructor() { super(...arguments), this.name = "Base64DecodeError" } } class an { constructor(t) { this.binaryString = t } static fromBase64String(t) { const i = (function (o) { try { return atob(o) } catch (u) { throw typeof DOMException < "u" && u instanceof DOMException ? new BA("Invalid base64 string: " + u) : u } })(t); return new an(i) } static fromUint8Array(t) { const i = (function (o) { let u = ""; for (let c = 0; c < o.length; ++c)u += String.fromCharCode(o[c]); return u })(t); return new an(i) } [Symbol.iterator]() { let t = 0; return { next: () => t < this.binaryString.length ? { value: this.binaryString.charCodeAt(t++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return (function (i) { return btoa(i) })(this.binaryString) } toUint8Array() { return (function (i) { const r = new Uint8Array(i.length); for (let o = 0; o < i.length; o++)r[o] = i.charCodeAt(o); return r })(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(t) { return jt(this.binaryString, t.binaryString) } isEqual(t) { return this.binaryString === t.binaryString } } an.EMPTY_BYTE_STRING = new an(""); const nN = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function Er(e) { if (Xt(!!e, 39018), typeof e == "string") { let t = 0; const i = nN.exec(e); if (Xt(!!i, 46558, { timestamp: e }), i[1]) { let o = i[1]; o = (o + "000000000").substr(0, 9), t = Number(o) } const r = new Date(e); return { seconds: Math.floor(r.getTime() / 1e3), nanos: t } } return { seconds: we(e.seconds), nanos: we(e.nanos) } } function we(e) { return typeof e == "number" ? e : typeof e == "string" ? Number(e) : 0 } function Sr(e) { return typeof e == "string" ? an.fromBase64String(e) : an.fromUint8Array(e) } const FA = "server_timestamp", qA = "__type__", HA = "__previous_value__", GA = "__local_write_time__"; function uy(e) { return (e?.mapValue?.fields || {})[qA]?.stringValue === FA } function Nf(e) { const t = e.mapValue.fields[HA]; return uy(t) ? Nf(t) : t } function Du(e) { const t = Er(e.mapValue.fields[GA].timestampValue); return new he(t.seconds, t.nanos) } class iN { constructor(t, i, r, o, u, c, d, p, g, v, b) { this.databaseId = t, this.appId = i, this.persistenceKey = r, this.host = o, this.ssl = u, this.forceLongPolling = c, this.autoDetectLongPolling = d, this.longPollingOptions = p, this.useFetchStreams = g, this.isUsingEmulator = v, this.apiKey = b } } const mf = "(default)"; class Vu { constructor(t, i) { this.projectId = t, this.database = i || mf } static empty() { return new Vu("", "") } get isDefaultDatabase() { return this.database === mf } isEqual(t) { return t instanceof Vu && t.projectId === this.projectId && t.database === this.database } } function sN(e, t) { if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"])) throw new ft(nt.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new Vu(e.options.projectId, t) } const YA = "__type__", rN = "__max__", Mh = { mapValue: {} }, KA = "__vector__", pf = "value"; function Ar(e) { return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? uy(e) ? 4 : oN(e) ? 9007199254740991 : aN(e) ? 10 : 11 : At(28295, { value: e }) } function $i(e, t) { if (e === t) return !0; const i = Ar(e); if (i !== Ar(t)) return !1; switch (i) { case 0: case 9007199254740991: return !0; case 1: return e.booleanValue === t.booleanValue; case 4: return Du(e).isEqual(Du(t)); case 3: return (function (o, u) { if (typeof o.timestampValue == "string" && typeof u.timestampValue == "string" && o.timestampValue.length === u.timestampValue.length) return o.timestampValue === u.timestampValue; const c = Er(o.timestampValue), d = Er(u.timestampValue); return c.seconds === d.seconds && c.nanos === d.nanos })(e, t); case 5: return e.stringValue === t.stringValue; case 6: return (function (o, u) { return Sr(o.bytesValue).isEqual(Sr(u.bytesValue)) })(e, t); case 7: return e.referenceValue === t.referenceValue; case 8: return (function (o, u) { return we(o.geoPointValue.latitude) === we(u.geoPointValue.latitude) && we(o.geoPointValue.longitude) === we(u.geoPointValue.longitude) })(e, t); case 2: return (function (o, u) { if ("integerValue" in o && "integerValue" in u) return we(o.integerValue) === we(u.integerValue); if ("doubleValue" in o && "doubleValue" in u) { const c = we(o.doubleValue), d = we(u.doubleValue); return c === d ? df(c) === df(d) : isNaN(c) && isNaN(d) } return !1 })(e, t); case 9: return Mo(e.arrayValue.values || [], t.arrayValue.values || [], $i); case 10: case 11: return (function (o, u) { const c = o.mapValue.fields || {}, d = u.mapValue.fields || {}; if (pT(c) !== pT(d)) return !1; for (const p in c) if (c.hasOwnProperty(p) && (d[p] === void 0 || !$i(c[p], d[p]))) return !1; return !0 })(e, t); default: return At(52216, { left: e }) } } function Mu(e, t) { return (e.values || []).find((i => $i(i, t))) !== void 0 } function Io(e, t) { if (e === t) return 0; const i = Ar(e), r = Ar(t); if (i !== r) return jt(i, r); switch (i) { case 0: case 9007199254740991: return 0; case 1: return jt(e.booleanValue, t.booleanValue); case 2: return (function (u, c) { const d = we(u.integerValue || u.doubleValue), p = we(c.integerValue || c.doubleValue); return d < p ? -1 : d > p ? 1 : d === p ? 0 : isNaN(d) ? isNaN(p) ? 0 : -1 : 1 })(e, t); case 3: return yT(e.timestampValue, t.timestampValue); case 4: return yT(Du(e), Du(t)); case 5: return sg(e.stringValue, t.stringValue); case 6: return (function (u, c) { const d = Sr(u), p = Sr(c); return d.compareTo(p) })(e.bytesValue, t.bytesValue); case 7: return (function (u, c) { const d = u.split("/"), p = c.split("/"); for (let g = 0; g < d.length && g < p.length; g++) { const v = jt(d[g], p[g]); if (v !== 0) return v } return jt(d.length, p.length) })(e.referenceValue, t.referenceValue); case 8: return (function (u, c) { const d = jt(we(u.latitude), we(c.latitude)); return d !== 0 ? d : jt(we(u.longitude), we(c.longitude)) })(e.geoPointValue, t.geoPointValue); case 9: return vT(e.arrayValue, t.arrayValue); case 10: return (function (u, c) { const d = u.fields || {}, p = c.fields || {}, g = d[pf]?.arrayValue, v = p[pf]?.arrayValue, b = jt(g?.values?.length || 0, v?.values?.length || 0); return b !== 0 ? b : vT(g, v) })(e.mapValue, t.mapValue); case 11: return (function (u, c) { if (u === Mh.mapValue && c === Mh.mapValue) return 0; if (u === Mh.mapValue) return 1; if (c === Mh.mapValue) return -1; const d = u.fields || {}, p = Object.keys(d), g = c.fields || {}, v = Object.keys(g); p.sort(), v.sort(); for (let b = 0; b < p.length && b < v.length; ++b) { const E = sg(p[b], v[b]); if (E !== 0) return E; const x = Io(d[p[b]], g[v[b]]); if (x !== 0) return x } return jt(p.length, v.length) })(e.mapValue, t.mapValue); default: throw At(23264, { he: i }) } } function yT(e, t) { if (typeof e == "string" && typeof t == "string" && e.length === t.length) return jt(e, t); const i = Er(e), r = Er(t), o = jt(i.seconds, r.seconds); return o !== 0 ? o : jt(i.nanos, r.nanos) } function vT(e, t) { const i = e.values || [], r = t.values || []; for (let o = 0; o < i.length && o < r.length; ++o) { const u = Io(i[o], r[o]); if (u) return u } return jt(i.length, r.length) } function Oo(e) { return rg(e) } function rg(e) { return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? (function (i) { const r = Er(i); return `time(${r.seconds},${r.nanos})` })(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? (function (i) { return Sr(i).toBase64() })(e.bytesValue) : "referenceValue" in e ? (function (i) { return bt.fromName(i).toString() })(e.referenceValue) : "geoPointValue" in e ? (function (i) { return `geo(${i.latitude},${i.longitude})` })(e.geoPointValue) : "arrayValue" in e ? (function (i) { let r = "[", o = !0; for (const u of i.values || []) o ? o = !1 : r += ",", r += rg(u); return r + "]" })(e.arrayValue) : "mapValue" in e ? (function (i) { const r = Object.keys(i.fields || {}).sort(); let o = "{", u = !0; for (const c of r) u ? u = !1 : o += ",", o += `${c}:${rg(i.fields[c])}`; return o + "}" })(e.mapValue) : At(61005, { value: e }) } function qh(e) { switch (Ar(e)) { case 0: case 1: return 4; case 2: return 8; case 3: case 8: return 16; case 4: const t = Nf(e); return t ? 16 + qh(t) : 16; case 5: return 2 * e.stringValue.length; case 6: return Sr(e.bytesValue).approximateByteSize(); case 7: return e.referenceValue.length; case 9: return (function (r) { return (r.values || []).reduce(((o, u) => o + qh(u)), 0) })(e.arrayValue); case 10: case 11: return (function (r) { let o = 0; return Dr(r.fields, ((u, c) => { o += u.length + qh(c) })), o })(e.mapValue); default: throw At(13486, { value: e }) } } function _T(e, t) { return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` } } function ag(e) { return !!e && "integerValue" in e } function cy(e) { return !!e && "arrayValue" in e } function bT(e) { return !!e && "nullValue" in e } function TT(e) { return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue)) } function Hh(e) { return !!e && "mapValue" in e } function aN(e) { return (e?.mapValue?.fields || {})[YA]?.stringValue === KA } function gu(e) { if (e.geoPointValue) return { geoPointValue: { ...e.geoPointValue } }; if (e.timestampValue && typeof e.timestampValue == "object") return { timestampValue: { ...e.timestampValue } }; if (e.mapValue) { const t = { mapValue: { fields: {} } }; return Dr(e.mapValue.fields, ((i, r) => t.mapValue.fields[i] = gu(r))), t } if (e.arrayValue) { const t = { arrayValue: { values: [] } }; for (let i = 0; i < (e.arrayValue.values || []).length; ++i)t.arrayValue.values[i] = gu(e.arrayValue.values[i]); return t } return { ...e } } function oN(e) { return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === rN } class wn { constructor(t) { this.value = t } static empty() { return new wn({ mapValue: {} }) } field(t) { if (t.isEmpty()) return this.value; { let i = this.value; for (let r = 0; r < t.length - 1; ++r)if (i = (i.mapValue.fields || {})[t.get(r)], !Hh(i)) return null; return i = (i.mapValue.fields || {})[t.lastSegment()], i || null } } set(t, i) { this.getFieldsMap(t.popLast())[t.lastSegment()] = gu(i) } setAll(t) { let i = sn.emptyPath(), r = {}, o = []; t.forEach(((c, d) => { if (!i.isImmediateParentOf(d)) { const p = this.getFieldsMap(i); this.applyChanges(p, r, o), r = {}, o = [], i = d.popLast() } c ? r[d.lastSegment()] = gu(c) : o.push(d.lastSegment()) })); const u = this.getFieldsMap(i); this.applyChanges(u, r, o) } delete(t) { const i = this.field(t.popLast()); Hh(i) && i.mapValue.fields && delete i.mapValue.fields[t.lastSegment()] } isEqual(t) { return $i(this.value, t.value) } getFieldsMap(t) { let i = this.value; i.mapValue.fields || (i.mapValue = { fields: {} }); for (let r = 0; r < t.length; ++r) { let o = i.mapValue.fields[t.get(r)]; Hh(o) && o.mapValue.fields || (o = { mapValue: { fields: {} } }, i.mapValue.fields[t.get(r)] = o), i = o } return i.mapValue.fields } applyChanges(t, i, r) { Dr(i, ((o, u) => t[o] = u)); for (const o of r) delete t[o] } clone() { return new wn(gu(this.value)) } } function QA(e) { const t = []; return Dr(e.fields, ((i, r) => { const o = new sn([i]); if (Hh(r)) { const u = QA(r.mapValue).fields; if (u.length === 0) t.push(o); else for (const c of u) t.push(o.child(c)) } else t.push(o) })), new Pn(t) } class cn { constructor(t, i, r, o, u, c, d) { this.key = t, this.documentType = i, this.version = r, this.readTime = o, this.createTime = u, this.data = c, this.documentState = d } static newInvalidDocument(t) { return new cn(t, 0, wt.min(), wt.min(), wt.min(), wn.empty(), 0) } static newFoundDocument(t, i, r, o) { return new cn(t, 1, i, wt.min(), r, o, 0) } static newNoDocument(t, i) { return new cn(t, 2, i, wt.min(), wt.min(), wn.empty(), 0) } static newUnknownDocument(t, i) { return new cn(t, 3, i, wt.min(), wt.min(), wn.empty(), 2) } convertToFoundDocument(t, i) { return !this.createTime.isEqual(wt.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = t), this.version = t, this.documentType = 1, this.data = i, this.documentState = 0, this } convertToNoDocument(t) { return this.version = t, this.documentType = 2, this.data = wn.empty(), this.documentState = 0, this } convertToUnknownDocument(t) { return this.version = t, this.documentType = 3, this.data = wn.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = wt.min(), this } setReadTime(t) { return this.readTime = t, this } get hasLocalMutations() { return this.documentState === 1 } get hasCommittedMutations() { return this.documentState === 2 } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return this.documentType !== 0 } isFoundDocument() { return this.documentType === 1 } isNoDocument() { return this.documentType === 2 } isUnknownDocument() { return this.documentType === 3 } isEqual(t) { return t instanceof cn && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data) } mutableCopy() { return new cn(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState) } toString() { return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})` } } class gf { constructor(t, i) { this.position = t, this.inclusive = i } } function ET(e, t, i) { let r = 0; for (let o = 0; o < e.position.length; o++) { const u = t[o], c = e.position[o]; if (u.field.isKeyField() ? r = bt.comparator(bt.fromName(c.referenceValue), i.key) : r = Io(c, i.data.field(u.field)), u.dir === "desc" && (r *= -1), r !== 0) break } return r } function ST(e, t) { if (e === null) return t === null; if (t === null || e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1; for (let i = 0; i < e.position.length; i++)if (!$i(e.position[i], t.position[i])) return !1; return !0 } class Iu { constructor(t, i = "asc") { this.field = t, this.dir = i } } function lN(e, t) { return e.dir === t.dir && e.field.isEqual(t.field) } class XA { } class ze extends XA { constructor(t, i, r) { super(), this.field = t, this.op = i, this.value = r } static create(t, i, r) { return t.isKeyField() ? i === "in" || i === "not-in" ? this.createKeyFieldInFilter(t, i, r) : new cN(t, i, r) : i === "array-contains" ? new dN(t, r) : i === "in" ? new mN(t, r) : i === "not-in" ? new pN(t, r) : i === "array-contains-any" ? new gN(t, r) : new ze(t, i, r) } static createKeyFieldInFilter(t, i, r) { return i === "in" ? new hN(t, r) : new fN(t, r) } matches(t) { const i = t.data.field(this.field); return this.op === "!=" ? i !== null && i.nullValue === void 0 && this.matchesComparison(Io(i, this.value)) : i !== null && Ar(this.value) === Ar(i) && this.matchesComparison(Io(i, this.value)) } matchesComparison(t) { switch (this.op) { case "<": return t < 0; case "<=": return t <= 0; case "==": return t === 0; case "!=": return t !== 0; case ">": return t > 0; case ">=": return t >= 0; default: return At(47266, { operator: this.op }) } } isInequality() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } getFlattenedFilters() { return [this] } getFilters() { return [this] } } class gi extends XA { constructor(t, i) { super(), this.filters = t, this.op = i, this.Pe = null } static create(t, i) { return new gi(t, i) } matches(t) { return WA(this) ? this.filters.find((i => !i.matches(t))) === void 0 : this.filters.find((i => i.matches(t))) !== void 0 } getFlattenedFilters() { return this.Pe !== null || (this.Pe = this.filters.reduce(((t, i) => t.concat(i.getFlattenedFilters())), [])), this.Pe } getFilters() { return Object.assign([], this.filters) } } function WA(e) { return e.op === "and" } function $A(e) { return uN(e) && WA(e) } function uN(e) { for (const t of e.filters) if (t instanceof gi) return !1; return !0 } function og(e) { if (e instanceof ze) return e.field.canonicalString() + e.op.toString() + Oo(e.value); if ($A(e)) return e.filters.map((t => og(t))).join(","); { const t = e.filters.map((i => og(i))).join(","); return `${e.op}(${t})` } } function ZA(e, t) { return e instanceof ze ? (function (r, o) { return o instanceof ze && r.op === o.op && r.field.isEqual(o.field) && $i(r.value, o.value) })(e, t) : e instanceof gi ? (function (r, o) { return o instanceof gi && r.op === o.op && r.filters.length === o.filters.length ? r.filters.reduce(((u, c, d) => u && ZA(c, o.filters[d])), !0) : !1 })(e, t) : void At(19439) } function JA(e) { return e instanceof ze ? (function (i) { return `${i.field.canonicalString()} ${i.op} ${Oo(i.value)}` })(e) : e instanceof gi ? (function (i) { return i.op.toString() + " {" + i.getFilters().map(JA).join(" ,") + "}" })(e) : "Filter" } class cN extends ze { constructor(t, i, r) { super(t, i, r), this.key = bt.fromName(r.referenceValue) } matches(t) { const i = bt.comparator(t.key, this.key); return this.matchesComparison(i) } } class hN extends ze { constructor(t, i) { super(t, "in", i), this.keys = tw("in", i) } matches(t) { return this.keys.some((i => i.isEqual(t.key))) } } class fN extends ze { constructor(t, i) { super(t, "not-in", i), this.keys = tw("not-in", i) } matches(t) { return !this.keys.some((i => i.isEqual(t.key))) } } function tw(e, t) { return (t.arrayValue?.values || []).map((i => bt.fromName(i.referenceValue))) } class dN extends ze { constructor(t, i) { super(t, "array-contains", i) } matches(t) { const i = t.data.field(this.field); return cy(i) && Mu(i.arrayValue, this.value) } } class mN extends ze { constructor(t, i) { super(t, "in", i) } matches(t) { const i = t.data.field(this.field); return i !== null && Mu(this.value.arrayValue, i) } } class pN extends ze { constructor(t, i) { super(t, "not-in", i) } matches(t) { if (Mu(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const i = t.data.field(this.field); return i !== null && i.nullValue === void 0 && !Mu(this.value.arrayValue, i) } } class gN extends ze { constructor(t, i) { super(t, "array-contains-any", i) } matches(t) { const i = t.data.field(this.field); return !(!cy(i) || !i.arrayValue.values) && i.arrayValue.values.some((r => Mu(this.value.arrayValue, r))) } } class yN { constructor(t, i = null, r = [], o = [], u = null, c = null, d = null) { this.path = t, this.collectionGroup = i, this.orderBy = r, this.filters = o, this.limit = u, this.startAt = c, this.endAt = d, this.Te = null } } function AT(e, t = null, i = [], r = [], o = null, u = null, c = null) { return new yN(e, t, i, r, o, u, c) } function hy(e) { const t = Dt(e); if (t.Te === null) { let i = t.path.canonicalString(); t.collectionGroup !== null && (i += "|cg:" + t.collectionGroup), i += "|f:", i += t.filters.map((r => og(r))).join(","), i += "|ob:", i += t.orderBy.map((r => (function (u) { return u.field.canonicalString() + u.dir })(r))).join(","), Of(t.limit) || (i += "|l:", i += t.limit), t.startAt && (i += "|lb:", i += t.startAt.inclusive ? "b:" : "a:", i += t.startAt.position.map((r => Oo(r))).join(",")), t.endAt && (i += "|ub:", i += t.endAt.inclusive ? "a:" : "b:", i += t.endAt.position.map((r => Oo(r))).join(",")), t.Te = i } return t.Te } function fy(e, t) { if (e.limit !== t.limit || e.orderBy.length !== t.orderBy.length) return !1; for (let i = 0; i < e.orderBy.length; i++)if (!lN(e.orderBy[i], t.orderBy[i])) return !1; if (e.filters.length !== t.filters.length) return !1; for (let i = 0; i < e.filters.length; i++)if (!ZA(e.filters[i], t.filters[i])) return !1; return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!ST(e.startAt, t.startAt) && ST(e.endAt, t.endAt) } function lg(e) { return bt.isDocumentKey(e.path) && e.collectionGroup === null && e.filters.length === 0 } class Ko { constructor(t, i = null, r = [], o = [], u = null, c = "F", d = null, p = null) { this.path = t, this.collectionGroup = i, this.explicitOrderBy = r, this.filters = o, this.limit = u, this.limitType = c, this.startAt = d, this.endAt = p, this.Ie = null, this.Ee = null, this.Re = null, this.startAt, this.endAt } } function vN(e, t, i, r, o, u, c, d) { return new Ko(e, t, i, r, o, u, c, d) } function dy(e) { return new Ko(e) } function wT(e) { return e.filters.length === 0 && e.limit === null && e.startAt == null && e.endAt == null && (e.explicitOrderBy.length === 0 || e.explicitOrderBy.length === 1 && e.explicitOrderBy[0].field.isKeyField()) } function _N(e) { return bt.isDocumentKey(e.path) && e.collectionGroup === null && e.filters.length === 0 } function ew(e) { return e.collectionGroup !== null } function yu(e) { const t = Dt(e); if (t.Ie === null) { t.Ie = []; const i = new Set; for (const u of t.explicitOrderBy) t.Ie.push(u), i.add(u.field.canonicalString()); const r = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc"; (function (c) { let d = new He(sn.comparator); return c.filters.forEach((p => { p.getFlattenedFilters().forEach((g => { g.isInequality() && (d = d.add(g.field)) })) })), d })(t).forEach((u => { i.has(u.canonicalString()) || u.isKeyField() || t.Ie.push(new Iu(u, r)) })), i.has(sn.keyField().canonicalString()) || t.Ie.push(new Iu(sn.keyField(), r)) } return t.Ie } function Yi(e) { const t = Dt(e); return t.Ee || (t.Ee = bN(t, yu(e))), t.Ee } function bN(e, t) { if (e.limitType === "F") return AT(e.path, e.collectionGroup, t, e.filters, e.limit, e.startAt, e.endAt); { t = t.map((o => { const u = o.dir === "desc" ? "asc" : "desc"; return new Iu(o.field, u) })); const i = e.endAt ? new gf(e.endAt.position, e.endAt.inclusive) : null, r = e.startAt ? new gf(e.startAt.position, e.startAt.inclusive) : null; return AT(e.path, e.collectionGroup, t, e.filters, e.limit, i, r) } } function ug(e, t) { const i = e.filters.concat([t]); return new Ko(e.path, e.collectionGroup, e.explicitOrderBy.slice(), i, e.limit, e.limitType, e.startAt, e.endAt) } function TN(e, t) { const i = e.explicitOrderBy.concat([t]); return new Ko(e.path, e.collectionGroup, i, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) } function yf(e, t, i) { return new Ko(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, i, e.startAt, e.endAt) } function Pf(e, t) { return fy(Yi(e), Yi(t)) && e.limitType === t.limitType } function nw(e) { return `${hy(Yi(e))}|lt:${e.limitType}` } function yo(e) { return `Query(target=${(function (i) { let r = i.path.canonicalString(); return i.collectionGroup !== null && (r += " collectionGroup=" + i.collectionGroup), i.filters.length > 0 && (r += `, filters: [${i.filters.map((o => JA(o))).join(", ")}]`), Of(i.limit) || (r += ", limit: " + i.limit), i.orderBy.length > 0 && (r += `, orderBy: [${i.orderBy.map((o => (function (c) { return `${c.field.canonicalString()} (${c.dir})` })(o))).join(", ")}]`), i.startAt && (r += ", startAt: ", r += i.startAt.inclusive ? "b:" : "a:", r += i.startAt.position.map((o => Oo(o))).join(",")), i.endAt && (r += ", endAt: ", r += i.endAt.inclusive ? "a:" : "b:", r += i.endAt.position.map((o => Oo(o))).join(",")), `Target(${r})` })(Yi(e))}; limitType=${e.limitType})` } function kf(e, t) { return t.isFoundDocument() && (function (r, o) { const u = o.key.path; return r.collectionGroup !== null ? o.key.hasCollectionId(r.collectionGroup) && r.path.isPrefixOf(u) : bt.isDocumentKey(r.path) ? r.path.isEqual(u) : r.path.isImmediateParentOf(u) })(e, t) && (function (r, o) { for (const u of yu(r)) if (!u.field.isKeyField() && o.data.field(u.field) === null) return !1; return !0 })(e, t) && (function (r, o) { for (const u of r.filters) if (!u.matches(o)) return !1; return !0 })(e, t) && (function (r, o) { return !(r.startAt && !(function (c, d, p) { const g = ET(c, d, p); return c.inclusive ? g <= 0 : g < 0 })(r.startAt, yu(r), o) || r.endAt && !(function (c, d, p) { const g = ET(c, d, p); return c.inclusive ? g >= 0 : g > 0 })(r.endAt, yu(r), o)) })(e, t) } function EN(e) { return e.collectionGroup || (e.path.length % 2 == 1 ? e.path.lastSegment() : e.path.get(e.path.length - 2)) } function iw(e) { return (t, i) => { let r = !1; for (const o of yu(e)) { const u = SN(o, t, i); if (u !== 0) return u; r = r || o.field.isKeyField() } return 0 } } function SN(e, t, i) { const r = e.field.isKeyField() ? bt.comparator(t.key, i.key) : (function (u, c, d) { const p = c.data.field(u), g = d.data.field(u); return p !== null && g !== null ? Io(p, g) : At(42886) })(e.field, t, i); switch (e.dir) { case "asc": return r; case "desc": return -1 * r; default: return At(19790, { direction: e.dir }) } } class Ea { constructor(t, i) { this.mapKeyFn = t, this.equalsFn = i, this.inner = {}, this.innerSize = 0 } get(t) { const i = this.mapKeyFn(t), r = this.inner[i]; if (r !== void 0) { for (const [o, u] of r) if (this.equalsFn(o, t)) return u } } has(t) { return this.get(t) !== void 0 } set(t, i) { const r = this.mapKeyFn(t), o = this.inner[r]; if (o === void 0) return this.inner[r] = [[t, i]], void this.innerSize++; for (let u = 0; u < o.length; u++)if (this.equalsFn(o[u][0], t)) return void (o[u] = [t, i]); o.push([t, i]), this.innerSize++ } delete(t) { const i = this.mapKeyFn(t), r = this.inner[i]; if (r === void 0) return !1; for (let o = 0; o < r.length; o++)if (this.equalsFn(r[o][0], t)) return r.length === 1 ? delete this.inner[i] : r.splice(o, 1), this.innerSize--, !0; return !1 } forEach(t) { Dr(this.inner, ((i, r) => { for (const [o, u] of r) t(o, u) })) } isEmpty() { return UA(this.inner) } size() { return this.innerSize } } const AN = new ge(bt.comparator); function xs() { return AN } const sw = new ge(bt.comparator); function lu(...e) { let t = sw; for (const i of e) t = t.insert(i.key, i); return t } function rw(e) { let t = sw; return e.forEach(((i, r) => t = t.insert(i, r.overlayedDocument))), t } function pa() { return vu() } function aw() { return vu() } function vu() { return new Ea((e => e.toString()), ((e, t) => e.isEqual(t))) } const wN = new ge(bt.comparator), xN = new He(bt.comparator); function Ut(...e) { let t = xN; for (const i of e) t = t.add(i); return t } const CN = new He(jt); function RN() { return CN } function my(e, t) { if (e.useProto3Json) { if (isNaN(t)) return { doubleValue: "NaN" }; if (t === 1 / 0) return { doubleValue: "Infinity" }; if (t === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: df(t) ? "-0" : t } } function ow(e) { return { integerValue: "" + e } } function DN(e, t) { return JO(t) ? ow(t) : my(e, t) } class Lf { constructor() { this._ = void 0 } } function VN(e, t, i) { return e instanceof Ou ? (function (o, u) { const c = { fields: { [qA]: { stringValue: FA }, [GA]: { timestampValue: { seconds: o.seconds, nanos: o.nanoseconds } } } }; return u && uy(u) && (u = Nf(u)), u && (c.fields[HA] = u), { mapValue: c } })(i, t) : e instanceof Nu ? uw(e, t) : e instanceof Pu ? cw(e, t) : (function (o, u) { const c = lw(o, u), d = xT(c) + xT(o.Ae); return ag(c) && ag(o.Ae) ? ow(d) : my(o.serializer, d) })(e, t) } function MN(e, t, i) { return e instanceof Nu ? uw(e, t) : e instanceof Pu ? cw(e, t) : i } function lw(e, t) { return e instanceof vf ? (function (r) { return ag(r) || (function (u) { return !!u && "doubleValue" in u })(r) })(t) ? t : { integerValue: 0 } : null } class Ou extends Lf { } class Nu extends Lf { constructor(t) { super(), this.elements = t } } function uw(e, t) { const i = hw(t); for (const r of e.elements) i.some((o => $i(o, r))) || i.push(r); return { arrayValue: { values: i } } } class Pu extends Lf { constructor(t) { super(), this.elements = t } } function cw(e, t) { let i = hw(t); for (const r of e.elements) i = i.filter((o => !$i(o, r))); return { arrayValue: { values: i } } } class vf extends Lf { constructor(t, i) { super(), this.serializer = t, this.Ae = i } } function xT(e) { return we(e.integerValue || e.doubleValue) } function hw(e) { return cy(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [] } class IN { constructor(t, i) { this.field = t, this.transform = i } } function ON(e, t) { return e.field.isEqual(t.field) && (function (r, o) { return r instanceof Nu && o instanceof Nu || r instanceof Pu && o instanceof Pu ? Mo(r.elements, o.elements, $i) : r instanceof vf && o instanceof vf ? $i(r.Ae, o.Ae) : r instanceof Ou && o instanceof Ou })(e.transform, t.transform) } class NN { constructor(t, i) { this.version = t, this.transformResults = i } } class mi { constructor(t, i) { this.updateTime = t, this.exists = i } static none() { return new mi } static exists(t) { return new mi(void 0, t) } static updateTime(t) { return new mi(t) } get isNone() { return this.updateTime === void 0 && this.exists === void 0 } isEqual(t) { return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime) } } function Gh(e, t) { return e.updateTime !== void 0 ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : e.exists === void 0 || e.exists === t.isFoundDocument() } class zf { } function fw(e, t) { if (!e.hasLocalMutations || t && t.fields.length === 0) return null; if (t === null) return e.isNoDocument() ? new mw(e.key, mi.none()) : new Fu(e.key, e.data, mi.none()); { const i = e.data, r = wn.empty(); let o = new He(sn.comparator); for (let u of t.fields) if (!o.has(u)) { let c = i.field(u); c === null && u.length > 1 && (u = u.popLast(), c = i.field(u)), c === null ? r.delete(u) : r.set(u, c), o = o.add(u) } return new Vr(e.key, r, new Pn(o.toArray()), mi.none()) } } function PN(e, t, i) { e instanceof Fu ? (function (o, u, c) { const d = o.value.clone(), p = RT(o.fieldTransforms, u, c.transformResults); d.setAll(p), u.convertToFoundDocument(c.version, d).setHasCommittedMutations() })(e, t, i) : e instanceof Vr ? (function (o, u, c) { if (!Gh(o.precondition, u)) return void u.convertToUnknownDocument(c.version); const d = RT(o.fieldTransforms, u, c.transformResults), p = u.data; p.setAll(dw(o)), p.setAll(d), u.convertToFoundDocument(c.version, p).setHasCommittedMutations() })(e, t, i) : (function (o, u, c) { u.convertToNoDocument(c.version).setHasCommittedMutations() })(0, t, i) } function _u(e, t, i, r) { return e instanceof Fu ? (function (u, c, d, p) { if (!Gh(u.precondition, c)) return d; const g = u.value.clone(), v = DT(u.fieldTransforms, p, c); return g.setAll(v), c.convertToFoundDocument(c.version, g).setHasLocalMutations(), null })(e, t, i, r) : e instanceof Vr ? (function (u, c, d, p) { if (!Gh(u.precondition, c)) return d; const g = DT(u.fieldTransforms, p, c), v = c.data; return v.setAll(dw(u)), v.setAll(g), c.convertToFoundDocument(c.version, v).setHasLocalMutations(), d === null ? null : d.unionWith(u.fieldMask.fields).unionWith(u.fieldTransforms.map((b => b.field))) })(e, t, i, r) : (function (u, c, d) { return Gh(u.precondition, c) ? (c.convertToNoDocument(c.version).setHasLocalMutations(), null) : d })(e, t, i) } function kN(e, t) { let i = null; for (const r of e.fieldTransforms) { const o = t.data.field(r.field), u = lw(r.transform, o || null); u != null && (i === null && (i = wn.empty()), i.set(r.field, u)) } return i || null } function CT(e, t) { return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && !!(function (r, o) { return r === void 0 && o === void 0 || !(!r || !o) && Mo(r, o, ((u, c) => ON(u, c))) })(e.fieldTransforms, t.fieldTransforms) && (e.type === 0 ? e.value.isEqual(t.value) : e.type !== 1 || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)) } class Fu extends zf { constructor(t, i, r, o = []) { super(), this.key = t, this.value = i, this.precondition = r, this.fieldTransforms = o, this.type = 0 } getFieldMask() { return null } } class Vr extends zf { constructor(t, i, r, o, u = []) { super(), this.key = t, this.data = i, this.fieldMask = r, this.precondition = o, this.fieldTransforms = u, this.type = 1 } getFieldMask() { return this.fieldMask } } function dw(e) { const t = new Map; return e.fieldMask.fields.forEach((i => { if (!i.isEmpty()) { const r = e.data.field(i); t.set(i, r) } })), t } function RT(e, t, i) { const r = new Map; Xt(e.length === i.length, 32656, { Ve: i.length, de: e.length }); for (let o = 0; o < i.length; o++) { const u = e[o], c = u.transform, d = t.data.field(u.field); r.set(u.field, MN(c, d, i[o])) } return r } function DT(e, t, i) { const r = new Map; for (const o of e) { const u = o.transform, c = i.data.field(o.field); r.set(o.field, VN(u, c, t)) } return r } class mw extends zf { constructor(t, i) { super(), this.key = t, this.precondition = i, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class LN extends zf { constructor(t, i) { super(), this.key = t, this.precondition = i, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } } class zN { constructor(t, i, r, o) { this.batchId = t, this.localWriteTime = i, this.baseMutations = r, this.mutations = o } applyToRemoteDocument(t, i) { const r = i.mutationResults; for (let o = 0; o < this.mutations.length; o++) { const u = this.mutations[o]; u.key.isEqual(t.key) && PN(u, t, r[o]) } } applyToLocalView(t, i) { for (const r of this.baseMutations) r.key.isEqual(t.key) && (i = _u(r, t, i, this.localWriteTime)); for (const r of this.mutations) r.key.isEqual(t.key) && (i = _u(r, t, i, this.localWriteTime)); return i } applyToLocalDocumentSet(t, i) { const r = aw(); return this.mutations.forEach((o => { const u = t.get(o.key), c = u.overlayedDocument; let d = this.applyToLocalView(c, u.mutatedFields); d = i.has(o.key) ? null : d; const p = fw(c, d); p !== null && r.set(o.key, p), c.isValidDocument() || c.convertToNoDocument(wt.min()) })), r } keys() { return this.mutations.reduce(((t, i) => t.add(i.key)), Ut()) } isEqual(t) { return this.batchId === t.batchId && Mo(this.mutations, t.mutations, ((i, r) => CT(i, r))) && Mo(this.baseMutations, t.baseMutations, ((i, r) => CT(i, r))) } } class py { constructor(t, i, r, o) { this.batch = t, this.commitVersion = i, this.mutationResults = r, this.docVersions = o } static from(t, i, r) { Xt(t.mutations.length === r.length, 58842, { me: t.mutations.length, fe: r.length }); let o = (function () { return wN })(); const u = t.mutations; for (let c = 0; c < u.length; c++)o = o.insert(u[c].key, r[c].version); return new py(t, i, r, o) } } class jN {
  constructor(t, i) { this.largestBatchId = t, this.mutation = i } getKey() { return this.mutation.key } isEqual(t) { return t !== null && this.mutation === t.mutation } toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`}
} class UN { constructor(t, i) { this.count = t, this.unchangedNames = i } } var ke, Ft; function BN(e) { switch (e) { case nt.OK: return At(64938); case nt.CANCELLED: case nt.UNKNOWN: case nt.DEADLINE_EXCEEDED: case nt.RESOURCE_EXHAUSTED: case nt.INTERNAL: case nt.UNAVAILABLE: case nt.UNAUTHENTICATED: return !1; case nt.INVALID_ARGUMENT: case nt.NOT_FOUND: case nt.ALREADY_EXISTS: case nt.PERMISSION_DENIED: case nt.FAILED_PRECONDITION: case nt.ABORTED: case nt.OUT_OF_RANGE: case nt.UNIMPLEMENTED: case nt.DATA_LOSS: return !0; default: return At(15467, { code: e }) } } function pw(e) { if (e === void 0) return ws("GRPC error has no .code"), nt.UNKNOWN; switch (e) { case ke.OK: return nt.OK; case ke.CANCELLED: return nt.CANCELLED; case ke.UNKNOWN: return nt.UNKNOWN; case ke.DEADLINE_EXCEEDED: return nt.DEADLINE_EXCEEDED; case ke.RESOURCE_EXHAUSTED: return nt.RESOURCE_EXHAUSTED; case ke.INTERNAL: return nt.INTERNAL; case ke.UNAVAILABLE: return nt.UNAVAILABLE; case ke.UNAUTHENTICATED: return nt.UNAUTHENTICATED; case ke.INVALID_ARGUMENT: return nt.INVALID_ARGUMENT; case ke.NOT_FOUND: return nt.NOT_FOUND; case ke.ALREADY_EXISTS: return nt.ALREADY_EXISTS; case ke.PERMISSION_DENIED: return nt.PERMISSION_DENIED; case ke.FAILED_PRECONDITION: return nt.FAILED_PRECONDITION; case ke.ABORTED: return nt.ABORTED; case ke.OUT_OF_RANGE: return nt.OUT_OF_RANGE; case ke.UNIMPLEMENTED: return nt.UNIMPLEMENTED; case ke.DATA_LOSS: return nt.DATA_LOSS; default: return At(39323, { code: e }) } } (Ft = ke || (ke = {}))[Ft.OK = 0] = "OK", Ft[Ft.CANCELLED = 1] = "CANCELLED", Ft[Ft.UNKNOWN = 2] = "UNKNOWN", Ft[Ft.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Ft[Ft.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Ft[Ft.NOT_FOUND = 5] = "NOT_FOUND", Ft[Ft.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Ft[Ft.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Ft[Ft.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Ft[Ft.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Ft[Ft.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Ft[Ft.ABORTED = 10] = "ABORTED", Ft[Ft.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Ft[Ft.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Ft[Ft.INTERNAL = 13] = "INTERNAL", Ft[Ft.UNAVAILABLE = 14] = "UNAVAILABLE", Ft[Ft.DATA_LOSS = 15] = "DATA_LOSS"; function FN() { return new TextEncoder } const qN = new gr([4294967295, 4294967295], 0); function VT(e) { const t = FN().encode(e), i = new DA; return i.update(t), new Uint8Array(i.digest()) } function MT(e) { const t = new DataView(e.buffer), i = t.getUint32(0, !0), r = t.getUint32(4, !0), o = t.getUint32(8, !0), u = t.getUint32(12, !0); return [new gr([i, r], 0), new gr([o, u], 0)] } class gy { constructor(t, i, r) { if (this.bitmap = t, this.padding = i, this.hashCount = r, i < 0 || i >= 8) throw new uu(`Invalid padding: ${i}`); if (r < 0) throw new uu(`Invalid hash count: ${r}`); if (t.length > 0 && this.hashCount === 0) throw new uu(`Invalid hash count: ${r}`); if (t.length === 0 && i !== 0) throw new uu(`Invalid padding when bitmap length is 0: ${i}`); this.ge = 8 * t.length - i, this.pe = gr.fromNumber(this.ge) } ye(t, i, r) { let o = t.add(i.multiply(gr.fromNumber(r))); return o.compare(qN) === 1 && (o = new gr([o.getBits(0), o.getBits(1)], 0)), o.modulo(this.pe).toNumber() } we(t) { return !!(this.bitmap[Math.floor(t / 8)] & 1 << t % 8) } mightContain(t) { if (this.ge === 0) return !1; const i = VT(t), [r, o] = MT(i); for (let u = 0; u < this.hashCount; u++) { const c = this.ye(r, o, u); if (!this.we(c)) return !1 } return !0 } static create(t, i, r) { const o = t % 8 == 0 ? 0 : 8 - t % 8, u = new Uint8Array(Math.ceil(t / 8)), c = new gy(u, o, i); return r.forEach((d => c.insert(d))), c } insert(t) { if (this.ge === 0) return; const i = VT(t), [r, o] = MT(i); for (let u = 0; u < this.hashCount; u++) { const c = this.ye(r, o, u); this.be(c) } } be(t) { const i = Math.floor(t / 8), r = t % 8; this.bitmap[i] |= 1 << r } } class uu extends Error { constructor() { super(...arguments), this.name = "BloomFilterError" } } class jf { constructor(t, i, r, o, u) { this.snapshotVersion = t, this.targetChanges = i, this.targetMismatches = r, this.documentUpdates = o, this.resolvedLimboDocuments = u } static createSynthesizedRemoteEventForCurrentChange(t, i, r) { const o = new Map; return o.set(t, qu.createSynthesizedTargetChangeForCurrentChange(t, i, r)), new jf(wt.min(), o, new ge(jt), xs(), Ut()) } } class qu { constructor(t, i, r, o, u) { this.resumeToken = t, this.current = i, this.addedDocuments = r, this.modifiedDocuments = o, this.removedDocuments = u } static createSynthesizedTargetChangeForCurrentChange(t, i, r) { return new qu(r, i, Ut(), Ut(), Ut()) } } class Yh { constructor(t, i, r, o) { this.Se = t, this.removedTargetIds = i, this.key = r, this.De = o } } class gw { constructor(t, i) { this.targetId = t, this.Ce = i } } class yw { constructor(t, i, r = an.EMPTY_BYTE_STRING, o = null) { this.state = t, this.targetIds = i, this.resumeToken = r, this.cause = o } } class IT { constructor() { this.ve = 0, this.Fe = OT(), this.Me = an.EMPTY_BYTE_STRING, this.xe = !1, this.Oe = !0 } get current() { return this.xe } get resumeToken() { return this.Me } get Ne() { return this.ve !== 0 } get Be() { return this.Oe } Le(t) { t.approximateByteSize() > 0 && (this.Oe = !0, this.Me = t) } ke() { let t = Ut(), i = Ut(), r = Ut(); return this.Fe.forEach(((o, u) => { switch (u) { case 0: t = t.add(o); break; case 2: i = i.add(o); break; case 1: r = r.add(o); break; default: At(38017, { changeType: u }) } })), new qu(this.Me, this.xe, t, i, r) } Ke() { this.Oe = !1, this.Fe = OT() } qe(t, i) { this.Oe = !0, this.Fe = this.Fe.insert(t, i) } Ue(t) { this.Oe = !0, this.Fe = this.Fe.remove(t) } $e() { this.ve += 1 } We() { this.ve -= 1, Xt(this.ve >= 0, 3241, { ve: this.ve }) } Qe() { this.Oe = !0, this.xe = !0 } } class HN { constructor(t) { this.Ge = t, this.ze = new Map, this.je = xs(), this.He = Ih(), this.Je = Ih(), this.Ze = new ge(jt) } Xe(t) { for (const i of t.Se) t.De && t.De.isFoundDocument() ? this.Ye(i, t.De) : this.et(i, t.key, t.De); for (const i of t.removedTargetIds) this.et(i, t.key, t.De) } tt(t) { this.forEachTarget(t, (i => { const r = this.nt(i); switch (t.state) { case 0: this.rt(i) && r.Le(t.resumeToken); break; case 1: r.We(), r.Ne || r.Ke(), r.Le(t.resumeToken); break; case 2: r.We(), r.Ne || this.removeTarget(i); break; case 3: this.rt(i) && (r.Qe(), r.Le(t.resumeToken)); break; case 4: this.rt(i) && (this.it(i), r.Le(t.resumeToken)); break; default: At(56790, { state: t.state }) } })) } forEachTarget(t, i) { t.targetIds.length > 0 ? t.targetIds.forEach(i) : this.ze.forEach(((r, o) => { this.rt(o) && i(o) })) } st(t) { const i = t.targetId, r = t.Ce.count, o = this.ot(i); if (o) { const u = o.target; if (lg(u)) if (r === 0) { const c = new bt(u.path); this.et(i, c, cn.newNoDocument(c, wt.min())) } else Xt(r === 1, 20013, { expectedCount: r }); else { const c = this._t(i); if (c !== r) { const d = this.ut(t), p = d ? this.ct(d, t, c) : 1; if (p !== 0) { this.it(i); const g = p === 2 ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch"; this.Ze = this.Ze.insert(i, g) } } } } } ut(t) { const i = t.Ce.unchangedNames; if (!i || !i.bits) return null; const { bits: { bitmap: r = "", padding: o = 0 }, hashCount: u = 0 } = i; let c, d; try { c = Sr(r).toUint8Array() } catch (p) { if (p instanceof BA) return ba("Decoding the base64 bloom filter in existence filter failed (" + p.message + "); ignoring the bloom filter and falling back to full re-query."), null; throw p } try { d = new gy(c, o, u) } catch (p) { return ba(p instanceof uu ? "BloomFilter error: " : "Applying bloom filter failed: ", p), null } return d.ge === 0 ? null : d } ct(t, i, r) { return i.Ce.count === r - this.Pt(t, i.targetId) ? 0 : 2 } Pt(t, i) { const r = this.Ge.getRemoteKeysForTarget(i); let o = 0; return r.forEach((u => { const c = this.Ge.ht(), d = `projects/${c.projectId}/databases/${c.database}/documents/${u.path.canonicalString()}`; t.mightContain(d) || (this.et(i, u, null), o++) })), o } Tt(t) { const i = new Map; this.ze.forEach(((u, c) => { const d = this.ot(c); if (d) { if (u.current && lg(d.target)) { const p = new bt(d.target.path); this.It(p).has(c) || this.Et(c, p) || this.et(c, p, cn.newNoDocument(p, t)) } u.Be && (i.set(c, u.ke()), u.Ke()) } })); let r = Ut(); this.Je.forEach(((u, c) => { let d = !0; c.forEachWhile((p => { const g = this.ot(p); return !g || g.purpose === "TargetPurposeLimboResolution" || (d = !1, !1) })), d && (r = r.add(u)) })), this.je.forEach(((u, c) => c.setReadTime(t))); const o = new jf(t, i, this.Ze, this.je, r); return this.je = xs(), this.He = Ih(), this.Je = Ih(), this.Ze = new ge(jt), o } Ye(t, i) { if (!this.rt(t)) return; const r = this.Et(t, i.key) ? 2 : 0; this.nt(t).qe(i.key, r), this.je = this.je.insert(i.key, i), this.He = this.He.insert(i.key, this.It(i.key).add(t)), this.Je = this.Je.insert(i.key, this.Rt(i.key).add(t)) } et(t, i, r) { if (!this.rt(t)) return; const o = this.nt(t); this.Et(t, i) ? o.qe(i, 1) : o.Ue(i), this.Je = this.Je.insert(i, this.Rt(i).delete(t)), this.Je = this.Je.insert(i, this.Rt(i).add(t)), r && (this.je = this.je.insert(i, r)) } removeTarget(t) { this.ze.delete(t) } _t(t) { const i = this.nt(t).ke(); return this.Ge.getRemoteKeysForTarget(t).size + i.addedDocuments.size - i.removedDocuments.size } $e(t) { this.nt(t).$e() } nt(t) { let i = this.ze.get(t); return i || (i = new IT, this.ze.set(t, i)), i } Rt(t) { let i = this.Je.get(t); return i || (i = new He(jt), this.Je = this.Je.insert(t, i)), i } It(t) { let i = this.He.get(t); return i || (i = new He(jt), this.He = this.He.insert(t, i)), i } rt(t) { const i = this.ot(t) !== null; return i || dt("WatchChangeAggregator", "Detected inactive target", t), i } ot(t) { const i = this.ze.get(t); return i && i.Ne ? null : this.Ge.At(t) } it(t) { this.ze.set(t, new IT), this.Ge.getRemoteKeysForTarget(t).forEach((i => { this.et(t, i, null) })) } Et(t, i) { return this.Ge.getRemoteKeysForTarget(t).has(i) } } function Ih() { return new ge(bt.comparator) } function OT() { return new ge(bt.comparator) } const GN = { asc: "ASCENDING", desc: "DESCENDING" }, YN = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }, KN = { and: "AND", or: "OR" }; class QN { constructor(t, i) { this.databaseId = t, this.useProto3Json = i } } function cg(e, t) { return e.useProto3Json || Of(t) ? t : { value: t } } function _f(e, t) { return e.useProto3Json ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : { seconds: "" + t.seconds, nanos: t.nanoseconds } } function vw(e, t) { return e.useProto3Json ? t.toBase64() : t.toUint8Array() } function XN(e, t) { return _f(e, t.toTimestamp()) } function Ki(e) { return Xt(!!e, 49232), wt.fromTimestamp((function (i) { const r = Er(i); return new he(r.seconds, r.nanos) })(e)) } function yy(e, t) { return hg(e, t).canonicalString() } function hg(e, t) { const i = (function (o) { return new oe(["projects", o.projectId, "databases", o.database]) })(e).child("documents"); return t === void 0 ? i : i.child(t) } function _w(e) { const t = oe.fromString(e); return Xt(Aw(t), 10190, { key: t.toString() }), t } function fg(e, t) { return yy(e.databaseId, t.path) } function Ep(e, t) { const i = _w(t); if (i.get(1) !== e.databaseId.projectId) throw new ft(nt.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + i.get(1) + " vs " + e.databaseId.projectId); if (i.get(3) !== e.databaseId.database) throw new ft(nt.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + i.get(3) + " vs " + e.databaseId.database); return new bt(Tw(i)) } function bw(e, t) { return yy(e.databaseId, t) } function WN(e) { const t = _w(e); return t.length === 4 ? oe.emptyPath() : Tw(t) } function dg(e) { return new oe(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString() } function Tw(e) { return Xt(e.length > 4 && e.get(4) === "documents", 29091, { key: e.toString() }), e.popFirst(5) } function NT(e, t, i) { return { name: fg(e, t), fields: i.value.mapValue.fields } } function $N(e, t) { let i; if ("targetChange" in t) { t.targetChange; const r = (function (g) { return g === "NO_CHANGE" ? 0 : g === "ADD" ? 1 : g === "REMOVE" ? 2 : g === "CURRENT" ? 3 : g === "RESET" ? 4 : At(39313, { state: g }) })(t.targetChange.targetChangeType || "NO_CHANGE"), o = t.targetChange.targetIds || [], u = (function (g, v) { return g.useProto3Json ? (Xt(v === void 0 || typeof v == "string", 58123), an.fromBase64String(v || "")) : (Xt(v === void 0 || v instanceof Buffer || v instanceof Uint8Array, 16193), an.fromUint8Array(v || new Uint8Array)) })(e, t.targetChange.resumeToken), c = t.targetChange.cause, d = c && (function (g) { const v = g.code === void 0 ? nt.UNKNOWN : pw(g.code); return new ft(v, g.message || "") })(c); i = new yw(r, o, u, d || null) } else if ("documentChange" in t) { t.documentChange; const r = t.documentChange; r.document, r.document.name, r.document.updateTime; const o = Ep(e, r.document.name), u = Ki(r.document.updateTime), c = r.document.createTime ? Ki(r.document.createTime) : wt.min(), d = new wn({ mapValue: { fields: r.document.fields } }), p = cn.newFoundDocument(o, u, c, d), g = r.targetIds || [], v = r.removedTargetIds || []; i = new Yh(g, v, p.key, p) } else if ("documentDelete" in t) { t.documentDelete; const r = t.documentDelete; r.document; const o = Ep(e, r.document), u = r.readTime ? Ki(r.readTime) : wt.min(), c = cn.newNoDocument(o, u), d = r.removedTargetIds || []; i = new Yh([], d, c.key, c) } else if ("documentRemove" in t) { t.documentRemove; const r = t.documentRemove; r.document; const o = Ep(e, r.document), u = r.removedTargetIds || []; i = new Yh([], u, o, null) } else { if (!("filter" in t)) return At(11601, { Vt: t }); { t.filter; const r = t.filter; r.targetId; const { count: o = 0, unchangedNames: u } = r, c = new UN(o, u), d = r.targetId; i = new gw(d, c) } } return i } function ZN(e, t) { let i; if (t instanceof Fu) i = { update: NT(e, t.key, t.value) }; else if (t instanceof mw) i = { delete: fg(e, t.key) }; else if (t instanceof Vr) i = { update: NT(e, t.key, t.data), updateMask: o5(t.fieldMask) }; else { if (!(t instanceof LN)) return At(16599, { dt: t.type }); i = { verify: fg(e, t.key) } } return t.fieldTransforms.length > 0 && (i.updateTransforms = t.fieldTransforms.map((r => (function (u, c) { const d = c.transform; if (d instanceof Ou) return { fieldPath: c.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (d instanceof Nu) return { fieldPath: c.field.canonicalString(), appendMissingElements: { values: d.elements } }; if (d instanceof Pu) return { fieldPath: c.field.canonicalString(), removeAllFromArray: { values: d.elements } }; if (d instanceof vf) return { fieldPath: c.field.canonicalString(), increment: d.Ae }; throw At(20930, { transform: c.transform }) })(0, r)))), t.precondition.isNone || (i.currentDocument = (function (o, u) { return u.updateTime !== void 0 ? { updateTime: XN(o, u.updateTime) } : u.exists !== void 0 ? { exists: u.exists } : At(27497) })(e, t.precondition)), i } function JN(e, t) { return e && e.length > 0 ? (Xt(t !== void 0, 14353), e.map((i => (function (o, u) { let c = o.updateTime ? Ki(o.updateTime) : Ki(u); return c.isEqual(wt.min()) && (c = Ki(u)), new NN(c, o.transformResults || []) })(i, t)))) : [] } function t5(e, t) { return { documents: [bw(e, t.path)] } } function e5(e, t) { const i = { structuredQuery: {} }, r = t.path; let o; t.collectionGroup !== null ? (o = r, i.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]) : (o = r.popLast(), i.structuredQuery.from = [{ collectionId: r.lastSegment() }]), i.parent = bw(e, o); const u = (function (g) { if (g.length !== 0) return Sw(gi.create(g, "and")) })(t.filters); u && (i.structuredQuery.where = u); const c = (function (g) { if (g.length !== 0) return g.map((v => (function (E) { return { field: vo(E.field), direction: s5(E.dir) } })(v))) })(t.orderBy); c && (i.structuredQuery.orderBy = c); const d = cg(e, t.limit); return d !== null && (i.structuredQuery.limit = d), t.startAt && (i.structuredQuery.startAt = (function (g) { return { before: g.inclusive, values: g.position } })(t.startAt)), t.endAt && (i.structuredQuery.endAt = (function (g) { return { before: !g.inclusive, values: g.position } })(t.endAt)), { ft: i, parent: o } } function n5(e) { let t = WN(e.parent); const i = e.structuredQuery, r = i.from ? i.from.length : 0; let o = null; if (r > 0) { Xt(r === 1, 65062); const v = i.from[0]; v.allDescendants ? o = v.collectionId : t = t.child(v.collectionId) } let u = []; i.where && (u = (function (b) { const E = Ew(b); return E instanceof gi && $A(E) ? E.getFilters() : [E] })(i.where)); let c = []; i.orderBy && (c = (function (b) { return b.map((E => (function (M) { return new Iu(_o(M.field), (function (z) { switch (z) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } })(M.direction)) })(E))) })(i.orderBy)); let d = null; i.limit && (d = (function (b) { let E; return E = typeof b == "object" ? b.value : b, Of(E) ? null : E })(i.limit)); let p = null; i.startAt && (p = (function (b) { const E = !!b.before, x = b.values || []; return new gf(x, E) })(i.startAt)); let g = null; return i.endAt && (g = (function (b) { const E = !b.before, x = b.values || []; return new gf(x, E) })(i.endAt)), vN(t, o, c, u, d, "F", p, g) } function i5(e, t) { const i = (function (o) { switch (o) { case "TargetPurposeListen": return null; case "TargetPurposeExistenceFilterMismatch": return "existence-filter-mismatch"; case "TargetPurposeExistenceFilterMismatchBloom": return "existence-filter-mismatch-bloom"; case "TargetPurposeLimboResolution": return "limbo-document"; default: return At(28987, { purpose: o }) } })(t.purpose); return i == null ? null : { "goog-listen-tags": i } } function Ew(e) { return e.unaryFilter !== void 0 ? (function (i) { switch (i.unaryFilter.op) { case "IS_NAN": const r = _o(i.unaryFilter.field); return ze.create(r, "==", { doubleValue: NaN }); case "IS_NULL": const o = _o(i.unaryFilter.field); return ze.create(o, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const u = _o(i.unaryFilter.field); return ze.create(u, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const c = _o(i.unaryFilter.field); return ze.create(c, "!=", { nullValue: "NULL_VALUE" }); case "OPERATOR_UNSPECIFIED": return At(61313); default: return At(60726) } })(e) : e.fieldFilter !== void 0 ? (function (i) { return ze.create(_o(i.fieldFilter.field), (function (o) { switch (o) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; case "OPERATOR_UNSPECIFIED": return At(58110); default: return At(50506) } })(i.fieldFilter.op), i.fieldFilter.value) })(e) : e.compositeFilter !== void 0 ? (function (i) { return gi.create(i.compositeFilter.filters.map((r => Ew(r))), (function (o) { switch (o) { case "AND": return "and"; case "OR": return "or"; default: return At(1026) } })(i.compositeFilter.op)) })(e) : At(30097, { filter: e }) } function s5(e) { return GN[e] } function r5(e) { return YN[e] } function a5(e) { return KN[e] } function vo(e) { return { fieldPath: e.canonicalString() } } function _o(e) { return sn.fromServerFormat(e.fieldPath) } function Sw(e) { return e instanceof ze ? (function (i) { if (i.op === "==") { if (TT(i.value)) return { unaryFilter: { field: vo(i.field), op: "IS_NAN" } }; if (bT(i.value)) return { unaryFilter: { field: vo(i.field), op: "IS_NULL" } } } else if (i.op === "!=") { if (TT(i.value)) return { unaryFilter: { field: vo(i.field), op: "IS_NOT_NAN" } }; if (bT(i.value)) return { unaryFilter: { field: vo(i.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: vo(i.field), op: r5(i.op), value: i.value } } })(e) : e instanceof gi ? (function (i) { const r = i.getFilters().map((o => Sw(o))); return r.length === 1 ? r[0] : { compositeFilter: { op: a5(i.op), filters: r } } })(e) : At(54877, { filter: e }) } function o5(e) { const t = []; return e.fields.forEach((i => t.push(i.canonicalString()))), { fieldPaths: t } } function Aw(e) { return e.length >= 4 && e.get(0) === "projects" && e.get(2) === "databases" } function ww(e) { return !!e && typeof e._toProto == "function" && e._protoValueType === "ProtoValue" } class hr { constructor(t, i, r, o, u = wt.min(), c = wt.min(), d = an.EMPTY_BYTE_STRING, p = null) { this.target = t, this.targetId = i, this.purpose = r, this.sequenceNumber = o, this.snapshotVersion = u, this.lastLimboFreeSnapshotVersion = c, this.resumeToken = d, this.expectedCount = p } withSequenceNumber(t) { return new hr(this.target, this.targetId, this.purpose, t, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount) } withResumeToken(t, i) { return new hr(this.target, this.targetId, this.purpose, this.sequenceNumber, i, this.lastLimboFreeSnapshotVersion, t, null) } withExpectedCount(t) { return new hr(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, t) } withLastLimboFreeSnapshotVersion(t) { return new hr(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t, this.resumeToken, this.expectedCount) } } class l5 { constructor(t) { this.yt = t } } function u5(e) { const t = n5({ parent: e.parent, structuredQuery: e.structuredQuery }); return e.limitType === "LAST" ? yf(t, t.limit, "L") : t } class c5 { constructor() { this.Sn = new h5 } addToCollectionParentIndex(t, i) { return this.Sn.add(i), st.resolve() } getCollectionParents(t, i) { return st.resolve(this.Sn.getEntries(i)) } addFieldIndex(t, i) { return st.resolve() } deleteFieldIndex(t, i) { return st.resolve() } deleteAllFieldIndexes(t) { return st.resolve() } createTargetIndexes(t, i) { return st.resolve() } getDocumentsMatchingTarget(t, i) { return st.resolve(null) } getIndexType(t, i) { return st.resolve(0) } getFieldIndexes(t, i) { return st.resolve([]) } getNextCollectionGroupToUpdate(t) { return st.resolve(null) } getMinOffset(t, i) { return st.resolve(Tr.min()) } getMinOffsetFromCollectionGroup(t, i) { return st.resolve(Tr.min()) } updateCollectionGroup(t, i, r) { return st.resolve() } updateIndexEntries(t, i) { return st.resolve() } } class h5 { constructor() { this.index = {} } add(t) { const i = t.lastSegment(), r = t.popLast(), o = this.index[i] || new He(oe.comparator), u = !o.has(r); return this.index[i] = o.add(r), u } has(t) { const i = t.lastSegment(), r = t.popLast(), o = this.index[i]; return o && o.has(r) } getEntries(t) { return (this.index[t] || new He(oe.comparator)).toArray() } } const PT = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }, xw = 41943040; class An { static withCacheSize(t) { return new An(t, An.DEFAULT_COLLECTION_PERCENTILE, An.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } constructor(t, i, r) { this.cacheSizeCollectionThreshold = t, this.percentileToCollect = i, this.maximumSequenceNumbersToCollect = r } } An.DEFAULT_COLLECTION_PERCENTILE = 10, An.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, An.DEFAULT = new An(xw, An.DEFAULT_COLLECTION_PERCENTILE, An.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), An.DISABLED = new An(-1, 0, 0); class No { constructor(t) { this.sr = t } next() { return this.sr += 2, this.sr } static _r() { return new No(0) } static ar() { return new No(-1) } } const kT = "LruGarbageCollector", f5 = 1048576; function LT([e, t], [i, r]) { const o = jt(e, i); return o === 0 ? jt(t, r) : o } class d5 { constructor(t) { this.Pr = t, this.buffer = new He(LT), this.Tr = 0 } Ir() { return ++this.Tr } Er(t) { const i = [t, this.Ir()]; if (this.buffer.size < this.Pr) this.buffer = this.buffer.add(i); else { const r = this.buffer.last(); LT(i, r) < 0 && (this.buffer = this.buffer.delete(r).add(i)) } } get maxValue() { return this.buffer.last()[0] } } class m5 { constructor(t, i, r) { this.garbageCollector = t, this.asyncQueue = i, this.localStore = r, this.Rr = null } start() { this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.Ar(6e4) } stop() { this.Rr && (this.Rr.cancel(), this.Rr = null) } get started() { return this.Rr !== null } Ar(t) { dt(kT, `Garbage collection scheduled in ${t}ms`), this.Rr = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t, (async () => { this.Rr = null; try { await this.localStore.collectGarbage(this.garbageCollector) } catch (i) { Yo(i) ? dt(kT, "Ignoring IndexedDB error during garbage collection: ", i) : await Go(i) } await this.Ar(3e5) })) } } class p5 {
  constructor(t, i) { this.Vr = t, this.params = i } calculateTargetCount(t, i) { return this.Vr.dr(t).next((r => Math.floor(i / 100 * r))) } nthSequenceNumber(t, i) { if (i === 0) return st.resolve(If.ce); const r = new d5(i); return this.Vr.forEachTarget(t, (o => r.Er(o.sequenceNumber))).next((() => this.Vr.mr(t, (o => r.Er(o))))).next((() => r.maxValue)) } removeTargets(t, i, r) { return this.Vr.removeTargets(t, i, r) } removeOrphanedDocuments(t, i) { return this.Vr.removeOrphanedDocuments(t, i) } collect(t, i) { return this.params.cacheSizeCollectionThreshold === -1 ? (dt("LruGarbageCollector", "Garbage collection skipped; disabled"), st.resolve(PT)) : this.getCacheSize(t).next((r => r < this.params.cacheSizeCollectionThreshold ? (dt("LruGarbageCollector", `Garbage collection skipped; Cache size ${r} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), PT) : this.gr(t, i))) } getCacheSize(t) { return this.Vr.getCacheSize(t) } gr(t, i) {
    let r, o, u, c, d, p, g; const v = Date.now(); return this.calculateTargetCount(t, this.params.percentileToCollect).next((b => (b > this.params.maximumSequenceNumbersToCollect ? (dt("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${b}`), o = this.params.maximumSequenceNumbersToCollect) : o = b, c = Date.now(), this.nthSequenceNumber(t, o)))).next((b => (r = b, d = Date.now(), this.removeTargets(t, r, i)))).next((b => (u = b, p = Date.now(), this.removeOrphanedDocuments(t, r)))).next((b => (g = Date.now(), go() <= qt.DEBUG && dt("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${c - v}ms
	Determined least recently used ${o} in ` + (d - c) + `ms
	Removed ${u} targets in ` + (p - d) + `ms
	Removed ${b} documents in ` + (g - p) + `ms
Total Duration: ${g - v}ms`), st.resolve({ didRun: !0, sequenceNumbersCollected: o, targetsRemoved: u, documentsRemoved: b }))))
  }
} function g5(e, t) { return new p5(e, t) } class y5 { constructor() { this.changes = new Ea((t => t.toString()), ((t, i) => t.isEqual(i))), this.changesApplied = !1 } addEntry(t) { this.assertNotApplied(), this.changes.set(t.key, t) } removeEntry(t, i) { this.assertNotApplied(), this.changes.set(t, cn.newInvalidDocument(t).setReadTime(i)) } getEntry(t, i) { this.assertNotApplied(); const r = this.changes.get(i); return r !== void 0 ? st.resolve(r) : this.getFromCache(t, i) } getEntries(t, i) { return this.getAllFromCache(t, i) } apply(t) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(t) } assertNotApplied() { } } class v5 { constructor(t, i) { this.overlayedDocument = t, this.mutatedFields = i } } class _5 { constructor(t, i, r, o) { this.remoteDocumentCache = t, this.mutationQueue = i, this.documentOverlayCache = r, this.indexManager = o } getDocument(t, i) { let r = null; return this.documentOverlayCache.getOverlay(t, i).next((o => (r = o, this.remoteDocumentCache.getEntry(t, i)))).next((o => (r !== null && _u(r.mutation, o, Pn.empty(), he.now()), o))) } getDocuments(t, i) { return this.remoteDocumentCache.getEntries(t, i).next((r => this.getLocalViewOfDocuments(t, r, Ut()).next((() => r)))) } getLocalViewOfDocuments(t, i, r = Ut()) { const o = pa(); return this.populateOverlays(t, o, i).next((() => this.computeViews(t, i, o, r).next((u => { let c = lu(); return u.forEach(((d, p) => { c = c.insert(d, p.overlayedDocument) })), c })))) } getOverlayedDocuments(t, i) { const r = pa(); return this.populateOverlays(t, r, i).next((() => this.computeViews(t, i, r, Ut()))) } populateOverlays(t, i, r) { const o = []; return r.forEach((u => { i.has(u) || o.push(u) })), this.documentOverlayCache.getOverlays(t, o).next((u => { u.forEach(((c, d) => { i.set(c, d) })) })) } computeViews(t, i, r, o) { let u = xs(); const c = vu(), d = (function () { return vu() })(); return i.forEach(((p, g) => { const v = r.get(g.key); o.has(g.key) && (v === void 0 || v.mutation instanceof Vr) ? u = u.insert(g.key, g) : v !== void 0 ? (c.set(g.key, v.mutation.getFieldMask()), _u(v.mutation, g, v.mutation.getFieldMask(), he.now())) : c.set(g.key, Pn.empty()) })), this.recalculateAndSaveOverlays(t, u).next((p => (p.forEach(((g, v) => c.set(g, v))), i.forEach(((g, v) => d.set(g, new v5(v, c.get(g) ?? null)))), d))) } recalculateAndSaveOverlays(t, i) { const r = vu(); let o = new ge(((c, d) => c - d)), u = Ut(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, i).next((c => { for (const d of c) d.keys().forEach((p => { const g = i.get(p); if (g === null) return; let v = r.get(p) || Pn.empty(); v = d.applyToLocalView(g, v), r.set(p, v); const b = (o.get(d.batchId) || Ut()).add(p); o = o.insert(d.batchId, b) })) })).next((() => { const c = [], d = o.getReverseIterator(); for (; d.hasNext();) { const p = d.getNext(), g = p.key, v = p.value, b = aw(); v.forEach((E => { if (!u.has(E)) { const x = fw(i.get(E), r.get(E)); x !== null && b.set(E, x), u = u.add(E) } })), c.push(this.documentOverlayCache.saveOverlays(t, g, b)) } return st.waitFor(c) })).next((() => r)) } recalculateAndSaveOverlaysForDocumentKeys(t, i) { return this.remoteDocumentCache.getEntries(t, i).next((r => this.recalculateAndSaveOverlays(t, r))) } getDocumentsMatchingQuery(t, i, r, o) { return _N(i) ? this.getDocumentsMatchingDocumentQuery(t, i.path) : ew(i) ? this.getDocumentsMatchingCollectionGroupQuery(t, i, r, o) : this.getDocumentsMatchingCollectionQuery(t, i, r, o) } getNextDocuments(t, i, r, o) { return this.remoteDocumentCache.getAllFromCollectionGroup(t, i, r, o).next((u => { const c = o - u.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, i, r.largestBatchId, o - u.size) : st.resolve(pa()); let d = Ru, p = u; return c.next((g => st.forEach(g, ((v, b) => (d < b.largestBatchId && (d = b.largestBatchId), u.get(v) ? st.resolve() : this.remoteDocumentCache.getEntry(t, v).next((E => { p = p.insert(v, E) }))))).next((() => this.populateOverlays(t, g, u))).next((() => this.computeViews(t, p, g, Ut()))).next((v => ({ batchId: d, changes: rw(v) }))))) })) } getDocumentsMatchingDocumentQuery(t, i) { return this.getDocument(t, new bt(i)).next((r => { let o = lu(); return r.isFoundDocument() && (o = o.insert(r.key, r)), o })) } getDocumentsMatchingCollectionGroupQuery(t, i, r, o) { const u = i.collectionGroup; let c = lu(); return this.indexManager.getCollectionParents(t, u).next((d => st.forEach(d, (p => { const g = (function (b, E) { return new Ko(E, null, b.explicitOrderBy.slice(), b.filters.slice(), b.limit, b.limitType, b.startAt, b.endAt) })(i, p.child(u)); return this.getDocumentsMatchingCollectionQuery(t, g, r, o).next((v => { v.forEach(((b, E) => { c = c.insert(b, E) })) })) })).next((() => c)))) } getDocumentsMatchingCollectionQuery(t, i, r, o) { let u; return this.documentOverlayCache.getOverlaysForCollection(t, i.path, r.largestBatchId).next((c => (u = c, this.remoteDocumentCache.getDocumentsMatchingQuery(t, i, r, u, o)))).next((c => { u.forEach(((p, g) => { const v = g.getKey(); c.get(v) === null && (c = c.insert(v, cn.newInvalidDocument(v))) })); let d = lu(); return c.forEach(((p, g) => { const v = u.get(p); v !== void 0 && _u(v.mutation, g, Pn.empty(), he.now()), kf(i, g) && (d = d.insert(p, g)) })), d })) } } class b5 { constructor(t) { this.serializer = t, this.Nr = new Map, this.Br = new Map } getBundleMetadata(t, i) { return st.resolve(this.Nr.get(i)) } saveBundleMetadata(t, i) { return this.Nr.set(i.id, (function (o) { return { id: o.id, version: o.version, createTime: Ki(o.createTime) } })(i)), st.resolve() } getNamedQuery(t, i) { return st.resolve(this.Br.get(i)) } saveNamedQuery(t, i) { return this.Br.set(i.name, (function (o) { return { name: o.name, query: u5(o.bundledQuery), readTime: Ki(o.readTime) } })(i)), st.resolve() } } class T5 { constructor() { this.overlays = new ge(bt.comparator), this.Lr = new Map } getOverlay(t, i) { return st.resolve(this.overlays.get(i)) } getOverlays(t, i) { const r = pa(); return st.forEach(i, (o => this.getOverlay(t, o).next((u => { u !== null && r.set(o, u) })))).next((() => r)) } saveOverlays(t, i, r) { return r.forEach(((o, u) => { this.bt(t, i, u) })), st.resolve() } removeOverlaysForBatchId(t, i, r) { const o = this.Lr.get(r); return o !== void 0 && (o.forEach((u => this.overlays = this.overlays.remove(u))), this.Lr.delete(r)), st.resolve() } getOverlaysForCollection(t, i, r) { const o = pa(), u = i.length + 1, c = new bt(i.child("")), d = this.overlays.getIteratorFrom(c); for (; d.hasNext();) { const p = d.getNext().value, g = p.getKey(); if (!i.isPrefixOf(g.path)) break; g.path.length === u && p.largestBatchId > r && o.set(p.getKey(), p) } return st.resolve(o) } getOverlaysForCollectionGroup(t, i, r, o) { let u = new ge(((g, v) => g - v)); const c = this.overlays.getIterator(); for (; c.hasNext();) { const g = c.getNext().value; if (g.getKey().getCollectionGroup() === i && g.largestBatchId > r) { let v = u.get(g.largestBatchId); v === null && (v = pa(), u = u.insert(g.largestBatchId, v)), v.set(g.getKey(), g) } } const d = pa(), p = u.getIterator(); for (; p.hasNext() && (p.getNext().value.forEach(((g, v) => d.set(g, v))), !(d.size() >= o));); return st.resolve(d) } bt(t, i, r) { const o = this.overlays.get(r.key); if (o !== null) { const c = this.Lr.get(o.largestBatchId).delete(r.key); this.Lr.set(o.largestBatchId, c) } this.overlays = this.overlays.insert(r.key, new jN(i, r)); let u = this.Lr.get(i); u === void 0 && (u = Ut(), this.Lr.set(i, u)), this.Lr.set(i, u.add(r.key)) } } class E5 { constructor() { this.sessionToken = an.EMPTY_BYTE_STRING } getSessionToken(t) { return st.resolve(this.sessionToken) } setSessionToken(t, i) { return this.sessionToken = i, st.resolve() } } class vy { constructor() { this.kr = new He(Qe.Kr), this.qr = new He(Qe.Ur) } isEmpty() { return this.kr.isEmpty() } addReference(t, i) { const r = new Qe(t, i); this.kr = this.kr.add(r), this.qr = this.qr.add(r) } $r(t, i) { t.forEach((r => this.addReference(r, i))) } removeReference(t, i) { this.Wr(new Qe(t, i)) } Qr(t, i) { t.forEach((r => this.removeReference(r, i))) } Gr(t) { const i = new bt(new oe([])), r = new Qe(i, t), o = new Qe(i, t + 1), u = []; return this.qr.forEachInRange([r, o], (c => { this.Wr(c), u.push(c.key) })), u } zr() { this.kr.forEach((t => this.Wr(t))) } Wr(t) { this.kr = this.kr.delete(t), this.qr = this.qr.delete(t) } jr(t) { const i = new bt(new oe([])), r = new Qe(i, t), o = new Qe(i, t + 1); let u = Ut(); return this.qr.forEachInRange([r, o], (c => { u = u.add(c.key) })), u } containsKey(t) { const i = new Qe(t, 0), r = this.kr.firstAfterOrEqual(i); return r !== null && t.isEqual(r.key) } } class Qe { constructor(t, i) { this.key = t, this.Hr = i } static Kr(t, i) { return bt.comparator(t.key, i.key) || jt(t.Hr, i.Hr) } static Ur(t, i) { return jt(t.Hr, i.Hr) || bt.comparator(t.key, i.key) } } class S5 { constructor(t, i) { this.indexManager = t, this.referenceDelegate = i, this.mutationQueue = [], this.Yn = 1, this.Jr = new He(Qe.Kr) } checkEmpty(t) { return st.resolve(this.mutationQueue.length === 0) } addMutationBatch(t, i, r, o) { const u = this.Yn; this.Yn++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1]; const c = new zN(u, i, r, o); this.mutationQueue.push(c); for (const d of o) this.Jr = this.Jr.add(new Qe(d.key, u)), this.indexManager.addToCollectionParentIndex(t, d.key.path.popLast()); return st.resolve(c) } lookupMutationBatch(t, i) { return st.resolve(this.Zr(i)) } getNextMutationBatchAfterBatchId(t, i) { const r = i + 1, o = this.Xr(r), u = o < 0 ? 0 : o; return st.resolve(this.mutationQueue.length > u ? this.mutationQueue[u] : null) } getHighestUnacknowledgedBatchId() { return st.resolve(this.mutationQueue.length === 0 ? ly : this.Yn - 1) } getAllMutationBatches(t) { return st.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(t, i) { const r = new Qe(i, 0), o = new Qe(i, Number.POSITIVE_INFINITY), u = []; return this.Jr.forEachInRange([r, o], (c => { const d = this.Zr(c.Hr); u.push(d) })), st.resolve(u) } getAllMutationBatchesAffectingDocumentKeys(t, i) { let r = new He(jt); return i.forEach((o => { const u = new Qe(o, 0), c = new Qe(o, Number.POSITIVE_INFINITY); this.Jr.forEachInRange([u, c], (d => { r = r.add(d.Hr) })) })), st.resolve(this.Yr(r)) } getAllMutationBatchesAffectingQuery(t, i) { const r = i.path, o = r.length + 1; let u = r; bt.isDocumentKey(u) || (u = u.child("")); const c = new Qe(new bt(u), 0); let d = new He(jt); return this.Jr.forEachWhile((p => { const g = p.key.path; return !!r.isPrefixOf(g) && (g.length === o && (d = d.add(p.Hr)), !0) }), c), st.resolve(this.Yr(d)) } Yr(t) { const i = []; return t.forEach((r => { const o = this.Zr(r); o !== null && i.push(o) })), i } removeMutationBatch(t, i) { Xt(this.ei(i.batchId, "removed") === 0, 55003), this.mutationQueue.shift(); let r = this.Jr; return st.forEach(i.mutations, (o => { const u = new Qe(o.key, i.batchId); return r = r.delete(u), this.referenceDelegate.markPotentiallyOrphaned(t, o.key) })).next((() => { this.Jr = r })) } nr(t) { } containsKey(t, i) { const r = new Qe(i, 0), o = this.Jr.firstAfterOrEqual(r); return st.resolve(i.isEqual(o && o.key)) } performConsistencyCheck(t) { return this.mutationQueue.length, st.resolve() } ei(t, i) { return this.Xr(t) } Xr(t) { return this.mutationQueue.length === 0 ? 0 : t - this.mutationQueue[0].batchId } Zr(t) { const i = this.Xr(t); return i < 0 || i >= this.mutationQueue.length ? null : this.mutationQueue[i] } } class A5 { constructor(t) { this.ti = t, this.docs = (function () { return new ge(bt.comparator) })(), this.size = 0 } setIndexManager(t) { this.indexManager = t } addEntry(t, i) { const r = i.key, o = this.docs.get(r), u = o ? o.size : 0, c = this.ti(i); return this.docs = this.docs.insert(r, { document: i.mutableCopy(), size: c }), this.size += c - u, this.indexManager.addToCollectionParentIndex(t, r.path.popLast()) } removeEntry(t) { const i = this.docs.get(t); i && (this.docs = this.docs.remove(t), this.size -= i.size) } getEntry(t, i) { const r = this.docs.get(i); return st.resolve(r ? r.document.mutableCopy() : cn.newInvalidDocument(i)) } getEntries(t, i) { let r = xs(); return i.forEach((o => { const u = this.docs.get(o); r = r.insert(o, u ? u.document.mutableCopy() : cn.newInvalidDocument(o)) })), st.resolve(r) } getDocumentsMatchingQuery(t, i, r, o) { let u = xs(); const c = i.path, d = new bt(c.child("__id-9223372036854775808__")), p = this.docs.getIteratorFrom(d); for (; p.hasNext();) { const { key: g, value: { document: v } } = p.getNext(); if (!c.isPrefixOf(g.path)) break; g.path.length > c.length + 1 || XO(QO(v), r) <= 0 || (o.has(v.key) || kf(i, v)) && (u = u.insert(v.key, v.mutableCopy())) } return st.resolve(u) } getAllFromCollectionGroup(t, i, r, o) { At(9500) } ni(t, i) { return st.forEach(this.docs, (r => i(r))) } newChangeBuffer(t) { return new w5(this) } getSize(t) { return st.resolve(this.size) } } class w5 extends y5 { constructor(t) { super(), this.Mr = t } applyChanges(t) { const i = []; return this.changes.forEach(((r, o) => { o.isValidDocument() ? i.push(this.Mr.addEntry(t, o)) : this.Mr.removeEntry(r) })), st.waitFor(i) } getFromCache(t, i) { return this.Mr.getEntry(t, i) } getAllFromCache(t, i) { return this.Mr.getEntries(t, i) } } class x5 { constructor(t) { this.persistence = t, this.ri = new Ea((i => hy(i)), fy), this.lastRemoteSnapshotVersion = wt.min(), this.highestTargetId = 0, this.ii = 0, this.si = new vy, this.targetCount = 0, this.oi = No._r() } forEachTarget(t, i) { return this.ri.forEach(((r, o) => i(o))), st.resolve() } getLastRemoteSnapshotVersion(t) { return st.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(t) { return st.resolve(this.ii) } allocateTargetId(t) { return this.highestTargetId = this.oi.next(), st.resolve(this.highestTargetId) } setTargetsMetadata(t, i, r) { return r && (this.lastRemoteSnapshotVersion = r), i > this.ii && (this.ii = i), st.resolve() } lr(t) { this.ri.set(t.target, t); const i = t.targetId; i > this.highestTargetId && (this.oi = new No(i), this.highestTargetId = i), t.sequenceNumber > this.ii && (this.ii = t.sequenceNumber) } addTargetData(t, i) { return this.lr(i), this.targetCount += 1, st.resolve() } updateTargetData(t, i) { return this.lr(i), st.resolve() } removeTargetData(t, i) { return this.ri.delete(i.target), this.si.Gr(i.targetId), this.targetCount -= 1, st.resolve() } removeTargets(t, i, r) { let o = 0; const u = []; return this.ri.forEach(((c, d) => { d.sequenceNumber <= i && r.get(d.targetId) === null && (this.ri.delete(c), u.push(this.removeMatchingKeysForTargetId(t, d.targetId)), o++) })), st.waitFor(u).next((() => o)) } getTargetCount(t) { return st.resolve(this.targetCount) } getTargetData(t, i) { const r = this.ri.get(i) || null; return st.resolve(r) } addMatchingKeys(t, i, r) { return this.si.$r(i, r), st.resolve() } removeMatchingKeys(t, i, r) { this.si.Qr(i, r); const o = this.persistence.referenceDelegate, u = []; return o && i.forEach((c => { u.push(o.markPotentiallyOrphaned(t, c)) })), st.waitFor(u) } removeMatchingKeysForTargetId(t, i) { return this.si.Gr(i), st.resolve() } getMatchingKeysForTargetId(t, i) { const r = this.si.jr(i); return st.resolve(r) } containsKey(t, i) { return st.resolve(this.si.containsKey(i)) } } class Cw { constructor(t, i) { this._i = {}, this.overlays = {}, this.ai = new If(0), this.ui = !1, this.ui = !0, this.ci = new E5, this.referenceDelegate = t(this), this.li = new x5(this), this.indexManager = new c5, this.remoteDocumentCache = (function (o) { return new A5(o) })((r => this.referenceDelegate.hi(r))), this.serializer = new l5(i), this.Pi = new b5(this.serializer) } start() { return Promise.resolve() } shutdown() { return this.ui = !1, Promise.resolve() } get started() { return this.ui } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(t) { return this.indexManager } getDocumentOverlayCache(t) { let i = this.overlays[t.toKey()]; return i || (i = new T5, this.overlays[t.toKey()] = i), i } getMutationQueue(t, i) { let r = this._i[t.toKey()]; return r || (r = new S5(i, this.referenceDelegate), this._i[t.toKey()] = r), r } getGlobalsCache() { return this.ci } getTargetCache() { return this.li } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.Pi } runTransaction(t, i, r) { dt("MemoryPersistence", "Starting transaction:", t); const o = new C5(this.ai.next()); return this.referenceDelegate.Ti(), r(o).next((u => this.referenceDelegate.Ii(o).next((() => u)))).toPromise().then((u => (o.raiseOnCommittedEvent(), u))) } Ei(t, i) { return st.or(Object.values(this._i).map((r => () => r.containsKey(t, i)))) } } class C5 extends $O { constructor(t) { super(), this.currentSequenceNumber = t } } class _y { constructor(t) { this.persistence = t, this.Ri = new vy, this.Ai = null } static Vi(t) { return new _y(t) } get di() { if (this.Ai) return this.Ai; throw At(60996) } addReference(t, i, r) { return this.Ri.addReference(r, i), this.di.delete(r.toString()), st.resolve() } removeReference(t, i, r) { return this.Ri.removeReference(r, i), this.di.add(r.toString()), st.resolve() } markPotentiallyOrphaned(t, i) { return this.di.add(i.toString()), st.resolve() } removeTarget(t, i) { this.Ri.Gr(i.targetId).forEach((o => this.di.add(o.toString()))); const r = this.persistence.getTargetCache(); return r.getMatchingKeysForTargetId(t, i.targetId).next((o => { o.forEach((u => this.di.add(u.toString()))) })).next((() => r.removeTargetData(t, i))) } Ti() { this.Ai = new Set } Ii(t) { const i = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return st.forEach(this.di, (r => { const o = bt.fromPath(r); return this.mi(t, o).next((u => { u || i.removeEntry(o, wt.min()) })) })).next((() => (this.Ai = null, i.apply(t)))) } updateLimboDocument(t, i) { return this.mi(t, i).next((r => { r ? this.di.delete(i.toString()) : this.di.add(i.toString()) })) } hi(t) { return 0 } mi(t, i) { return st.or([() => st.resolve(this.Ri.containsKey(i)), () => this.persistence.getTargetCache().containsKey(t, i), () => this.persistence.Ei(t, i)]) } } class bf { constructor(t, i) { this.persistence = t, this.fi = new Ea((r => tN(r.path)), ((r, o) => r.isEqual(o))), this.garbageCollector = g5(this, i) } static Vi(t, i) { return new bf(t, i) } Ti() { } Ii(t) { return st.resolve() } forEachTarget(t, i) { return this.persistence.getTargetCache().forEachTarget(t, i) } dr(t) { const i = this.pr(t); return this.persistence.getTargetCache().getTargetCount(t).next((r => i.next((o => r + o)))) } pr(t) { let i = 0; return this.mr(t, (r => { i++ })).next((() => i)) } mr(t, i) { return st.forEach(this.fi, ((r, o) => this.wr(t, r, o).next((u => u ? st.resolve() : i(o))))) } removeTargets(t, i, r) { return this.persistence.getTargetCache().removeTargets(t, i, r) } removeOrphanedDocuments(t, i) { let r = 0; const o = this.persistence.getRemoteDocumentCache(), u = o.newChangeBuffer(); return o.ni(t, (c => this.wr(t, c, i).next((d => { d || (r++, u.removeEntry(c, wt.min())) })))).next((() => u.apply(t))).next((() => r)) } markPotentiallyOrphaned(t, i) { return this.fi.set(i, t.currentSequenceNumber), st.resolve() } removeTarget(t, i) { const r = i.withSequenceNumber(t.currentSequenceNumber); return this.persistence.getTargetCache().updateTargetData(t, r) } addReference(t, i, r) { return this.fi.set(r, t.currentSequenceNumber), st.resolve() } removeReference(t, i, r) { return this.fi.set(r, t.currentSequenceNumber), st.resolve() } updateLimboDocument(t, i) { return this.fi.set(i, t.currentSequenceNumber), st.resolve() } hi(t) { let i = t.key.toString().length; return t.isFoundDocument() && (i += qh(t.data.value)), i } wr(t, i, r) { return st.or([() => this.persistence.Ei(t, i), () => this.persistence.getTargetCache().containsKey(t, i), () => { const o = this.fi.get(i); return st.resolve(o !== void 0 && o > r) }]) } getCacheSize(t) { return this.persistence.getRemoteDocumentCache().getSize(t) } } class by { constructor(t, i, r, o) { this.targetId = t, this.fromCache = i, this.Ts = r, this.Is = o } static Es(t, i) { let r = Ut(), o = Ut(); for (const u of i.docChanges) switch (u.type) { case 0: r = r.add(u.doc.key); break; case 1: o = o.add(u.doc.key) }return new by(t, i.fromCache, r, o) } } class R5 { constructor() { this._documentReadCount = 0 } get documentReadCount() { return this._documentReadCount } incrementDocumentReadCount(t) { this._documentReadCount += t } } class D5 { constructor() { this.Rs = !1, this.As = !1, this.Vs = 100, this.ds = (function () { return pI() ? 8 : ZO(dI()) > 0 ? 6 : 4 })() } initialize(t, i) { this.fs = t, this.indexManager = i, this.Rs = !0 } getDocumentsMatchingQuery(t, i, r, o) { const u = { result: null }; return this.gs(t, i).next((c => { u.result = c })).next((() => { if (!u.result) return this.ps(t, i, o, r).next((c => { u.result = c })) })).next((() => { if (u.result) return; const c = new R5; return this.ys(t, i, c).next((d => { if (u.result = d, this.As) return this.ws(t, i, c, d.size) })) })).next((() => u.result)) } ws(t, i, r, o) { return r.documentReadCount < this.Vs ? (go() <= qt.DEBUG && dt("QueryEngine", "SDK will not create cache indexes for query:", yo(i), "since it only creates cache indexes for collection contains", "more than or equal to", this.Vs, "documents"), st.resolve()) : (go() <= qt.DEBUG && dt("QueryEngine", "Query:", yo(i), "scans", r.documentReadCount, "local documents and returns", o, "documents as results."), r.documentReadCount > this.ds * o ? (go() <= qt.DEBUG && dt("QueryEngine", "The SDK decides to create cache indexes for query:", yo(i), "as using cache indexes may help improve performance."), this.indexManager.createTargetIndexes(t, Yi(i))) : st.resolve()) } gs(t, i) { if (wT(i)) return st.resolve(null); let r = Yi(i); return this.indexManager.getIndexType(t, r).next((o => o === 0 ? null : (i.limit !== null && o === 1 && (i = yf(i, null, "F"), r = Yi(i)), this.indexManager.getDocumentsMatchingTarget(t, r).next((u => { const c = Ut(...u); return this.fs.getDocuments(t, c).next((d => this.indexManager.getMinOffset(t, r).next((p => { const g = this.bs(i, d); return this.Ss(i, g, c, p.readTime) ? this.gs(t, yf(i, null, "F")) : this.Ds(t, g, i, p) })))) }))))) } ps(t, i, r, o) { return wT(i) || o.isEqual(wt.min()) ? st.resolve(null) : this.fs.getDocuments(t, r).next((u => { const c = this.bs(i, u); return this.Ss(i, c, r, o) ? st.resolve(null) : (go() <= qt.DEBUG && dt("QueryEngine", "Re-using previous result from %s to execute query: %s", o.toString(), yo(i)), this.Ds(t, c, i, KO(o, Ru)).next((d => d))) })) } bs(t, i) { let r = new He(iw(t)); return i.forEach(((o, u) => { kf(t, u) && (r = r.add(u)) })), r } Ss(t, i, r, o) { if (t.limit === null) return !1; if (r.size !== i.size) return !0; const u = t.limitType === "F" ? i.last() : i.first(); return !!u && (u.hasPendingWrites || u.version.compareTo(o) > 0) } ys(t, i, r) { return go() <= qt.DEBUG && dt("QueryEngine", "Using full collection scan to execute query:", yo(i)), this.fs.getDocumentsMatchingQuery(t, i, Tr.min(), r) } Ds(t, i, r, o) { return this.fs.getDocumentsMatchingQuery(t, r, o).next((u => (i.forEach((c => { u = u.insert(c.key, c) })), u))) } } const Ty = "LocalStore", V5 = 3e8; class M5 { constructor(t, i, r, o) { this.persistence = t, this.Cs = i, this.serializer = o, this.vs = new ge(jt), this.Fs = new Ea((u => hy(u)), fy), this.Ms = new Map, this.xs = t.getRemoteDocumentCache(), this.li = t.getTargetCache(), this.Pi = t.getBundleCache(), this.Os(r) } Os(t) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t), this.indexManager = this.persistence.getIndexManager(t), this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager), this.localDocuments = new _5(this.xs, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.xs.setIndexManager(this.indexManager), this.Cs.initialize(this.localDocuments, this.indexManager) } collectGarbage(t) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (i => t.collect(i, this.vs))) } } function I5(e, t, i, r) { return new M5(e, t, i, r) } async function Rw(e, t) { const i = Dt(e); return await i.persistence.runTransaction("Handle user change", "readonly", (r => { let o; return i.mutationQueue.getAllMutationBatches(r).next((u => (o = u, i.Os(t), i.mutationQueue.getAllMutationBatches(r)))).next((u => { const c = [], d = []; let p = Ut(); for (const g of o) { c.push(g.batchId); for (const v of g.mutations) p = p.add(v.key) } for (const g of u) { d.push(g.batchId); for (const v of g.mutations) p = p.add(v.key) } return i.localDocuments.getDocuments(r, p).next((g => ({ Ns: g, removedBatchIds: c, addedBatchIds: d }))) })) })) } function O5(e, t) { const i = Dt(e); return i.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (r => { const o = t.batch.keys(), u = i.xs.newChangeBuffer({ trackRemovals: !0 }); return (function (d, p, g, v) { const b = g.batch, E = b.keys(); let x = st.resolve(); return E.forEach((M => { x = x.next((() => v.getEntry(p, M))).next((j => { const z = g.docVersions.get(M); Xt(z !== null, 48541), j.version.compareTo(z) < 0 && (b.applyToRemoteDocument(j, g), j.isValidDocument() && (j.setReadTime(g.commitVersion), v.addEntry(j))) })) })), x.next((() => d.mutationQueue.removeMutationBatch(p, b))) })(i, r, t, u).next((() => u.apply(r))).next((() => i.mutationQueue.performConsistencyCheck(r))).next((() => i.documentOverlayCache.removeOverlaysForBatchId(r, o, t.batch.batchId))).next((() => i.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(r, (function (d) { let p = Ut(); for (let g = 0; g < d.mutationResults.length; ++g)d.mutationResults[g].transformResults.length > 0 && (p = p.add(d.batch.mutations[g].key)); return p })(t)))).next((() => i.localDocuments.getDocuments(r, o))) })) } function Dw(e) { const t = Dt(e); return t.persistence.runTransaction("Get last remote snapshot version", "readonly", (i => t.li.getLastRemoteSnapshotVersion(i))) } function N5(e, t) { const i = Dt(e), r = t.snapshotVersion; let o = i.vs; return i.persistence.runTransaction("Apply remote event", "readwrite-primary", (u => { const c = i.xs.newChangeBuffer({ trackRemovals: !0 }); o = i.vs; const d = []; t.targetChanges.forEach(((v, b) => { const E = o.get(b); if (!E) return; d.push(i.li.removeMatchingKeys(u, v.removedDocuments, b).next((() => i.li.addMatchingKeys(u, v.addedDocuments, b)))); let x = E.withSequenceNumber(u.currentSequenceNumber); t.targetMismatches.get(b) !== null ? x = x.withResumeToken(an.EMPTY_BYTE_STRING, wt.min()).withLastLimboFreeSnapshotVersion(wt.min()) : v.resumeToken.approximateByteSize() > 0 && (x = x.withResumeToken(v.resumeToken, r)), o = o.insert(b, x), (function (j, z, K) { return j.resumeToken.approximateByteSize() === 0 || z.snapshotVersion.toMicroseconds() - j.snapshotVersion.toMicroseconds() >= V5 ? !0 : K.addedDocuments.size + K.modifiedDocuments.size + K.removedDocuments.size > 0 })(E, x, v) && d.push(i.li.updateTargetData(u, x)) })); let p = xs(), g = Ut(); if (t.documentUpdates.forEach((v => { t.resolvedLimboDocuments.has(v) && d.push(i.persistence.referenceDelegate.updateLimboDocument(u, v)) })), d.push(P5(u, c, t.documentUpdates).next((v => { p = v.Bs, g = v.Ls }))), !r.isEqual(wt.min())) { const v = i.li.getLastRemoteSnapshotVersion(u).next((b => i.li.setTargetsMetadata(u, u.currentSequenceNumber, r))); d.push(v) } return st.waitFor(d).next((() => c.apply(u))).next((() => i.localDocuments.getLocalViewOfDocuments(u, p, g))).next((() => p)) })).then((u => (i.vs = o, u))) } function P5(e, t, i) { let r = Ut(), o = Ut(); return i.forEach((u => r = r.add(u))), t.getEntries(e, r).next((u => { let c = xs(); return i.forEach(((d, p) => { const g = u.get(d); p.isFoundDocument() !== g.isFoundDocument() && (o = o.add(d)), p.isNoDocument() && p.version.isEqual(wt.min()) ? (t.removeEntry(d, p.readTime), c = c.insert(d, p)) : !g.isValidDocument() || p.version.compareTo(g.version) > 0 || p.version.compareTo(g.version) === 0 && g.hasPendingWrites ? (t.addEntry(p), c = c.insert(d, p)) : dt(Ty, "Ignoring outdated watch update for ", d, ". Current version:", g.version, " Watch version:", p.version) })), { Bs: c, Ls: o } })) } function k5(e, t) { const i = Dt(e); return i.persistence.runTransaction("Get next mutation batch", "readonly", (r => (t === void 0 && (t = ly), i.mutationQueue.getNextMutationBatchAfterBatchId(r, t)))) } function L5(e, t) { const i = Dt(e); return i.persistence.runTransaction("Allocate target", "readwrite", (r => { let o; return i.li.getTargetData(r, t).next((u => u ? (o = u, st.resolve(o)) : i.li.allocateTargetId(r).next((c => (o = new hr(t, c, "TargetPurposeListen", r.currentSequenceNumber), i.li.addTargetData(r, o).next((() => o))))))) })).then((r => { const o = i.vs.get(r.targetId); return (o === null || r.snapshotVersion.compareTo(o.snapshotVersion) > 0) && (i.vs = i.vs.insert(r.targetId, r), i.Fs.set(t, r.targetId)), r })) } async function mg(e, t, i) { const r = Dt(e), o = r.vs.get(t), u = i ? "readwrite" : "readwrite-primary"; try { i || await r.persistence.runTransaction("Release target", u, (c => r.persistence.referenceDelegate.removeTarget(c, o))) } catch (c) { if (!Yo(c)) throw c; dt(Ty, `Failed to update sequence numbers for target ${t}: ${c}`) } r.vs = r.vs.remove(t), r.Fs.delete(o.target) } function zT(e, t, i) { const r = Dt(e); let o = wt.min(), u = Ut(); return r.persistence.runTransaction("Execute query", "readwrite", (c => (function (p, g, v) { const b = Dt(p), E = b.Fs.get(v); return E !== void 0 ? st.resolve(b.vs.get(E)) : b.li.getTargetData(g, v) })(r, c, Yi(t)).next((d => { if (d) return o = d.lastLimboFreeSnapshotVersion, r.li.getMatchingKeysForTargetId(c, d.targetId).next((p => { u = p })) })).next((() => r.Cs.getDocumentsMatchingQuery(c, t, i ? o : wt.min(), i ? u : Ut()))).next((d => (z5(r, EN(t), d), { documents: d, ks: u }))))) } function z5(e, t, i) { let r = e.Ms.get(t) || wt.min(); i.forEach(((o, u) => { u.readTime.compareTo(r) > 0 && (r = u.readTime) })), e.Ms.set(t, r) } class jT { constructor() { this.activeTargetIds = RN() } Qs(t) { this.activeTargetIds = this.activeTargetIds.add(t) } Gs(t) { this.activeTargetIds = this.activeTargetIds.delete(t) } Ws() { const t = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(t) } } class j5 { constructor() { this.vo = new jT, this.Fo = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(t) { } updateMutationState(t, i, r) { } addLocalQueryTarget(t, i = !0) { return i && this.vo.Qs(t), this.Fo[t] || "not-current" } updateQueryState(t, i, r) { this.Fo[t] = i } removeLocalQueryTarget(t) { this.vo.Gs(t) } isLocalQueryTarget(t) { return this.vo.activeTargetIds.has(t) } clearQueryState(t) { delete this.Fo[t] } getAllActiveQueryTargets() { return this.vo.activeTargetIds } isActiveQueryTarget(t) { return this.vo.activeTargetIds.has(t) } start() { return this.vo = new jT, Promise.resolve() } handleUserChange(t, i, r) { } setOnlineState(t) { } shutdown() { } writeSequenceNumber(t) { } notifyBundleLoaded(t) { } } class U5 { Mo(t) { } shutdown() { } } const UT = "ConnectivityMonitor"; class BT { constructor() { this.xo = () => this.Oo(), this.No = () => this.Bo(), this.Lo = [], this.ko() } Mo(t) { this.Lo.push(t) } shutdown() { window.removeEventListener("online", this.xo), window.removeEventListener("offline", this.No) } ko() { window.addEventListener("online", this.xo), window.addEventListener("offline", this.No) } Oo() { dt(UT, "Network connectivity changed: AVAILABLE"); for (const t of this.Lo) t(0) } Bo() { dt(UT, "Network connectivity changed: UNAVAILABLE"); for (const t of this.Lo) t(1) } static v() { return typeof window < "u" && window.addEventListener !== void 0 && window.removeEventListener !== void 0 } } let Oh = null; function pg() { return Oh === null ? Oh = (function () { return 268435456 + Math.round(2147483648 * Math.random()) })() : Oh++, "0x" + Oh.toString(16) } const Sp = "RestConnection", B5 = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery", ExecutePipeline: "executePipeline" }; class F5 { get Ko() { return !1 } constructor(t) { this.databaseInfo = t, this.databaseId = t.databaseId; const i = t.ssl ? "https" : "http", r = encodeURIComponent(this.databaseId.projectId), o = encodeURIComponent(this.databaseId.database); this.qo = i + "://" + t.host, this.Uo = `projects/${r}/databases/${o}`, this.$o = this.databaseId.database === mf ? `project_id=${r}` : `project_id=${r}&database_id=${o}` } Wo(t, i, r, o, u) { const c = pg(), d = this.Qo(t, i.toUriEncodedString()); dt(Sp, `Sending RPC '${t}' ${c}:`, d, r); const p = { "google-cloud-resource-prefix": this.Uo, "x-goog-request-params": this.$o }; this.Go(p, o, u); const { host: g } = new URL(d), v = sy(g); return this.zo(t, d, p, r, v).then((b => (dt(Sp, `Received RPC '${t}' ${c}: `, b), b)), (b => { throw ba(Sp, `RPC '${t}' ${c} failed with error: `, b, "url: ", d, "request:", r), b })) } jo(t, i, r, o, u, c) { return this.Wo(t, i, r, o, u) } Go(t, i, r) { t["X-Goog-Api-Client"] = (function () { return "gl-js/ fire/" + Ho })(), t["Content-Type"] = "text/plain", this.databaseInfo.appId && (t["X-Firebase-GMPID"] = this.databaseInfo.appId), i && i.headers.forEach(((o, u) => t[u] = o)), r && r.headers.forEach(((o, u) => t[u] = o)) } Qo(t, i) { const r = B5[t]; let o = `${this.qo}/v1/${i}:${r}`; return this.databaseInfo.apiKey && (o = `${o}?key=${encodeURIComponent(this.databaseInfo.apiKey)}`), o } terminate() { } } class q5 { constructor(t) { this.Ho = t.Ho, this.Jo = t.Jo } Zo(t) { this.Xo = t } Yo(t) { this.e_ = t } t_(t) { this.n_ = t } onMessage(t) { this.r_ = t } close() { this.Jo() } send(t) { this.Ho(t) } i_() { this.Xo() } s_() { this.e_() } o_(t) { this.n_(t) } __(t) { this.r_(t) } } const ln = "WebChannelConnection", ru = (e, t, i) => { e.listen(t, (r => { try { i(r) } catch (o) { setTimeout((() => { throw o }), 0) } })) }; class Co extends F5 { constructor(t) { super(t), this.a_ = [], this.forceLongPolling = t.forceLongPolling, this.autoDetectLongPolling = t.autoDetectLongPolling, this.useFetchStreams = t.useFetchStreams, this.longPollingOptions = t.longPollingOptions } static u_() { if (!Co.c_) { const t = OA(); ru(t, IA.STAT_EVENT, (i => { i.stat === ig.PROXY ? dt(ln, "STAT_EVENT: detected buffering proxy") : i.stat === ig.NOPROXY && dt(ln, "STAT_EVENT: detected no buffering proxy") })), Co.c_ = !0 } } zo(t, i, r, o, u) { const c = pg(); return new Promise(((d, p) => { const g = new VA; g.setWithCredentials(!0), g.listenOnce(MA.COMPLETE, (() => { try { switch (g.getLastErrorCode()) { case Fh.NO_ERROR: const b = g.getResponseJson(); dt(ln, `XHR for RPC '${t}' ${c} received:`, JSON.stringify(b)), d(b); break; case Fh.TIMEOUT: dt(ln, `RPC '${t}' ${c} timed out`), p(new ft(nt.DEADLINE_EXCEEDED, "Request time out")); break; case Fh.HTTP_ERROR: const E = g.getStatus(); if (dt(ln, `RPC '${t}' ${c} failed with status:`, E, "response text:", g.getResponseText()), E > 0) { let x = g.getResponseJson(); Array.isArray(x) && (x = x[0]); const M = x?.error; if (M && M.status && M.message) { const j = (function (K) { const it = K.toLowerCase().replace(/_/g, "-"); return Object.values(nt).indexOf(it) >= 0 ? it : nt.UNKNOWN })(M.status); p(new ft(j, M.message)) } else p(new ft(nt.UNKNOWN, "Server responded with status " + g.getStatus())) } else p(new ft(nt.UNAVAILABLE, "Connection failed.")); break; default: At(9055, { l_: t, streamId: c, h_: g.getLastErrorCode(), P_: g.getLastError() }) } } finally { dt(ln, `RPC '${t}' ${c} completed.`) } })); const v = JSON.stringify(o); dt(ln, `RPC '${t}' ${c} sending request:`, o), g.send(i, "POST", v, r, 15) })) } T_(t, i, r) { const o = pg(), u = [this.qo, "/", "google.firestore.v1.Firestore", "/", t, "/channel"], c = this.createWebChannelTransport(), d = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }, p = this.longPollingOptions.timeoutSeconds; p !== void 0 && (d.longPollingTimeout = Math.round(1e3 * p)), this.useFetchStreams && (d.useFetchStreams = !0), this.Go(d.initMessageHeaders, i, r), d.encodeInitMessageHeaders = !0; const g = u.join(""); dt(ln, `Creating RPC '${t}' stream ${o}: ${g}`, d); const v = c.createWebChannel(g, d); this.I_(v); let b = !1, E = !1; const x = new q5({ Ho: M => { E ? dt(ln, `Not sending because RPC '${t}' stream ${o} is closed:`, M) : (b || (dt(ln, `Opening RPC '${t}' stream ${o} transport.`), v.open(), b = !0), dt(ln, `RPC '${t}' stream ${o} sending:`, M), v.send(M)) }, Jo: () => v.close() }); return ru(v, ou.EventType.OPEN, (() => { E || (dt(ln, `RPC '${t}' stream ${o} transport opened.`), x.i_()) })), ru(v, ou.EventType.CLOSE, (() => { E || (E = !0, dt(ln, `RPC '${t}' stream ${o} transport closed`), x.o_(), this.E_(v)) })), ru(v, ou.EventType.ERROR, (M => { E || (E = !0, ba(ln, `RPC '${t}' stream ${o} transport errored. Name:`, M.name, "Message:", M.message), x.o_(new ft(nt.UNAVAILABLE, "The operation could not be completed"))) })), ru(v, ou.EventType.MESSAGE, (M => { if (!E) { const j = M.data[0]; Xt(!!j, 16349); const z = j, K = z?.error || z[0]?.error; if (K) { dt(ln, `RPC '${t}' stream ${o} received error:`, K); const it = K.status; let X = (function (ht) { const R = ke[ht]; if (R !== void 0) return pw(R) })(it), at = K.message; it === "NOT_FOUND" && at.includes("database") && at.includes("does not exist") && at.includes(this.databaseId.database) && ba(`Database '${this.databaseId.database}' not found. Please check your project configuration.`), X === void 0 && (X = nt.INTERNAL, at = "Unknown error status: " + it + " with message " + K.message), E = !0, x.o_(new ft(X, at)), v.close() } else dt(ln, `RPC '${t}' stream ${o} received:`, j), x.__(j) } })), Co.u_(), setTimeout((() => { x.s_() }), 0), x } terminate() { this.a_.forEach((t => t.close())), this.a_ = [] } I_(t) { this.a_.push(t) } E_(t) { this.a_ = this.a_.filter((i => i === t)) } Go(t, i, r) { super.Go(t, i, r), this.databaseInfo.apiKey && (t["x-goog-api-key"] = this.databaseInfo.apiKey) } createWebChannelTransport() { return NA() } } function H5(e) { return new Co(e) } function Ap() { return typeof document < "u" ? document : null } function Uf(e) { return new QN(e, !0) } Co.c_ = !1; class Vw { constructor(t, i, r = 1e3, o = 1.5, u = 6e4) { this.Ci = t, this.timerId = i, this.R_ = r, this.A_ = o, this.V_ = u, this.d_ = 0, this.m_ = null, this.f_ = Date.now(), this.reset() } reset() { this.d_ = 0 } g_() { this.d_ = this.V_ } p_(t) { this.cancel(); const i = Math.floor(this.d_ + this.y_()), r = Math.max(0, Date.now() - this.f_), o = Math.max(0, i - r); o > 0 && dt("ExponentialBackoff", `Backing off for ${o} ms (base delay: ${this.d_} ms, delay with jitter: ${i} ms, last attempt: ${r} ms ago)`), this.m_ = this.Ci.enqueueAfterDelay(this.timerId, o, (() => (this.f_ = Date.now(), t()))), this.d_ *= this.A_, this.d_ < this.R_ && (this.d_ = this.R_), this.d_ > this.V_ && (this.d_ = this.V_) } w_() { this.m_ !== null && (this.m_.skipDelay(), this.m_ = null) } cancel() { this.m_ !== null && (this.m_.cancel(), this.m_ = null) } y_() { return (Math.random() - .5) * this.d_ } } const FT = "PersistentStream"; class Mw { constructor(t, i, r, o, u, c, d, p) { this.Ci = t, this.b_ = r, this.S_ = o, this.connection = u, this.authCredentialsProvider = c, this.appCheckCredentialsProvider = d, this.listener = p, this.state = 0, this.D_ = 0, this.C_ = null, this.v_ = null, this.stream = null, this.F_ = 0, this.M_ = new Vw(t, i) } x_() { return this.state === 1 || this.state === 5 || this.O_() } O_() { return this.state === 2 || this.state === 3 } start() { this.F_ = 0, this.state !== 4 ? this.auth() : this.N_() } async stop() { this.x_() && await this.close(0) } B_() { this.state = 0, this.M_.reset() } L_() { this.O_() && this.C_ === null && (this.C_ = this.Ci.enqueueAfterDelay(this.b_, 6e4, (() => this.k_()))) } K_(t) { this.q_(), this.stream.send(t) } async k_() { if (this.O_()) return this.close(0) } q_() { this.C_ && (this.C_.cancel(), this.C_ = null) } U_() { this.v_ && (this.v_.cancel(), this.v_ = null) } async close(t, i) { this.q_(), this.U_(), this.M_.cancel(), this.D_++, t !== 4 ? this.M_.reset() : i && i.code === nt.RESOURCE_EXHAUSTED ? (ws(i.toString()), ws("Using maximum backoff delay to prevent overloading the backend."), this.M_.g_()) : i && i.code === nt.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.W_(), this.stream.close(), this.stream = null), this.state = t, await this.listener.t_(i) } W_() { } auth() { this.state = 1; const t = this.Q_(this.D_), i = this.D_; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then((([r, o]) => { this.D_ === i && this.G_(r, o) }), (r => { t((() => { const o = new ft(nt.UNKNOWN, "Fetching auth token failed: " + r.message); return this.z_(o) })) })) } G_(t, i) { const r = this.Q_(this.D_); this.stream = this.j_(t, i), this.stream.Zo((() => { r((() => this.listener.Zo())) })), this.stream.Yo((() => { r((() => (this.state = 2, this.v_ = this.Ci.enqueueAfterDelay(this.S_, 1e4, (() => (this.O_() && (this.state = 3), Promise.resolve()))), this.listener.Yo()))) })), this.stream.t_((o => { r((() => this.z_(o))) })), this.stream.onMessage((o => { r((() => ++this.F_ == 1 ? this.H_(o) : this.onNext(o))) })) } N_() { this.state = 5, this.M_.p_((async () => { this.state = 0, this.start() })) } z_(t) { return dt(FT, `close with error: ${t}`), this.stream = null, this.close(4, t) } Q_(t) { return i => { this.Ci.enqueueAndForget((() => this.D_ === t ? i() : (dt(FT, "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()))) } } } class G5 extends Mw { constructor(t, i, r, o, u, c) { super(t, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", i, r, o, c), this.serializer = u } j_(t, i) { return this.connection.T_("Listen", t, i) } H_(t) { return this.onNext(t) } onNext(t) { this.M_.reset(); const i = $N(this.serializer, t), r = (function (u) { if (!("targetChange" in u)) return wt.min(); const c = u.targetChange; return c.targetIds && c.targetIds.length ? wt.min() : c.readTime ? Ki(c.readTime) : wt.min() })(t); return this.listener.J_(i, r) } Z_(t) { const i = {}; i.database = dg(this.serializer), i.addTarget = (function (u, c) { let d; const p = c.target; if (d = lg(p) ? { documents: t5(u, p) } : { query: e5(u, p).ft }, d.targetId = c.targetId, c.resumeToken.approximateByteSize() > 0) { d.resumeToken = vw(u, c.resumeToken); const g = cg(u, c.expectedCount); g !== null && (d.expectedCount = g) } else if (c.snapshotVersion.compareTo(wt.min()) > 0) { d.readTime = _f(u, c.snapshotVersion.toTimestamp()); const g = cg(u, c.expectedCount); g !== null && (d.expectedCount = g) } return d })(this.serializer, t); const r = i5(this.serializer, t); r && (i.labels = r), this.K_(i) } X_(t) { const i = {}; i.database = dg(this.serializer), i.removeTarget = t, this.K_(i) } } class Y5 extends Mw { constructor(t, i, r, o, u, c) { super(t, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", i, r, o, c), this.serializer = u } get Y_() { return this.F_ > 0 } start() { this.lastStreamToken = void 0, super.start() } W_() { this.Y_ && this.ea([]) } j_(t, i) { return this.connection.T_("Write", t, i) } H_(t) { return Xt(!!t.streamToken, 31322), this.lastStreamToken = t.streamToken, Xt(!t.writeResults || t.writeResults.length === 0, 55816), this.listener.ta() } onNext(t) { Xt(!!t.streamToken, 12678), this.lastStreamToken = t.streamToken, this.M_.reset(); const i = JN(t.writeResults, t.commitTime), r = Ki(t.commitTime); return this.listener.na(r, i) } ra() { const t = {}; t.database = dg(this.serializer), this.K_(t) } ea(t) { const i = { streamToken: this.lastStreamToken, writes: t.map((r => ZN(this.serializer, r))) }; this.K_(i) } } class K5 { } class Q5 extends K5 { constructor(t, i, r, o) { super(), this.authCredentials = t, this.appCheckCredentials = i, this.connection = r, this.serializer = o, this.ia = !1 } sa() { if (this.ia) throw new ft(nt.FAILED_PRECONDITION, "The client has already been terminated.") } Wo(t, i, r, o) { return this.sa(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((([u, c]) => this.connection.Wo(t, hg(i, r), o, u, c))).catch((u => { throw u.name === "FirebaseError" ? (u.code === nt.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), u) : new ft(nt.UNKNOWN, u.toString()) })) } jo(t, i, r, o, u) { return this.sa(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then((([c, d]) => this.connection.jo(t, hg(i, r), o, c, d, u))).catch((c => { throw c.name === "FirebaseError" ? (c.code === nt.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), c) : new ft(nt.UNKNOWN, c.toString()) })) } terminate() { this.ia = !0, this.connection.terminate() } } function X5(e, t, i, r) { return new Q5(e, t, i, r) } class W5 {
  constructor(t, i) { this.asyncQueue = t, this.onlineStateHandler = i, this.state = "Unknown", this.oa = 0, this._a = null, this.aa = !0 } ua() { this.oa === 0 && (this.ca("Unknown"), this._a = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, (() => (this._a = null, this.la("Backend didn't respond within 10 seconds."), this.ca("Offline"), Promise.resolve())))) } ha(t) { this.state === "Online" ? this.ca("Unknown") : (this.oa++, this.oa >= 1 && (this.Pa(), this.la(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.ca("Offline"))) } set(t) { this.Pa(), this.oa = 0, t === "Online" && (this.aa = !1), this.ca(t) } ca(t) { t !== this.state && (this.state = t, this.onlineStateHandler(t)) } la(t) {
    const i = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`; this.aa ? (ws(i), this.aa = !1) : dt("OnlineStateTracker", i)
  } Pa() { this._a !== null && (this._a.cancel(), this._a = null) }
} const Ta = "RemoteStore"; class $5 { constructor(t, i, r, o, u) { this.localStore = t, this.datastore = i, this.asyncQueue = r, this.remoteSyncer = {}, this.Ta = [], this.Ia = new Map, this.Ea = new Set, this.Ra = [], this.Aa = u, this.Aa.Mo((c => { r.enqueueAndForget((async () => { Sa(this) && (dt(Ta, "Restarting streams for network reachability change."), await (async function (p) { const g = Dt(p); g.Ea.add(4), await Hu(g), g.Va.set("Unknown"), g.Ea.delete(4), await Bf(g) })(this)) })) })), this.Va = new W5(r, o) } } async function Bf(e) { if (Sa(e)) for (const t of e.Ra) await t(!0) } async function Hu(e) { for (const t of e.Ra) await t(!1) } function Iw(e, t) { const i = Dt(e); i.Ia.has(t.targetId) || (i.Ia.set(t.targetId, t), wy(i) ? Ay(i) : Qo(i).O_() && Sy(i, t)) } function Ey(e, t) { const i = Dt(e), r = Qo(i); i.Ia.delete(t), r.O_() && Ow(i, t), i.Ia.size === 0 && (r.O_() ? r.L_() : Sa(i) && i.Va.set("Unknown")) } function Sy(e, t) { if (e.da.$e(t.targetId), t.resumeToken.approximateByteSize() > 0 || t.snapshotVersion.compareTo(wt.min()) > 0) { const i = e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size; t = t.withExpectedCount(i) } Qo(e).Z_(t) } function Ow(e, t) { e.da.$e(t), Qo(e).X_(t) } function Ay(e) { e.da = new HN({ getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t), At: t => e.Ia.get(t) || null, ht: () => e.datastore.serializer.databaseId }), Qo(e).start(), e.Va.ua() } function wy(e) { return Sa(e) && !Qo(e).x_() && e.Ia.size > 0 } function Sa(e) { return Dt(e).Ea.size === 0 } function Nw(e) { e.da = void 0 } async function Z5(e) { e.Va.set("Online") } async function J5(e) { e.Ia.forEach(((t, i) => { Sy(e, t) })) } async function t9(e, t) { Nw(e), wy(e) ? (e.Va.ha(t), Ay(e)) : e.Va.set("Unknown") } async function e9(e, t, i) { if (e.Va.set("Online"), t instanceof yw && t.state === 2 && t.cause) try { await (async function (o, u) { const c = u.cause; for (const d of u.targetIds) o.Ia.has(d) && (await o.remoteSyncer.rejectListen(d, c), o.Ia.delete(d), o.da.removeTarget(d)) })(e, t) } catch (r) { dt(Ta, "Failed to remove targets %s: %s ", t.targetIds.join(","), r), await Tf(e, r) } else if (t instanceof Yh ? e.da.Xe(t) : t instanceof gw ? e.da.st(t) : e.da.tt(t), !i.isEqual(wt.min())) try { const r = await Dw(e.localStore); i.compareTo(r) >= 0 && await (function (u, c) { const d = u.da.Tt(c); return d.targetChanges.forEach(((p, g) => { if (p.resumeToken.approximateByteSize() > 0) { const v = u.Ia.get(g); v && u.Ia.set(g, v.withResumeToken(p.resumeToken, c)) } })), d.targetMismatches.forEach(((p, g) => { const v = u.Ia.get(p); if (!v) return; u.Ia.set(p, v.withResumeToken(an.EMPTY_BYTE_STRING, v.snapshotVersion)), Ow(u, p); const b = new hr(v.target, p, g, v.sequenceNumber); Sy(u, b) })), u.remoteSyncer.applyRemoteEvent(d) })(e, i) } catch (r) { dt(Ta, "Failed to raise snapshot:", r), await Tf(e, r) } } async function Tf(e, t, i) { if (!Yo(t)) throw t; e.Ea.add(1), await Hu(e), e.Va.set("Offline"), i || (i = () => Dw(e.localStore)), e.asyncQueue.enqueueRetryable((async () => { dt(Ta, "Retrying IndexedDB access"), await i(), e.Ea.delete(1), await Bf(e) })) } function Pw(e, t) { return t().catch((i => Tf(e, i, t))) } async function Ff(e) { const t = Dt(e), i = wr(t); let r = t.Ta.length > 0 ? t.Ta[t.Ta.length - 1].batchId : ly; for (; n9(t);)try { const o = await k5(t.localStore, r); if (o === null) { t.Ta.length === 0 && i.L_(); break } r = o.batchId, i9(t, o) } catch (o) { await Tf(t, o) } kw(t) && Lw(t) } function n9(e) { return Sa(e) && e.Ta.length < 10 } function i9(e, t) { e.Ta.push(t); const i = wr(e); i.O_() && i.Y_ && i.ea(t.mutations) } function kw(e) { return Sa(e) && !wr(e).x_() && e.Ta.length > 0 } function Lw(e) { wr(e).start() } async function s9(e) { wr(e).ra() } async function r9(e) { const t = wr(e); for (const i of e.Ta) t.ea(i.mutations) } async function a9(e, t, i) { const r = e.Ta.shift(), o = py.from(r, t, i); await Pw(e, (() => e.remoteSyncer.applySuccessfulWrite(o))), await Ff(e) } async function o9(e, t) { t && wr(e).Y_ && await (async function (r, o) { if ((function (c) { return BN(c) && c !== nt.ABORTED })(o.code)) { const u = r.Ta.shift(); wr(r).B_(), await Pw(r, (() => r.remoteSyncer.rejectFailedWrite(u.batchId, o))), await Ff(r) } })(e, t), kw(e) && Lw(e) } async function qT(e, t) { const i = Dt(e); i.asyncQueue.verifyOperationInProgress(), dt(Ta, "RemoteStore received new credentials"); const r = Sa(i); i.Ea.add(3), await Hu(i), r && i.Va.set("Unknown"), await i.remoteSyncer.handleCredentialChange(t), i.Ea.delete(3), await Bf(i) } async function l9(e, t) { const i = Dt(e); t ? (i.Ea.delete(2), await Bf(i)) : t || (i.Ea.add(2), await Hu(i), i.Va.set("Unknown")) } function Qo(e) { return e.ma || (e.ma = (function (i, r, o) { const u = Dt(i); return u.sa(), new G5(r, u.connection, u.authCredentials, u.appCheckCredentials, u.serializer, o) })(e.datastore, e.asyncQueue, { Zo: Z5.bind(null, e), Yo: J5.bind(null, e), t_: t9.bind(null, e), J_: e9.bind(null, e) }), e.Ra.push((async t => { t ? (e.ma.B_(), wy(e) ? Ay(e) : e.Va.set("Unknown")) : (await e.ma.stop(), Nw(e)) }))), e.ma } function wr(e) { return e.fa || (e.fa = (function (i, r, o) { const u = Dt(i); return u.sa(), new Y5(r, u.connection, u.authCredentials, u.appCheckCredentials, u.serializer, o) })(e.datastore, e.asyncQueue, { Zo: () => Promise.resolve(), Yo: s9.bind(null, e), t_: o9.bind(null, e), ta: r9.bind(null, e), na: a9.bind(null, e) }), e.Ra.push((async t => { t ? (e.fa.B_(), await Ff(e)) : (await e.fa.stop(), e.Ta.length > 0 && (dt(Ta, `Stopping write stream with ${e.Ta.length} pending writes`), e.Ta = [])) }))), e.fa } class xy { constructor(t, i, r, o, u) { this.asyncQueue = t, this.timerId = i, this.targetTimeMs = r, this.op = o, this.removalCallback = u, this.deferred = new ya, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((c => { })) } get promise() { return this.deferred.promise } static createAndSchedule(t, i, r, o, u) { const c = Date.now() + r, d = new xy(t, i, c, o, u); return d.start(r), d } start(t) { this.timerHandle = setTimeout((() => this.handleDelayElapsed()), t) } skipDelay() { return this.handleDelayElapsed() } cancel(t) { this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new ft(nt.CANCELLED, "Operation cancelled" + (t ? ": " + t : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget((() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t => this.deferred.resolve(t)))) : Promise.resolve())) } clearTimeout() { this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function Cy(e, t) { if (ws("AsyncQueue", `${t}: ${e}`), Yo(e)) return new ft(nt.UNAVAILABLE, `${t}: ${e}`); throw e } class Ro {
  static emptySet(t) { return new Ro(t.comparator) } constructor(t) { this.comparator = t ? (i, r) => t(i, r) || bt.comparator(i.key, r.key) : (i, r) => bt.comparator(i.key, r.key), this.keyedMap = lu(), this.sortedSet = new ge(this.comparator) } has(t) { return this.keyedMap.get(t) != null } get(t) { return this.keyedMap.get(t) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(t) { const i = this.keyedMap.get(t); return i ? this.sortedSet.indexOf(i) : -1 } get size() { return this.sortedSet.size } forEach(t) { this.sortedSet.inorderTraversal(((i, r) => (t(i), !1))) } add(t) { const i = this.delete(t.key); return i.copy(i.keyedMap.insert(t.key, t), i.sortedSet.insert(t, null)) } delete(t) { const i = this.get(t); return i ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(i)) : this } isEqual(t) { if (!(t instanceof Ro) || this.size !== t.size) return !1; const i = this.sortedSet.getIterator(), r = t.sortedSet.getIterator(); for (; i.hasNext();) { const o = i.getNext().key, u = r.getNext().key; if (!o.isEqual(u)) return !1 } return !0 } toString() {
    const t = []; return this.forEach((i => { t.push(i.toString()) })), t.length === 0 ? "DocumentSet ()" : `DocumentSet (
  `+ t.join(`  
`) + `
)`} copy(t, i) { const r = new Ro; return r.comparator = this.comparator, r.keyedMap = t, r.sortedSet = i, r }
} class HT { constructor() { this.ga = new ge(bt.comparator) } track(t) { const i = t.doc.key, r = this.ga.get(i); r ? t.type !== 0 && r.type === 3 ? this.ga = this.ga.insert(i, t) : t.type === 3 && r.type !== 1 ? this.ga = this.ga.insert(i, { type: r.type, doc: t.doc }) : t.type === 2 && r.type === 2 ? this.ga = this.ga.insert(i, { type: 2, doc: t.doc }) : t.type === 2 && r.type === 0 ? this.ga = this.ga.insert(i, { type: 0, doc: t.doc }) : t.type === 1 && r.type === 0 ? this.ga = this.ga.remove(i) : t.type === 1 && r.type === 2 ? this.ga = this.ga.insert(i, { type: 1, doc: r.doc }) : t.type === 0 && r.type === 1 ? this.ga = this.ga.insert(i, { type: 2, doc: t.doc }) : At(63341, { Vt: t, pa: r }) : this.ga = this.ga.insert(i, t) } ya() { const t = []; return this.ga.inorderTraversal(((i, r) => { t.push(r) })), t } } class Po { constructor(t, i, r, o, u, c, d, p, g) { this.query = t, this.docs = i, this.oldDocs = r, this.docChanges = o, this.mutatedKeys = u, this.fromCache = c, this.syncStateChanged = d, this.excludesMetadataChanges = p, this.hasCachedResults = g } static fromInitialDocuments(t, i, r, o, u) { const c = []; return i.forEach((d => { c.push({ type: 0, doc: d }) })), new Po(t, i, Ro.emptySet(i), c, r, o, !0, !1, u) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(t) { if (!(this.fromCache === t.fromCache && this.hasCachedResults === t.hasCachedResults && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && Pf(this.query, t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1; const i = this.docChanges, r = t.docChanges; if (i.length !== r.length) return !1; for (let o = 0; o < i.length; o++)if (i[o].type !== r[o].type || !i[o].doc.isEqual(r[o].doc)) return !1; return !0 } } class u9 { constructor() { this.wa = void 0, this.ba = [] } Sa() { return this.ba.some((t => t.Da())) } } class c9 { constructor() { this.queries = GT(), this.onlineState = "Unknown", this.Ca = new Set } terminate() { (function (i, r) { const o = Dt(i), u = o.queries; o.queries = GT(), u.forEach(((c, d) => { for (const p of d.ba) p.onError(r) })) })(this, new ft(nt.ABORTED, "Firestore shutting down")) } } function GT() { return new Ea((e => nw(e)), Pf) } async function h9(e, t) { const i = Dt(e); let r = 3; const o = t.query; let u = i.queries.get(o); u ? !u.Sa() && t.Da() && (r = 2) : (u = new u9, r = t.Da() ? 0 : 1); try { switch (r) { case 0: u.wa = await i.onListen(o, !0); break; case 1: u.wa = await i.onListen(o, !1); break; case 2: await i.onFirstRemoteStoreListen(o) } } catch (c) { const d = Cy(c, `Initialization of query '${yo(t.query)}' failed`); return void t.onError(d) } i.queries.set(o, u), u.ba.push(t), t.va(i.onlineState), u.wa && t.Fa(u.wa) && Ry(i) } async function f9(e, t) { const i = Dt(e), r = t.query; let o = 3; const u = i.queries.get(r); if (u) { const c = u.ba.indexOf(t); c >= 0 && (u.ba.splice(c, 1), u.ba.length === 0 ? o = t.Da() ? 0 : 1 : !u.Sa() && t.Da() && (o = 2)) } switch (o) { case 0: return i.queries.delete(r), i.onUnlisten(r, !0); case 1: return i.queries.delete(r), i.onUnlisten(r, !1); case 2: return i.onLastRemoteStoreUnlisten(r); default: return } } function d9(e, t) { const i = Dt(e); let r = !1; for (const o of t) { const u = o.query, c = i.queries.get(u); if (c) { for (const d of c.ba) d.Fa(o) && (r = !0); c.wa = o } } r && Ry(i) } function m9(e, t, i) { const r = Dt(e), o = r.queries.get(t); if (o) for (const u of o.ba) u.onError(i); r.queries.delete(t) } function Ry(e) { e.Ca.forEach((t => { t.next() })) } var gg, YT; (YT = gg || (gg = {})).Ma = "default", YT.Cache = "cache"; class p9 { constructor(t, i, r) { this.query = t, this.xa = i, this.Oa = !1, this.Na = null, this.onlineState = "Unknown", this.options = r || {} } Fa(t) { if (!this.options.includeMetadataChanges) { const r = []; for (const o of t.docChanges) o.type !== 3 && r.push(o); t = new Po(t.query, t.docs, t.oldDocs, r, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0, t.hasCachedResults) } let i = !1; return this.Oa ? this.Ba(t) && (this.xa.next(t), i = !0) : this.La(t, this.onlineState) && (this.ka(t), i = !0), this.Na = t, i } onError(t) { this.xa.error(t) } va(t) { this.onlineState = t; let i = !1; return this.Na && !this.Oa && this.La(this.Na, t) && (this.ka(this.Na), i = !0), i } La(t, i) { if (!t.fromCache || !this.Da()) return !0; const r = i !== "Offline"; return (!this.options.Ka || !r) && (!t.docs.isEmpty() || t.hasCachedResults || i === "Offline") } Ba(t) { if (t.docChanges.length > 0) return !0; const i = this.Na && this.Na.hasPendingWrites !== t.hasPendingWrites; return !(!t.syncStateChanged && !i) && this.options.includeMetadataChanges === !0 } ka(t) { t = Po.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache, t.hasCachedResults), this.Oa = !0, this.xa.next(t) } Da() { return this.options.source !== gg.Cache } } class zw { constructor(t) { this.key = t } } class jw { constructor(t) { this.key = t } } class g9 { constructor(t, i) { this.query = t, this.Za = i, this.Xa = null, this.hasCachedResults = !1, this.current = !1, this.Ya = Ut(), this.mutatedKeys = Ut(), this.eu = iw(t), this.tu = new Ro(this.eu) } get nu() { return this.Za } ru(t, i) { const r = i ? i.iu : new HT, o = i ? i.tu : this.tu; let u = i ? i.mutatedKeys : this.mutatedKeys, c = o, d = !1; const p = this.query.limitType === "F" && o.size === this.query.limit ? o.last() : null, g = this.query.limitType === "L" && o.size === this.query.limit ? o.first() : null; if (t.inorderTraversal(((v, b) => { const E = o.get(v), x = kf(this.query, b) ? b : null, M = !!E && this.mutatedKeys.has(E.key), j = !!x && (x.hasLocalMutations || this.mutatedKeys.has(x.key) && x.hasCommittedMutations); let z = !1; E && x ? E.data.isEqual(x.data) ? M !== j && (r.track({ type: 3, doc: x }), z = !0) : this.su(E, x) || (r.track({ type: 2, doc: x }), z = !0, (p && this.eu(x, p) > 0 || g && this.eu(x, g) < 0) && (d = !0)) : !E && x ? (r.track({ type: 0, doc: x }), z = !0) : E && !x && (r.track({ type: 1, doc: E }), z = !0, (p || g) && (d = !0)), z && (x ? (c = c.add(x), u = j ? u.add(v) : u.delete(v)) : (c = c.delete(v), u = u.delete(v))) })), this.query.limit !== null) for (; c.size > this.query.limit;) { const v = this.query.limitType === "F" ? c.last() : c.first(); c = c.delete(v.key), u = u.delete(v.key), r.track({ type: 1, doc: v }) } return { tu: c, iu: r, Ss: d, mutatedKeys: u } } su(t, i) { return t.hasLocalMutations && i.hasCommittedMutations && !i.hasLocalMutations } applyChanges(t, i, r, o) { const u = this.tu; this.tu = t.tu, this.mutatedKeys = t.mutatedKeys; const c = t.iu.ya(); c.sort(((v, b) => (function (x, M) { const j = z => { switch (z) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return At(20277, { Vt: z }) } }; return j(x) - j(M) })(v.type, b.type) || this.eu(v.doc, b.doc))), this.ou(r), o = o ?? !1; const d = i && !o ? this._u() : [], p = this.Ya.size === 0 && this.current && !o ? 1 : 0, g = p !== this.Xa; return this.Xa = p, c.length !== 0 || g ? { snapshot: new Po(this.query, t.tu, u, c, t.mutatedKeys, p === 0, g, !1, !!r && r.resumeToken.approximateByteSize() > 0), au: d } : { au: d } } va(t) { return this.current && t === "Offline" ? (this.current = !1, this.applyChanges({ tu: this.tu, iu: new HT, mutatedKeys: this.mutatedKeys, Ss: !1 }, !1)) : { au: [] } } uu(t) { return !this.Za.has(t) && !!this.tu.has(t) && !this.tu.get(t).hasLocalMutations } ou(t) { t && (t.addedDocuments.forEach((i => this.Za = this.Za.add(i))), t.modifiedDocuments.forEach((i => { })), t.removedDocuments.forEach((i => this.Za = this.Za.delete(i))), this.current = t.current) } _u() { if (!this.current) return []; const t = this.Ya; this.Ya = Ut(), this.tu.forEach((r => { this.uu(r.key) && (this.Ya = this.Ya.add(r.key)) })); const i = []; return t.forEach((r => { this.Ya.has(r) || i.push(new jw(r)) })), this.Ya.forEach((r => { t.has(r) || i.push(new zw(r)) })), i } cu(t) { this.Za = t.ks, this.Ya = Ut(); const i = this.ru(t.documents); return this.applyChanges(i, !0) } lu() { return Po.fromInitialDocuments(this.query, this.tu, this.mutatedKeys, this.Xa === 0, this.hasCachedResults) } } const Dy = "SyncEngine"; class y9 { constructor(t, i, r) { this.query = t, this.targetId = i, this.view = r } } class v9 { constructor(t) { this.key = t, this.hu = !1 } } class _9 { constructor(t, i, r, o, u, c) { this.localStore = t, this.remoteStore = i, this.eventManager = r, this.sharedClientState = o, this.currentUser = u, this.maxConcurrentLimboResolutions = c, this.Pu = {}, this.Tu = new Ea((d => nw(d)), Pf), this.Iu = new Map, this.Eu = new Set, this.Ru = new ge(bt.comparator), this.Au = new Map, this.Vu = new vy, this.du = {}, this.mu = new Map, this.fu = No.ar(), this.onlineState = "Unknown", this.gu = void 0 } get isPrimaryClient() { return this.gu === !0 } } async function b9(e, t, i = !0) { const r = Gw(e); let o; const u = r.Tu.get(t); return u ? (r.sharedClientState.addLocalQueryTarget(u.targetId), o = u.view.lu()) : o = await Uw(r, t, i, !0), o } async function T9(e, t) { const i = Gw(e); await Uw(i, t, !0, !1) } async function Uw(e, t, i, r) { const o = await L5(e.localStore, Yi(t)), u = o.targetId, c = e.sharedClientState.addLocalQueryTarget(u, i); let d; return r && (d = await E9(e, t, u, c === "current", o.resumeToken)), e.isPrimaryClient && i && Iw(e.remoteStore, o), d } async function E9(e, t, i, r, o) { e.pu = (b, E, x) => (async function (j, z, K, it) { let X = z.view.ru(K); X.Ss && (X = await zT(j.localStore, z.query, !1).then((({ documents: R }) => z.view.ru(R, X)))); const at = it && it.targetChanges.get(z.targetId), lt = it && it.targetMismatches.get(z.targetId) != null, ht = z.view.applyChanges(X, j.isPrimaryClient, at, lt); return QT(j, z.targetId, ht.au), ht.snapshot })(e, b, E, x); const u = await zT(e.localStore, t, !0), c = new g9(t, u.ks), d = c.ru(u.documents), p = qu.createSynthesizedTargetChangeForCurrentChange(i, r && e.onlineState !== "Offline", o), g = c.applyChanges(d, e.isPrimaryClient, p); QT(e, i, g.au); const v = new y9(t, i, c); return e.Tu.set(t, v), e.Iu.has(i) ? e.Iu.get(i).push(t) : e.Iu.set(i, [t]), g.snapshot } async function S9(e, t, i) { const r = Dt(e), o = r.Tu.get(t), u = r.Iu.get(o.targetId); if (u.length > 1) return r.Iu.set(o.targetId, u.filter((c => !Pf(c, t)))), void r.Tu.delete(t); r.isPrimaryClient ? (r.sharedClientState.removeLocalQueryTarget(o.targetId), r.sharedClientState.isActiveQueryTarget(o.targetId) || await mg(r.localStore, o.targetId, !1).then((() => { r.sharedClientState.clearQueryState(o.targetId), i && Ey(r.remoteStore, o.targetId), yg(r, o.targetId) })).catch(Go)) : (yg(r, o.targetId), await mg(r.localStore, o.targetId, !0)) } async function A9(e, t) { const i = Dt(e), r = i.Tu.get(t), o = i.Iu.get(r.targetId); i.isPrimaryClient && o.length === 1 && (i.sharedClientState.removeLocalQueryTarget(r.targetId), Ey(i.remoteStore, r.targetId)) } async function w9(e, t, i) { const r = I9(e); try { const o = await (function (c, d) { const p = Dt(c), g = he.now(), v = d.reduce(((x, M) => x.add(M.key)), Ut()); let b, E; return p.persistence.runTransaction("Locally write mutations", "readwrite", (x => { let M = xs(), j = Ut(); return p.xs.getEntries(x, v).next((z => { M = z, M.forEach(((K, it) => { it.isValidDocument() || (j = j.add(K)) })) })).next((() => p.localDocuments.getOverlayedDocuments(x, M))).next((z => { b = z; const K = []; for (const it of d) { const X = kN(it, b.get(it.key).overlayedDocument); X != null && K.push(new Vr(it.key, X, QA(X.value.mapValue), mi.exists(!0))) } return p.mutationQueue.addMutationBatch(x, g, K, d) })).next((z => { E = z; const K = z.applyToLocalDocumentSet(b, j); return p.documentOverlayCache.saveOverlays(x, z.batchId, K) })) })).then((() => ({ batchId: E.batchId, changes: rw(b) }))) })(r.localStore, t); r.sharedClientState.addPendingMutation(o.batchId), (function (c, d, p) { let g = c.du[c.currentUser.toKey()]; g || (g = new ge(jt)), g = g.insert(d, p), c.du[c.currentUser.toKey()] = g })(r, o.batchId, i), await Gu(r, o.changes), await Ff(r.remoteStore) } catch (o) { const u = Cy(o, "Failed to persist write"); i.reject(u) } } async function Bw(e, t) { const i = Dt(e); try { const r = await N5(i.localStore, t); t.targetChanges.forEach(((o, u) => { const c = i.Au.get(u); c && (Xt(o.addedDocuments.size + o.modifiedDocuments.size + o.removedDocuments.size <= 1, 22616), o.addedDocuments.size > 0 ? c.hu = !0 : o.modifiedDocuments.size > 0 ? Xt(c.hu, 14607) : o.removedDocuments.size > 0 && (Xt(c.hu, 42227), c.hu = !1)) })), await Gu(i, r, t) } catch (r) { await Go(r) } } function KT(e, t, i) { const r = Dt(e); if (r.isPrimaryClient && i === 0 || !r.isPrimaryClient && i === 1) { const o = []; r.Tu.forEach(((u, c) => { const d = c.view.va(t); d.snapshot && o.push(d.snapshot) })), (function (c, d) { const p = Dt(c); p.onlineState = d; let g = !1; p.queries.forEach(((v, b) => { for (const E of b.ba) E.va(d) && (g = !0) })), g && Ry(p) })(r.eventManager, t), o.length && r.Pu.J_(o), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t) } } async function x9(e, t, i) { const r = Dt(e); r.sharedClientState.updateQueryState(t, "rejected", i); const o = r.Au.get(t), u = o && o.key; if (u) { let c = new ge(bt.comparator); c = c.insert(u, cn.newNoDocument(u, wt.min())); const d = Ut().add(u), p = new jf(wt.min(), new Map, new ge(jt), c, d); await Bw(r, p), r.Ru = r.Ru.remove(u), r.Au.delete(t), Vy(r) } else await mg(r.localStore, t, !1).then((() => yg(r, t, i))).catch(Go) } async function C9(e, t) { const i = Dt(e), r = t.batch.batchId; try { const o = await O5(i.localStore, t); qw(i, r, null), Fw(i, r), i.sharedClientState.updateMutationState(r, "acknowledged"), await Gu(i, o) } catch (o) { await Go(o) } } async function R9(e, t, i) { const r = Dt(e); try { const o = await (function (c, d) { const p = Dt(c); return p.persistence.runTransaction("Reject batch", "readwrite-primary", (g => { let v; return p.mutationQueue.lookupMutationBatch(g, d).next((b => (Xt(b !== null, 37113), v = b.keys(), p.mutationQueue.removeMutationBatch(g, b)))).next((() => p.mutationQueue.performConsistencyCheck(g))).next((() => p.documentOverlayCache.removeOverlaysForBatchId(g, v, d))).next((() => p.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(g, v))).next((() => p.localDocuments.getDocuments(g, v))) })) })(r.localStore, t); qw(r, t, i), Fw(r, t), r.sharedClientState.updateMutationState(t, "rejected", i), await Gu(r, o) } catch (o) { await Go(o) } } function Fw(e, t) { (e.mu.get(t) || []).forEach((i => { i.resolve() })), e.mu.delete(t) } function qw(e, t, i) { const r = Dt(e); let o = r.du[r.currentUser.toKey()]; if (o) { const u = o.get(t); u && (i ? u.reject(i) : u.resolve(), o = o.remove(t)), r.du[r.currentUser.toKey()] = o } } function yg(e, t, i = null) { e.sharedClientState.removeLocalQueryTarget(t); for (const r of e.Iu.get(t)) e.Tu.delete(r), i && e.Pu.yu(r, i); e.Iu.delete(t), e.isPrimaryClient && e.Vu.Gr(t).forEach((r => { e.Vu.containsKey(r) || Hw(e, r) })) } function Hw(e, t) { e.Eu.delete(t.path.canonicalString()); const i = e.Ru.get(t); i !== null && (Ey(e.remoteStore, i), e.Ru = e.Ru.remove(t), e.Au.delete(i), Vy(e)) } function QT(e, t, i) { for (const r of i) r instanceof zw ? (e.Vu.addReference(r.key, t), D9(e, r)) : r instanceof jw ? (dt(Dy, "Document no longer in limbo: " + r.key), e.Vu.removeReference(r.key, t), e.Vu.containsKey(r.key) || Hw(e, r.key)) : At(19791, { wu: r }) } function D9(e, t) { const i = t.key, r = i.path.canonicalString(); e.Ru.get(i) || e.Eu.has(r) || (dt(Dy, "New document in limbo: " + i), e.Eu.add(r), Vy(e)) } function Vy(e) { for (; e.Eu.size > 0 && e.Ru.size < e.maxConcurrentLimboResolutions;) { const t = e.Eu.values().next().value; e.Eu.delete(t); const i = new bt(oe.fromString(t)), r = e.fu.next(); e.Au.set(r, new v9(i)), e.Ru = e.Ru.insert(i, r), Iw(e.remoteStore, new hr(Yi(dy(i.path)), r, "TargetPurposeLimboResolution", If.ce)) } } async function Gu(e, t, i) { const r = Dt(e), o = [], u = [], c = []; r.Tu.isEmpty() || (r.Tu.forEach(((d, p) => { c.push(r.pu(p, t, i).then((g => { if ((g || i) && r.isPrimaryClient) { const v = g ? !g.fromCache : i?.targetChanges.get(p.targetId)?.current; r.sharedClientState.updateQueryState(p.targetId, v ? "current" : "not-current") } if (g) { o.push(g); const v = by.Es(p.targetId, g); u.push(v) } }))) })), await Promise.all(c), r.Pu.J_(o), await (async function (p, g) { const v = Dt(p); try { await v.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (b => st.forEach(g, (E => st.forEach(E.Ts, (x => v.persistence.referenceDelegate.addReference(b, E.targetId, x))).next((() => st.forEach(E.Is, (x => v.persistence.referenceDelegate.removeReference(b, E.targetId, x))))))))) } catch (b) { if (!Yo(b)) throw b; dt(Ty, "Failed to update sequence numbers: " + b) } for (const b of g) { const E = b.targetId; if (!b.fromCache) { const x = v.vs.get(E), M = x.snapshotVersion, j = x.withLastLimboFreeSnapshotVersion(M); v.vs = v.vs.insert(E, j) } } })(r.localStore, u)) } async function V9(e, t) { const i = Dt(e); if (!i.currentUser.isEqual(t)) { dt(Dy, "User change. New user:", t.toKey()); const r = await Rw(i.localStore, t); i.currentUser = t, (function (u, c) { u.mu.forEach((d => { d.forEach((p => { p.reject(new ft(nt.CANCELLED, c)) })) })), u.mu.clear() })(i, "'waitForPendingWrites' promise is rejected due to a user change."), i.sharedClientState.handleUserChange(t, r.removedBatchIds, r.addedBatchIds), await Gu(i, r.Ns) } } function M9(e, t) { const i = Dt(e), r = i.Au.get(t); if (r && r.hu) return Ut().add(r.key); { let o = Ut(); const u = i.Iu.get(t); if (!u) return o; for (const c of u) { const d = i.Tu.get(c); o = o.unionWith(d.view.nu) } return o } } function Gw(e) { const t = Dt(e); return t.remoteStore.remoteSyncer.applyRemoteEvent = Bw.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = M9.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = x9.bind(null, t), t.Pu.J_ = d9.bind(null, t.eventManager), t.Pu.yu = m9.bind(null, t.eventManager), t } function I9(e) { const t = Dt(e); return t.remoteStore.remoteSyncer.applySuccessfulWrite = C9.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = R9.bind(null, t), t } class Ef { constructor() { this.kind = "memory", this.synchronizeTabs = !1 } async initialize(t) { this.serializer = Uf(t.databaseInfo.databaseId), this.sharedClientState = this.Du(t), this.persistence = this.Cu(t), await this.persistence.start(), this.localStore = this.vu(t), this.gcScheduler = this.Fu(t, this.localStore), this.indexBackfillerScheduler = this.Mu(t, this.localStore) } Fu(t, i) { return null } Mu(t, i) { return null } vu(t) { return I5(this.persistence, new D5, t.initialUser, this.serializer) } Cu(t) { return new Cw(_y.Vi, this.serializer) } Du(t) { return new j5 } async terminate() { this.gcScheduler?.stop(), this.indexBackfillerScheduler?.stop(), this.sharedClientState.shutdown(), await this.persistence.shutdown() } } Ef.provider = { build: () => new Ef }; class O9 extends Ef { constructor(t) { super(), this.cacheSizeBytes = t } Fu(t, i) { Xt(this.persistence.referenceDelegate instanceof bf, 46915); const r = this.persistence.referenceDelegate.garbageCollector; return new m5(r, t.asyncQueue, i) } Cu(t) { const i = this.cacheSizeBytes !== void 0 ? An.withCacheSize(this.cacheSizeBytes) : An.DEFAULT; return new Cw((r => bf.Vi(r, i)), this.serializer) } } class vg { async initialize(t, i) { this.localStore || (this.localStore = t.localStore, this.sharedClientState = t.sharedClientState, this.datastore = this.createDatastore(i), this.remoteStore = this.createRemoteStore(i), this.eventManager = this.createEventManager(i), this.syncEngine = this.createSyncEngine(i, !t.synchronizeTabs), this.sharedClientState.onlineStateHandler = r => KT(this.syncEngine, r, 1), this.remoteStore.remoteSyncer.handleCredentialChange = V9.bind(null, this.syncEngine), await l9(this.remoteStore, this.syncEngine.isPrimaryClient)) } createEventManager(t) { return (function () { return new c9 })() } createDatastore(t) { const i = Uf(t.databaseInfo.databaseId), r = H5(t.databaseInfo); return X5(t.authCredentials, t.appCheckCredentials, r, i) } createRemoteStore(t) { return (function (r, o, u, c, d) { return new $5(r, o, u, c, d) })(this.localStore, this.datastore, t.asyncQueue, (i => KT(this.syncEngine, i, 0)), (function () { return BT.v() ? new BT : new U5 })()) } createSyncEngine(t, i) { return (function (o, u, c, d, p, g, v) { const b = new _9(o, u, c, d, p, g); return v && (b.gu = !0), b })(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t.initialUser, t.maxConcurrentLimboResolutions, i) } async terminate() { await (async function (i) { const r = Dt(i); dt(Ta, "RemoteStore shutting down."), r.Ea.add(5), await Hu(r), r.Aa.shutdown(), r.Va.set("Unknown") })(this.remoteStore), this.datastore?.terminate(), this.eventManager?.terminate() } } vg.provider = { build: () => new vg }; class N9 { constructor(t) { this.observer = t, this.muted = !1 } next(t) { this.muted || this.observer.next && this.Ou(this.observer.next, t) } error(t) { this.muted || (this.observer.error ? this.Ou(this.observer.error, t) : ws("Uncaught Error in snapshot listener:", t.toString())) } Nu() { this.muted = !0 } Ou(t, i) { setTimeout((() => { this.muted || t(i) }), 0) } } const xr = "FirestoreClient"; class P9 { constructor(t, i, r, o, u) { this.authCredentials = t, this.appCheckCredentials = i, this.asyncQueue = r, this._databaseInfo = o, this.user = un.UNAUTHENTICATED, this.clientId = oy.newId(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this._uninitializedComponentsProvider = u, this.authCredentials.start(r, (async c => { dt(xr, "Received user=", c.uid), await this.authCredentialListener(c), this.user = c })), this.appCheckCredentials.start(r, (c => (dt(xr, "Received new app check token=", c), this.appCheckCredentialListener(c, this.user)))) } get configuration() { return { asyncQueue: this.asyncQueue, databaseInfo: this._databaseInfo, clientId: this.clientId, authCredentials: this.authCredentials, appCheckCredentials: this.appCheckCredentials, initialUser: this.user, maxConcurrentLimboResolutions: 100 } } setCredentialChangeListener(t) { this.authCredentialListener = t } setAppCheckTokenChangeListener(t) { this.appCheckCredentialListener = t } terminate() { this.asyncQueue.enterRestrictedMode(); const t = new ya; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async () => { try { this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t.resolve() } catch (i) { const r = Cy(i, "Failed to shutdown persistence"); t.reject(r) } })), t.promise } } async function wp(e, t) { e.asyncQueue.verifyOperationInProgress(), dt(xr, "Initializing OfflineComponentProvider"); const i = e.configuration; await t.initialize(i); let r = i.initialUser; e.setCredentialChangeListener((async o => { r.isEqual(o) || (await Rw(t.localStore, o), r = o) })), t.persistence.setDatabaseDeletedListener((() => e.terminate())), e._offlineComponents = t } async function XT(e, t) { e.asyncQueue.verifyOperationInProgress(); const i = await k9(e); dt(xr, "Initializing OnlineComponentProvider"), await t.initialize(i, e.configuration), e.setCredentialChangeListener((r => qT(t.remoteStore, r))), e.setAppCheckTokenChangeListener(((r, o) => qT(t.remoteStore, o))), e._onlineComponents = t } async function k9(e) { if (!e._offlineComponents) if (e._uninitializedComponentsProvider) { dt(xr, "Using user provided OfflineComponentProvider"); try { await wp(e, e._uninitializedComponentsProvider._offline) } catch (t) { const i = t; if (!(function (o) { return o.name === "FirebaseError" ? o.code === nt.FAILED_PRECONDITION || o.code === nt.UNIMPLEMENTED : !(typeof DOMException < "u" && o instanceof DOMException) || o.code === 22 || o.code === 20 || o.code === 11 })(i)) throw i; ba("Error using user provided cache. Falling back to memory cache: " + i), await wp(e, new Ef) } } else dt(xr, "Using default OfflineComponentProvider"), await wp(e, new O9(void 0)); return e._offlineComponents } async function Yw(e) { return e._onlineComponents || (e._uninitializedComponentsProvider ? (dt(xr, "Using user provided OnlineComponentProvider"), await XT(e, e._uninitializedComponentsProvider._online)) : (dt(xr, "Using default OnlineComponentProvider"), await XT(e, new vg))), e._onlineComponents } function L9(e) { return Yw(e).then((t => t.syncEngine)) } async function WT(e) { const t = await Yw(e), i = t.eventManager; return i.onListen = b9.bind(null, t.syncEngine), i.onUnlisten = S9.bind(null, t.syncEngine), i.onFirstRemoteStoreListen = T9.bind(null, t.syncEngine), i.onLastRemoteStoreUnlisten = A9.bind(null, t.syncEngine), i } function z9(e, t, i, r) { const o = new N9(r), u = new p9(t, o, i); return e.asyncQueue.enqueueAndForget((async () => h9(await WT(e), u))), () => { o.Nu(), e.asyncQueue.enqueueAndForget((async () => f9(await WT(e), u))) } } function j9(e, t) { const i = new ya; return e.asyncQueue.enqueueAndForget((async () => w9(await L9(e), t, i))), i.promise } function Kw(e) { const t = {}; return e.timeoutSeconds !== void 0 && (t.timeoutSeconds = e.timeoutSeconds), t } const U9 = "ComponentProvider", $T = new Map; function B9(e, t, i, r, o) { return new iN(e, t, i, o.host, o.ssl, o.experimentalForceLongPolling, o.experimentalAutoDetectLongPolling, Kw(o.experimentalLongPollingOptions), o.useFetchStreams, o.isUsingEmulator, r) } const Qw = "firestore.googleapis.com", ZT = !0; class JT { constructor(t) { if (t.host === void 0) { if (t.ssl !== void 0) throw new ft(nt.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = Qw, this.ssl = ZT } else this.host = t.host, this.ssl = t.ssl ?? ZT; if (this.isUsingEmulator = t.emulatorOptions !== void 0, this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, this.localCache = t.localCache, t.cacheSizeBytes === void 0) this.cacheSizeBytes = xw; else { if (t.cacheSizeBytes !== -1 && t.cacheSizeBytes < f5) throw new ft(nt.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = t.cacheSizeBytes } YO("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : t.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !0 : this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.experimentalLongPollingOptions = Kw(t.experimentalLongPollingOptions ?? {}), (function (r) { if (r.timeoutSeconds !== void 0) { if (isNaN(r.timeoutSeconds)) throw new ft(nt.INVALID_ARGUMENT, `invalid long polling timeout: ${r.timeoutSeconds} (must not be NaN)`); if (r.timeoutSeconds < 5) throw new ft(nt.INVALID_ARGUMENT, `invalid long polling timeout: ${r.timeoutSeconds} (minimum allowed value is 5)`); if (r.timeoutSeconds > 30) throw new ft(nt.INVALID_ARGUMENT, `invalid long polling timeout: ${r.timeoutSeconds} (maximum allowed value is 30)`) } })(this.experimentalLongPollingOptions), this.useFetchStreams = !!t.useFetchStreams } isEqual(t) { return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && (function (r, o) { return r.timeoutSeconds === o.timeoutSeconds })(this.experimentalLongPollingOptions, t.experimentalLongPollingOptions) && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams } } class qf { constructor(t, i, r, o) { this._authCredentials = t, this._appCheckCredentials = i, this._databaseId = r, this._app = o, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new JT({}), this._settingsFrozen = !1, this._emulatorOptions = {}, this._terminateTask = "notTerminated" } get app() { if (!this._app) throw new ft(nt.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return this._terminateTask !== "notTerminated" } _setSettings(t) { if (this._settingsFrozen) throw new ft(nt.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new JT(t), this._emulatorOptions = t.emulatorOptions || {}, t.credentials !== void 0 && (this._authCredentials = (function (r) { if (!r) return new kO; switch (r.type) { case "firstParty": return new UO(r.sessionIndex || "0", r.iamToken || null, r.authTokenFactory || null); case "provider": return r.client; default: throw new ft(nt.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } })(t.credentials)) } _getSettings() { return this._settings } _getEmulatorOptions() { return this._emulatorOptions } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask === "notTerminated" && (this._terminateTask = this._terminate()), this._terminateTask } async _restart() { this._terminateTask === "notTerminated" ? await this._terminate() : this._terminateTask = "notTerminated" } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return (function (i) { const r = $T.get(i); r && (dt(U9, "Removing Datastore"), $T.delete(i), r.terminate()) })(this), Promise.resolve() } } function F9(e, t, i, r = {}) { e = Ts(e, qf); const o = sy(t), u = e._getSettings(), c = { ...u, emulatorOptions: e._getEmulatorOptions() }, d = `${t}:${i}`; o && (lI(`https://${d}`), fI("Firestore", !0)), u.host !== Qw && u.host !== d && ba("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."); const p = { ...u, host: d, ssl: o, emulatorOptions: r }; if (!cf(p, c) && (e._setSettings(p), r.mockUserToken)) { let g, v; if (typeof r.mockUserToken == "string") g = r.mockUserToken, v = un.MOCK_USER; else { g = uI(r.mockUserToken, e._app?.options.projectId); const b = r.mockUserToken.sub || r.mockUserToken.user_id; if (!b) throw new ft(nt.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); v = new un(b) } e._authCredentials = new LO(new kA(g, v)) } } class Mr { constructor(t, i, r) { this.converter = i, this._query = r, this.type = "query", this.firestore = t } withConverter(t) { return new Mr(this.firestore, t, this._query) } } class xe { constructor(t, i, r) { this.converter = i, this._key = r, this.type = "document", this.firestore = t } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new yr(this.firestore, this.converter, this._key.path.popLast()) } withConverter(t) { return new xe(this.firestore, t, this._key) } toJSON() { return { type: xe._jsonSchemaVersion, referencePath: this._key.toString() } } static fromJSON(t, i, r) { if (Bu(i, xe._jsonSchema)) return new xe(t, r || null, new bt(oe.fromString(i.referencePath))) } } xe._jsonSchemaVersion = "firestore/documentReference/1.0", xe._jsonSchema = { type: je("string", xe._jsonSchemaVersion), referencePath: je("string") }; class yr extends Mr { constructor(t, i, r) { super(t, i, dy(r)), this._path = r, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const t = this._path.popLast(); return t.isEmpty() ? null : new xe(this.firestore, null, new bt(t)) } withConverter(t) { return new yr(this.firestore, t, this._path) } } function _g(e, t, ...i) { if (e = Wi(e), LA("collection", "path", t), e instanceof qf) { const r = oe.fromString(t, ...i); return hT(r), new yr(e, null, r) } { if (!(e instanceof xe || e instanceof yr)) throw new ft(nt.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = e._path.child(oe.fromString(t, ...i)); return hT(r), new yr(e.firestore, null, r) } } function bg(e, t, ...i) { if (e = Wi(e), arguments.length === 1 && (t = oy.newId()), LA("doc", "path", t), e instanceof qf) { const r = oe.fromString(t, ...i); return cT(r), new xe(e, null, new bt(r)) } { if (!(e instanceof xe || e instanceof yr)) throw new ft(nt.INVALID_ARGUMENT, "Expected first argument to doc() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = e._path.child(oe.fromString(t, ...i)); return cT(r), new xe(e.firestore, e instanceof yr ? e.converter : null, new bt(r)) } } const tE = "AsyncQueue"; class eE { constructor(t = Promise.resolve()) { this.Yu = [], this.ec = !1, this.tc = [], this.nc = null, this.rc = !1, this.sc = !1, this.oc = [], this.M_ = new Vw(this, "async_queue_retry"), this._c = () => { const r = Ap(); r && dt(tE, "Visibility state changed to " + r.visibilityState), this.M_.w_() }, this.ac = t; const i = Ap(); i && typeof i.addEventListener == "function" && i.addEventListener("visibilitychange", this._c) } get isShuttingDown() { return this.ec } enqueueAndForget(t) { this.enqueue(t) } enqueueAndForgetEvenWhileRestricted(t) { this.uc(), this.cc(t) } enterRestrictedMode(t) { if (!this.ec) { this.ec = !0, this.sc = t || !1; const i = Ap(); i && typeof i.removeEventListener == "function" && i.removeEventListener("visibilitychange", this._c) } } enqueue(t) { if (this.uc(), this.ec) return new Promise((() => { })); const i = new ya; return this.cc((() => this.ec && this.sc ? Promise.resolve() : (t().then(i.resolve, i.reject), i.promise))).then((() => i.promise)) } enqueueRetryable(t) { this.enqueueAndForget((() => (this.Yu.push(t), this.lc()))) } async lc() { if (this.Yu.length !== 0) { try { await this.Yu[0](), this.Yu.shift(), this.M_.reset() } catch (t) { if (!Yo(t)) throw t; dt(tE, "Operation failed with retryable error: " + t) } this.Yu.length > 0 && this.M_.p_((() => this.lc())) } } cc(t) { const i = this.ac.then((() => (this.rc = !0, t().catch((r => { throw this.nc = r, this.rc = !1, ws("INTERNAL UNHANDLED ERROR: ", nE(r)), r })).then((r => (this.rc = !1, r)))))); return this.ac = i, i } enqueueAfterDelay(t, i, r) { this.uc(), this.oc.indexOf(t) > -1 && (i = 0); const o = xy.createAndSchedule(this, t, i, r, (u => this.hc(u))); return this.tc.push(o), o } uc() { this.nc && At(47125, { Pc: nE(this.nc) }) } verifyOperationInProgress() { } async Tc() { let t; do t = this.ac, await t; while (t !== this.ac) } Ic(t) { for (const i of this.tc) if (i.timerId === t) return !0; return !1 } Ec(t) { return this.Tc().then((() => { this.tc.sort(((i, r) => i.targetTimeMs - r.targetTimeMs)); for (const i of this.tc) if (i.skipDelay(), t !== "all" && i.timerId === t) break; return this.Tc() })) } Rc(t) { this.oc.push(t) } hc(t) { const i = this.tc.indexOf(t); this.tc.splice(i, 1) } } function nE(e) {
  let t = e.message || ""; return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + `
`+ e.stack), t
} class ko extends qf { constructor(t, i, r, o) { super(t, i, r, o), this.type = "firestore", this._queue = new eE, this._persistenceKey = o?.name || "[DEFAULT]" } async _terminate() { if (this._firestoreClient) { const t = this._firestoreClient.terminate(); this._queue = new eE(t), this._firestoreClient = void 0, await t } } } function q9(e, t) { const i = typeof e == "object" ? e : EO(), r = typeof e == "string" ? e : mf, o = yO(i, "firestore").getImmediate({ identifier: r }); if (!o._initialized) { const u = aI("firestore"); u && F9(o, ...u) } return o } function Xw(e) { if (e._terminated) throw new ft(nt.FAILED_PRECONDITION, "The client has already been terminated."); return e._firestoreClient || H9(e), e._firestoreClient } function H9(e) { const t = e._freezeSettings(), i = B9(e._databaseId, e._app?.options.appId || "", e._persistenceKey, e._app?.options.apiKey, t); e._componentsProvider || t.localCache?._offlineComponentProvider && t.localCache?._onlineComponentProvider && (e._componentsProvider = { _offline: t.localCache._offlineComponentProvider, _online: t.localCache._onlineComponentProvider }), e._firestoreClient = new P9(e._authCredentials, e._appCheckCredentials, e._queue, i, e._componentsProvider && (function (o) { const u = o?._online.build(); return { _offline: o?._offline.build(u), _online: u } })(e._componentsProvider)) } class Wn { constructor(t) { this._byteString = t } static fromBase64String(t) { try { return new Wn(an.fromBase64String(t)) } catch (i) { throw new ft(nt.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + i) } } static fromUint8Array(t) { return new Wn(an.fromUint8Array(t)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(t) { return this._byteString.isEqual(t._byteString) } toJSON() { return { type: Wn._jsonSchemaVersion, bytes: this.toBase64() } } static fromJSON(t) { if (Bu(t, Wn._jsonSchema)) return Wn.fromBase64String(t.bytes) } } Wn._jsonSchemaVersion = "firestore/bytes/1.0", Wn._jsonSchema = { type: je("string", Wn._jsonSchemaVersion), bytes: je("string") }; class My { constructor(...t) { for (let i = 0; i < t.length; ++i)if (t[i].length === 0) throw new ft(nt.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new sn(t) } isEqual(t) { return this._internalPath.isEqual(t._internalPath) } } class Hf { constructor(t) { this._methodName = t } } class Qi { constructor(t, i) { if (!isFinite(t) || t < -90 || t > 90) throw new ft(nt.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t); if (!isFinite(i) || i < -180 || i > 180) throw new ft(nt.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + i); this._lat = t, this._long = i } get latitude() { return this._lat } get longitude() { return this._long } isEqual(t) { return this._lat === t._lat && this._long === t._long } _compareTo(t) { return jt(this._lat, t._lat) || jt(this._long, t._long) } toJSON() { return { latitude: this._lat, longitude: this._long, type: Qi._jsonSchemaVersion } } static fromJSON(t) { if (Bu(t, Qi._jsonSchema)) return new Qi(t.latitude, t.longitude) } } Qi._jsonSchemaVersion = "firestore/geoPoint/1.0", Qi._jsonSchema = { type: je("string", Qi._jsonSchemaVersion), latitude: je("number"), longitude: je("number") }; class pi { constructor(t) { this._values = (t || []).map((i => i)) } toArray() { return this._values.map((t => t)) } isEqual(t) { return (function (r, o) { if (r.length !== o.length) return !1; for (let u = 0; u < r.length; ++u)if (r[u] !== o[u]) return !1; return !0 })(this._values, t._values) } toJSON() { return { type: pi._jsonSchemaVersion, vectorValues: this._values } } static fromJSON(t) { if (Bu(t, pi._jsonSchema)) { if (Array.isArray(t.vectorValues) && t.vectorValues.every((i => typeof i == "number"))) return new pi(t.vectorValues); throw new ft(nt.INVALID_ARGUMENT, "Expected 'vectorValues' field to be a number array") } } } pi._jsonSchemaVersion = "firestore/vectorValue/1.0", pi._jsonSchema = { type: je("string", pi._jsonSchemaVersion), vectorValues: je("object") }; const G9 = /^__.*__$/; class Y9 { constructor(t, i, r) { this.data = t, this.fieldMask = i, this.fieldTransforms = r } toMutation(t, i) { return this.fieldMask !== null ? new Vr(t, this.data, this.fieldMask, i, this.fieldTransforms) : new Fu(t, this.data, i, this.fieldTransforms) } } class Ww { constructor(t, i, r) { this.data = t, this.fieldMask = i, this.fieldTransforms = r } toMutation(t, i) { return new Vr(t, this.data, this.fieldMask, i, this.fieldTransforms) } } function $w(e) { switch (e) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw At(40011, { dataSource: e }) } } class Iy { constructor(t, i, r, o, u, c) { this.settings = t, this.databaseId = i, this.serializer = r, this.ignoreUndefinedProperties = o, u === void 0 && this.validatePath(), this.fieldTransforms = u || [], this.fieldMask = c || [] } get path() { return this.settings.path } get dataSource() { return this.settings.dataSource } contextWith(t) { return new Iy({ ...this.settings, ...t }, this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } childContextForField(t) { const i = this.path?.child(t), r = this.contextWith({ path: i, arrayElement: !1 }); return r.validatePathSegment(t), r } childContextForFieldPath(t) { const i = this.path?.child(t), r = this.contextWith({ path: i, arrayElement: !1 }); return r.validatePath(), r } childContextForArray(t) { return this.contextWith({ path: void 0, arrayElement: !0 }) } createError(t) { return Sf(t, this.settings.methodName, this.settings.hasConverter || !1, this.path, this.settings.targetDoc) } contains(t) { return this.fieldMask.find((i => t.isPrefixOf(i))) !== void 0 || this.fieldTransforms.find((i => t.isPrefixOf(i.field))) !== void 0 } validatePath() { if (this.path) for (let t = 0; t < this.path.length; t++)this.validatePathSegment(this.path.get(t)) } validatePathSegment(t) { if (t.length === 0) throw this.createError("Document fields must not be empty"); if ($w(this.dataSource) && G9.test(t)) throw this.createError('Document fields cannot begin and end with "__"') } } class K9 { constructor(t, i, r) { this.databaseId = t, this.ignoreUndefinedProperties = i, this.serializer = r || Uf(t) } createContext(t, i, r, o = !1) { return new Iy({ dataSource: t, methodName: i, targetDoc: r, path: sn.emptyPath(), arrayElement: !1, hasConverter: o }, this.databaseId, this.serializer, this.ignoreUndefinedProperties) } } function Gf(e) { const t = e._freezeSettings(), i = Uf(e._databaseId); return new K9(e._databaseId, !!t.ignoreUndefinedProperties, i) } function Zw(e, t, i, r, o, u = {}) { const c = e.createContext(u.merge || u.mergeFields ? 2 : 0, t, i, o); Ny("Data must be an object, but it was:", c, r); const d = Jw(r, c); let p, g; if (u.merge) p = new Pn(c.fieldMask), g = c.fieldTransforms; else if (u.mergeFields) { const v = []; for (const b of u.mergeFields) { const E = Lo(t, b, i); if (!c.contains(E)) throw new ft(nt.INVALID_ARGUMENT, `Field '${E}' is specified in your field mask but missing from your input data.`); n2(v, E) || v.push(E) } p = new Pn(v), g = c.fieldTransforms.filter((b => p.covers(b.field))) } else p = null, g = c.fieldTransforms; return new Y9(new wn(d), p, g) } class Yf extends Hf { _toFieldTransform(t) { if (t.dataSource !== 2) throw t.dataSource === 1 ? t.createError(`${this._methodName}() can only appear at the top level of your update data`) : t.createError(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`); return t.fieldMask.push(t.path), null } isEqual(t) { return t instanceof Yf } } class Oy extends Hf { _toFieldTransform(t) { return new IN(t.path, new Ou) } isEqual(t) { return t instanceof Oy } } function Q9(e, t, i, r) { const o = e.createContext(1, t, i); Ny("Data must be an object, but it was:", o, r); const u = [], c = wn.empty(); Dr(r, ((p, g) => { const v = e2(t, p, i); g = Wi(g); const b = o.childContextForFieldPath(v); if (g instanceof Yf) u.push(v); else { const E = Yu(g, b); E != null && (u.push(v), c.set(v, E)) } })); const d = new Pn(u); return new Ww(c, d, o.fieldTransforms) } function X9(e, t, i, r, o, u) { const c = e.createContext(1, t, i), d = [Lo(t, r, i)], p = [o]; if (u.length % 2 != 0) throw new ft(nt.INVALID_ARGUMENT, `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`); for (let E = 0; E < u.length; E += 2)d.push(Lo(t, u[E])), p.push(u[E + 1]); const g = [], v = wn.empty(); for (let E = d.length - 1; E >= 0; --E)if (!n2(g, d[E])) { const x = d[E]; let M = p[E]; M = Wi(M); const j = c.childContextForFieldPath(x); if (M instanceof Yf) g.push(x); else { const z = Yu(M, j); z != null && (g.push(x), v.set(x, z)) } } const b = new Pn(g); return new Ww(v, b, c.fieldTransforms) } function W9(e, t, i, r = !1) { return Yu(i, e.createContext(r ? 4 : 3, t)) } function Yu(e, t) { if (t2(e = Wi(e))) return Ny("Unsupported field value:", t, e), Jw(e, t); if (e instanceof Hf) return (function (r, o) { if (!$w(o.dataSource)) throw o.createError(`${r._methodName}() can only be used with update() and set()`); if (!o.path) throw o.createError(`${r._methodName}() is not currently supported inside arrays`); const u = r._toFieldTransform(o); u && o.fieldTransforms.push(u) })(e, t), null; if (e === void 0 && t.ignoreUndefinedProperties) return null; if (t.path && t.fieldMask.push(t.path), e instanceof Array) { if (t.settings.arrayElement && t.dataSource !== 4) throw t.createError("Nested arrays are not supported"); return (function (r, o) { const u = []; let c = 0; for (const d of r) { let p = Yu(d, o.childContextForArray(c)); p == null && (p = { nullValue: "NULL_VALUE" }), u.push(p), c++ } return { arrayValue: { values: u } } })(e, t) } return (function (r, o) { if ((r = Wi(r)) === null) return { nullValue: "NULL_VALUE" }; if (typeof r == "number") return DN(o.serializer, r); if (typeof r == "boolean") return { booleanValue: r }; if (typeof r == "string") return { stringValue: r }; if (r instanceof Date) { const u = he.fromDate(r); return { timestampValue: _f(o.serializer, u) } } if (r instanceof he) { const u = new he(r.seconds, 1e3 * Math.floor(r.nanoseconds / 1e3)); return { timestampValue: _f(o.serializer, u) } } if (r instanceof Qi) return { geoPointValue: { latitude: r.latitude, longitude: r.longitude } }; if (r instanceof Wn) return { bytesValue: vw(o.serializer, r._byteString) }; if (r instanceof xe) { const u = o.databaseId, c = r.firestore._databaseId; if (!c.isEqual(u)) throw o.createError(`Document reference is for database ${c.projectId}/${c.database} but should be for database ${u.projectId}/${u.database}`); return { referenceValue: yy(r.firestore._databaseId || o.databaseId, r._key.path) } } if (r instanceof pi) return (function (c, d) { const p = c instanceof pi ? c.toArray() : c; return { mapValue: { fields: { [YA]: { stringValue: KA }, [pf]: { arrayValue: { values: p.map((v => { if (typeof v != "number") throw d.createError("VectorValues must only contain numeric values."); return my(d.serializer, v) })) } } } } } })(r, o); if (ww(r)) return r._toProto(o.serializer); throw o.createError(`Unsupported field value: ${Mf(r)}`) })(e, t) } function Jw(e, t) { const i = {}; return UA(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : Dr(e, ((r, o) => { const u = Yu(o, t.childContextForField(r)); u != null && (i[r] = u) })), { mapValue: { fields: i } } } function t2(e) { return !(typeof e != "object" || e === null || e instanceof Array || e instanceof Date || e instanceof he || e instanceof Qi || e instanceof Wn || e instanceof xe || e instanceof Hf || e instanceof pi || ww(e)) } function Ny(e, t, i) { if (!t2(i) || !zA(i)) { const r = Mf(i); throw r === "an object" ? t.createError(e + " a custom object") : t.createError(e + " " + r) } } function Lo(e, t, i) { if ((t = Wi(t)) instanceof My) return t._internalPath; if (typeof t == "string") return e2(e, t); throw Sf("Field path arguments must be of type string or ", e, !1, void 0, i) } const $9 = new RegExp("[~\\*/\\[\\]]"); function e2(e, t, i) { if (t.search($9) >= 0) throw Sf(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, i); try { return new My(...t.split("."))._internalPath } catch { throw Sf(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, i) } } function Sf(e, t, i, r, o) { const u = r && !r.isEmpty(), c = o !== void 0; let d = `Function ${t}() called with invalid data`; i && (d += " (via `toFirestore()`)"), d += ". "; let p = ""; return (u || c) && (p += " (found", u && (p += ` in field ${r}`), c && (p += ` in document ${o}`), p += ")"), new ft(nt.INVALID_ARGUMENT, d + e + p) } function n2(e, t) { return e.some((i => i.isEqual(t))) } class Z9 { convertValue(t, i = "none") { switch (Ar(t)) { case 0: return null; case 1: return t.booleanValue; case 2: return we(t.integerValue || t.doubleValue); case 3: return this.convertTimestamp(t.timestampValue); case 4: return this.convertServerTimestamp(t, i); case 5: return t.stringValue; case 6: return this.convertBytes(Sr(t.bytesValue)); case 7: return this.convertReference(t.referenceValue); case 8: return this.convertGeoPoint(t.geoPointValue); case 9: return this.convertArray(t.arrayValue, i); case 11: return this.convertObject(t.mapValue, i); case 10: return this.convertVectorValue(t.mapValue); default: throw At(62114, { value: t }) } } convertObject(t, i) { return this.convertObjectMap(t.fields, i) } convertObjectMap(t, i = "none") { const r = {}; return Dr(t, ((o, u) => { r[o] = this.convertValue(u, i) })), r } convertVectorValue(t) { const i = t.fields?.[pf].arrayValue?.values?.map((r => we(r.doubleValue))); return new pi(i) } convertGeoPoint(t) { return new Qi(we(t.latitude), we(t.longitude)) } convertArray(t, i) { return (t.values || []).map((r => this.convertValue(r, i))) } convertServerTimestamp(t, i) { switch (i) { case "previous": const r = Nf(t); return r == null ? null : this.convertValue(r, i); case "estimate": return this.convertTimestamp(Du(t)); default: return null } } convertTimestamp(t) { const i = Er(t); return new he(i.seconds, i.nanos) } convertDocumentKey(t, i) { const r = oe.fromString(t); Xt(Aw(r), 9688, { name: t }); const o = new Vu(r.get(1), r.get(3)), u = new bt(r.popFirst(5)); return o.isEqual(i) || ws(`Document ${u} contains a document reference within a different database (${o.projectId}/${o.database}) which is not supported. It will be treated as a reference in the current database (${i.projectId}/${i.database}) instead.`), u } } class i2 extends Z9 { constructor(t) { super(), this.firestore = t } convertBytes(t) { return new Wn(t) } convertReference(t) { const i = this.convertDocumentKey(t, this.firestore._databaseId); return new xe(this.firestore, null, i) } } function J9() { return new Oy("serverTimestamp") } const iE = "@firebase/firestore", sE = "4.11.0"; function rE(e) { return (function (i, r) { if (typeof i != "object" || i === null) return !1; const o = i; for (const u of r) if (u in o && typeof o[u] == "function") return !0; return !1 })(e, ["next", "error", "complete"]) } class s2 { constructor(t, i, r, o, u) { this._firestore = t, this._userDataWriter = i, this._key = r, this._document = o, this._converter = u } get id() { return this._key.path.lastSegment() } get ref() { return new xe(this._firestore, this._converter, this._key) } exists() { return this._document !== null } data() { if (this._document) { if (this._converter) { const t = new tP(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(t) } return this._userDataWriter.convertValue(this._document.data.value) } } _fieldsProto() { return this._document?.data.clone().value.mapValue.fields ?? void 0 } get(t) { if (this._document) { const i = this._document.data.field(Lo("DocumentSnapshot.get", t)); if (i !== null) return this._userDataWriter.convertValue(i) } } } class tP extends s2 { data() { return super.data() } } function eP(e) { if (e.limitType === "L" && e.explicitOrderBy.length === 0) throw new ft(nt.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause") } class Py { } class ky extends Py { } function nP(e, t, ...i) { let r = []; t instanceof Py && r.push(t), r = r.concat(i), (function (u) { const c = u.filter((p => p instanceof zy)).length, d = u.filter((p => p instanceof Ly)).length; if (c > 1 || c > 0 && d > 0) throw new ft(nt.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.") })(r); for (const o of r) e = o._apply(e); return e } class Ly extends ky { constructor(t, i, r) { super(), this._field = t, this._op = i, this._value = r, this.type = "where" } static _create(t, i, r) { return new Ly(t, i, r) } _apply(t) { const i = this._parse(t); return r2(t._query, i), new Mr(t.firestore, t.converter, ug(t._query, i)) } _parse(t) { const i = Gf(t.firestore); return (function (u, c, d, p, g, v, b) { let E; if (g.isKeyField()) { if (v === "array-contains" || v === "array-contains-any") throw new ft(nt.INVALID_ARGUMENT, `Invalid Query. You can't perform '${v}' queries on documentId().`); if (v === "in" || v === "not-in") { oE(b, v); const M = []; for (const j of b) M.push(aE(p, u, j)); E = { arrayValue: { values: M } } } else E = aE(p, u, b) } else v !== "in" && v !== "not-in" && v !== "array-contains-any" || oE(b, v), E = W9(d, c, b, v === "in" || v === "not-in"); return ze.create(g, v, E) })(t._query, "where", i, t.firestore._databaseId, this._field, this._op, this._value) } } class zy extends Py { constructor(t, i) { super(), this.type = t, this._queryConstraints = i } static _create(t, i) { return new zy(t, i) } _parse(t) { const i = this._queryConstraints.map((r => r._parse(t))).filter((r => r.getFilters().length > 0)); return i.length === 1 ? i[0] : gi.create(i, this._getOperator()) } _apply(t) { const i = this._parse(t); return i.getFilters().length === 0 ? t : ((function (o, u) { let c = o; const d = u.getFlattenedFilters(); for (const p of d) r2(c, p), c = ug(c, p) })(t._query, i), new Mr(t.firestore, t.converter, ug(t._query, i))) } _getQueryConstraints() { return this._queryConstraints } _getOperator() { return this.type === "and" ? "and" : "or" } } class jy extends ky { constructor(t, i) { super(), this._field = t, this._direction = i, this.type = "orderBy" } static _create(t, i) { return new jy(t, i) } _apply(t) { const i = (function (o, u, c) { if (o.startAt !== null) throw new ft(nt.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."); if (o.endAt !== null) throw new ft(nt.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."); return new Iu(u, c) })(t._query, this._field, this._direction); return new Mr(t.firestore, t.converter, TN(t._query, i)) } } function iP(e, t = "asc") { const i = t, r = Lo("orderBy", e); return jy._create(r, i) } class Uy extends ky { constructor(t, i, r) { super(), this.type = t, this._limit = i, this._limitType = r } static _create(t, i, r) { return new Uy(t, i, r) } _apply(t) { return new Mr(t.firestore, t.converter, yf(t._query, this._limit, this._limitType)) } } function sP(e) { return Uy._create("limit", e, "F") } function aE(e, t, i) { if (typeof (i = Wi(i)) == "string") { if (i === "") throw new ft(nt.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."); if (!ew(t) && i.indexOf("/") !== -1) throw new ft(nt.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${i}' contains a '/' character.`); const r = t.path.child(oe.fromString(i)); if (!bt.isDocumentKey(r)) throw new ft(nt.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`); return _T(e, new bt(r)) } if (i instanceof xe) return _T(e, i._key); throw new ft(nt.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Mf(i)}.`) } function oE(e, t) { if (!Array.isArray(e) || e.length === 0) throw new ft(nt.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`) } function r2(e, t) { const i = (function (o, u) { for (const c of o) for (const d of c.getFlattenedFilters()) if (u.indexOf(d.op) >= 0) return d.op; return null })(e.filters, (function (o) { switch (o) { case "!=": return ["!=", "not-in"]; case "array-contains-any": case "in": return ["not-in"]; case "not-in": return ["array-contains-any", "in", "not-in", "!="]; default: return [] } })(t.op)); if (i !== null) throw i === t.op ? new ft(nt.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${t.op.toString()}' filter.`) : new ft(nt.INVALID_ARGUMENT, `Invalid query. You cannot use '${t.op.toString()}' filters with '${i.toString()}' filters.`) } function a2(e, t, i) { let r; return r = e ? e.toFirestore(t) : t, r } class cu { constructor(t, i) { this.hasPendingWrites = t, this.fromCache = i } isEqual(t) { return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache } } class va extends s2 { constructor(t, i, r, o, u, c) { super(t, i, r, o, c), this._firestore = t, this._firestoreImpl = t, this.metadata = u } exists() { return super.exists() } data(t = {}) { if (this._document) { if (this._converter) { const i = new Kh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(i, t) } return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps) } } get(t, i = {}) { if (this._document) { const r = this._document.data.field(Lo("DocumentSnapshot.get", t)); if (r !== null) return this._userDataWriter.convertValue(r, i.serverTimestamps) } } toJSON() { if (this.metadata.hasPendingWrites) throw new ft(nt.FAILED_PRECONDITION, "DocumentSnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON()."); const t = this._document, i = {}; return i.type = va._jsonSchemaVersion, i.bundle = "", i.bundleSource = "DocumentSnapshot", i.bundleName = this._key.toString(), !t || !t.isValidDocument() || !t.isFoundDocument() ? i : (this._userDataWriter.convertObjectMap(t.data.value.mapValue.fields, "previous"), i.bundle = (this._firestore, this.ref.path, "NOT SUPPORTED"), i) } } va._jsonSchemaVersion = "firestore/documentSnapshot/1.0", va._jsonSchema = { type: je("string", va._jsonSchemaVersion), bundleSource: je("string", "DocumentSnapshot"), bundleName: je("string"), bundle: je("string") }; class Kh extends va { data(t = {}) { return super.data(t) } } class Do { constructor(t, i, r, o) { this._firestore = t, this._userDataWriter = i, this._snapshot = o, this.metadata = new cu(o.hasPendingWrites, o.fromCache), this.query = r } get docs() { const t = []; return this.forEach((i => t.push(i))), t } get size() { return this._snapshot.docs.size } get empty() { return this.size === 0 } forEach(t, i) { this._snapshot.docs.forEach((r => { t.call(i, new Kh(this._firestore, this._userDataWriter, r.key, r, new cu(this._snapshot.mutatedKeys.has(r.key), this._snapshot.fromCache), this.query.converter)) })) } docChanges(t = {}) { const i = !!t.includeMetadataChanges; if (i && this._snapshot.excludesMetadataChanges) throw new ft(nt.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."); return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === i || (this._cachedChanges = (function (o, u) { if (o._snapshot.oldDocs.isEmpty()) { let c = 0; return o._snapshot.docChanges.map((d => { const p = new Kh(o._firestore, o._userDataWriter, d.doc.key, d.doc, new cu(o._snapshot.mutatedKeys.has(d.doc.key), o._snapshot.fromCache), o.query.converter); return d.doc, { type: "added", doc: p, oldIndex: -1, newIndex: c++ } })) } { let c = o._snapshot.oldDocs; return o._snapshot.docChanges.filter((d => u || d.type !== 3)).map((d => { const p = new Kh(o._firestore, o._userDataWriter, d.doc.key, d.doc, new cu(o._snapshot.mutatedKeys.has(d.doc.key), o._snapshot.fromCache), o.query.converter); let g = -1, v = -1; return d.type !== 0 && (g = c.indexOf(d.doc.key), c = c.delete(d.doc.key)), d.type !== 1 && (c = c.add(d.doc), v = c.indexOf(d.doc.key)), { type: rP(d.type), doc: p, oldIndex: g, newIndex: v } })) } })(this, i), this._cachedChangesIncludeMetadataChanges = i), this._cachedChanges } toJSON() { if (this.metadata.hasPendingWrites) throw new ft(nt.FAILED_PRECONDITION, "QuerySnapshot.toJSON() attempted to serialize a document with pending writes. Await waitForPendingWrites() before invoking toJSON()."); const t = {}; t.type = Do._jsonSchemaVersion, t.bundleSource = "QuerySnapshot", t.bundleName = oy.newId(), this._firestore._databaseId.database, this._firestore._databaseId.projectId; const i = [], r = [], o = []; return this.docs.forEach((u => { u._document !== null && (i.push(u._document), r.push(this._userDataWriter.convertObjectMap(u._document.data.value.mapValue.fields, "previous")), o.push(u.ref.path)) })), t.bundle = (this._firestore, this.query._query, t.bundleName, "NOT SUPPORTED"), t } } function rP(e) { switch (e) { case 0: return "added"; case 2: case 3: return "modified"; case 1: return "removed"; default: return At(61501, { type: e }) } } Do._jsonSchemaVersion = "firestore/querySnapshot/1.0", Do._jsonSchema = { type: je("string", Do._jsonSchemaVersion), bundleSource: je("string", "QuerySnapshot"), bundleName: je("string"), bundle: je("string") }; function aP(e, t, i) { e = Ts(e, xe); const r = Ts(e.firestore, ko), o = a2(e.converter, t), u = Gf(r); return By(r, [Zw(u, "setDoc", e._key, o, e.converter !== null, i).toMutation(e._key, mi.none())]) } function oP(e, t, i, ...r) { e = Ts(e, xe); const o = Ts(e.firestore, ko), u = Gf(o); let c; return c = typeof (t = Wi(t)) == "string" || t instanceof My ? X9(u, "updateDoc", e._key, t, i, r) : Q9(u, "updateDoc", e._key, t), By(o, [c.toMutation(e._key, mi.exists(!0))]) } function lP(e, t) { const i = Ts(e.firestore, ko), r = bg(e), o = a2(e.converter, t), u = Gf(e.firestore); return By(i, [Zw(u, "addDoc", r._key, o, e.converter !== null, {}).toMutation(r._key, mi.exists(!1))]).then((() => r)) } function o2(e, ...t) { e = Wi(e); let i = { includeMetadataChanges: !1, source: "default" }, r = 0; typeof t[r] != "object" || rE(t[r]) || (i = t[r++]); const o = { includeMetadataChanges: i.includeMetadataChanges, source: i.source }; if (rE(t[r])) { const g = t[r]; t[r] = g.next?.bind(g), t[r + 1] = g.error?.bind(g), t[r + 2] = g.complete?.bind(g) } let u, c, d; if (e instanceof xe) c = Ts(e.firestore, ko), d = dy(e._key.path), u = { next: g => { t[r] && t[r](uP(c, e, g)) }, error: t[r + 1], complete: t[r + 2] }; else { const g = Ts(e, Mr); c = Ts(g.firestore, ko), d = g._query; const v = new i2(c); u = { next: b => { t[r] && t[r](new Do(c, v, g, b)) }, error: t[r + 1], complete: t[r + 2] }, eP(e._query) } const p = Xw(c); return z9(p, d, o, u) } function By(e, t) { const i = Xw(e); return j9(i, t) } function uP(e, t, i) { const r = i.docs.get(t._key), o = new i2(e); return new va(e, o, t._key, r, new cu(i.hasPendingWrites, i.fromCache), t.converter) } (function (t, i = !0) { PO(TO), ff(new xu("firestore", ((r, { instanceIdentifier: o, options: u }) => { const c = r.getProvider("app").getImmediate(), d = new ko(new zO(r.getProvider("auth-internal")), new BO(c, r.getProvider("app-check-internal")), sN(c, o), c); return u = { useFetchStreams: i, ...u }, d._setSettings(u), d }), "PUBLIC").setMultipleInstances(!0)), xo(iE, sE, t), xo(iE, sE, "esm2020") })(); const l2 = { apiKey: void 0, authDomain: void 0, projectId: void 0, storageBucket: void 0, messagingSenderId: void 0, appId: void 0 }, cP = l2.projectId !== "YOUR_PROJECT_ID"; let lE, Fi = null; if (cP) try { lE = xA(l2), Fi = q9(lE) } catch (e) { console.error("Firebase initialization failed:", e) } function hP() { const [e, t] = J.useState([]); return J.useEffect(() => { if (!Fi) { const u = localStorage.getItem("openmic_messages"); if (u) { const c = JSON.parse(u).map(d => ({ ...d, timestamp: new Date(d.timestamp) })); t(c) } else t([{ id: 1, text: "Welcome to Open Mic Night!", type: "text", timestamp: new Date }]); return } const r = nP(_g(Fi, "messages"), iP("timestamp", "asc"), sP(50)), o = o2(r, u => { const c = u.docs.map(d => ({ id: d.id, ...d.data(), timestamp: d.data().timestamp?.toDate() || new Date })); t(c) }); return () => o() }, []), { messages: e, sendMessage: async (r, o = "text") => { const u = { text: r, type: o, timestamp: new Date }; if (!Fi) { const c = [...e, { ...u, id: Date.now() }]; t(c), localStorage.setItem("openmic_messages", JSON.stringify(c)); return } await lP(_g(Fi, "messages"), { ...u, timestamp: J9() }) } } } const fP = ["src/assets/anger.gif", "src/assets/bravo.gif", "src/assets/insult.gif", "src/assets/surprise.gif", "src/assets/thumbs-up.gif", "src/assets/excited.gif"]; function dP() { const { messages: e, sendMessage: t } = hP(), [i, r] = J.useState(""), [o, u] = J.useState(!1), c = J.useRef(null); J.useEffect(() => { c.current && (c.current.scrollTop = c.current.scrollHeight) }, [e]); const d = () => { i.trim() && (t(i, "text"), r("")) }, p = g => { t(g, "gif"), u(!1) }; return F.jsxs("div", { className: "bg-slate-900/50 rounded-2xl border border-white/5 backdrop-blur-md flex flex-col h-[600px] relative overflow-hidden", children: [F.jsx("div", { className: "absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-slate-500 to-transparent opacity-20" }), F.jsxs("div", { className: "p-4 border-b border-slate-800", children: [F.jsx("h2", { className: "text-lg font-semibold text-slate-200", children: "Live Stage Chat" }), F.jsx("p", { className: "text-xs text-slate-500", children: "Public message board" })] }), F.jsx("div", { className: "flex-1 overflow-y-auto p-4 space-y-4", ref: c, children: e.map(g => F.jsxs(dr.div, { initial: { opacity: 0, scale: .95 }, animate: { opacity: 1, scale: 1 }, className: "flex flex-col items-start", children: [F.jsx("div", { className: bs("max-w-[85%] rounded-2xl p-3 text-sm shadow-lg", g.type === "text" ? "bg-slate-800 text-slate-200" : "bg-transparent p-0 overflow-hidden"), children: g.type === "text" ? F.jsx("p", { children: g.text }) : F.jsx("img", { src: g.text, alt: "gif", className: "rounded-xl w-48 h-auto object-cover" }) }), F.jsx("span", { className: "text-[10px] text-slate-600 mt-1 ml-2", children: lf(new Date(g.timestamp), "h:mm aa") })] }, g.id)) }), F.jsxs("div", { className: "p-4 border-t border-slate-800 bg-slate-900/80 backdrop-blur-sm", children: [o && F.jsx("div", { className: "absolute bottom-20 left-4 right-4 bg-slate-800 rounded-xl border border-slate-700 shadow-xl p-2 z-10", children: F.jsx("div", { className: "grid grid-cols-3 gap-2", children: fP.map((g, v) => F.jsx("button", { onClick: () => p(g), className: "hover:opacity-80 transition-opacity", children: F.jsx("img", { src: g, alt: "gif", className: "w-full h-20 object-cover rounded-lg" }) }, v)) }) }), F.jsxs("div", { className: "flex gap-2", children: [F.jsx("button", { onClick: () => u(!o), className: bs("p-3 rounded-lg transition-colors", o ? "bg-slate-700 text-white" : "bg-slate-800 text-slate-400 hover:text-white"), children: F.jsx(HM, {}) }), F.jsx("input", { type: "text", value: i, onChange: g => r(g.target.value), onKeyDown: g => g.key === "Enter" && d(), placeholder: "Say something...", className: "flex-1 bg-slate-800 border-none rounded-lg px-4 text-white focus:ring-1 focus:ring-slate-600 placeholder:text-slate-600" }), F.jsx("button", { onClick: d, disabled: !i.trim(), className: "p-3 bg-tesla-red rounded-lg text-white hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors", children: F.jsx(KM, {}) })] })] })] }) } function mP({ slots: e, onClose: t }) { const [i, r] = J.useState(new Date), [o, u] = J.useState(null), [c, d] = J.useState(null), [p, g] = J.useState(null); J.useEffect(() => { const b = setInterval(() => { const E = new Date; r(E); const x = e.find(M => { const j = new Date(M.rawTime); j.setFullYear(E.getFullYear(), E.getMonth(), E.getDate()); const z = Gb(j, 15); return X3(E, { start: j, end: z }) }); if (u(x), x) { const M = new Date(x.rawTime); M.setFullYear(E.getFullYear(), E.getMonth(), E.getDate()); const j = Gb(M, 15), z = X6(j, E); g(z); const K = e.findIndex(it => it.id === x.id); K >= 0 && K < e.length - 1 ? d(e[K + 1]) : d(null) } else g(null), d(null) }, 1e3); return () => clearInterval(b) }, [e]); const v = b => { if (b === null || b < 0) return "--:--"; const E = Math.floor(b / 60), x = b % 60; return `${E}:${x.toString().padStart(2, "0")}` }; return F.jsxs(dr.div, { initial: { opacity: 0, scale: .98 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: .98 }, className: "fixed inset-0 z-50 bg-slate-950 text-white flex flex-col items-center justify-center p-8", children: [F.jsx("button", { onClick: t, className: "absolute top-6 right-6 p-4 rounded-full bg-slate-900 text-slate-400 hover:text-white hover:bg-slate-800 transition-all border border-slate-800", children: F.jsx(rf, { size: 24 }) }), F.jsxs("div", { className: "w-full max-w-7xl grid grid-cols-1 lg:grid-cols-2 gap-12 items-center", children: [F.jsxs("div", { className: "flex flex-col items-center lg:items-start space-y-12", children: [F.jsxs("div", { className: "bg-slate-900/50 p-12 rounded-3xl border border-slate-800 shadow-2xl backdrop-blur-sm w-full text-center lg:text-left", children: [F.jsxs("span", { className: "text-slate-500 uppercase tracking-widest font-semibold text-lg flex items-center gap-2 mb-4 justify-center lg:justify-start", children: [F.jsx(BM, {}), " Current Time"] }), F.jsxs("h1", { className: "text-8xl md:text-9xl font-mono font-bold tracking-tighter text-white tabular-nums", children: [lf(i, "h:mm"), F.jsx("span", { className: "text-4xl text-slate-500 ml-4", children: lf(i, "ss") })] })] }), o && F.jsxs("div", { className: bs("w-full p-12 rounded-3xl border shadow-2xl transition-all duration-500", p < 60 ? "bg-red-900/20 border-red-500/50 animate-pulse" : "bg-slate-900/30 border-slate-800"), children: [F.jsx("span", { className: bs("uppercase tracking-widest font-semibold text-lg mb-4 block", p < 60 ? "text-red-500" : "text-tesla-red"), children: "Time Remaining" }), F.jsx("h2", { className: bs("text-7xl md:text-9xl font-mono font-bold tracking-tighter tabular-nums", p < 60 ? "text-red-500" : "text-white"), children: v(p) })] })] }), F.jsxs("div", { className: "space-y-8", children: [F.jsxs("div", { className: "relative", children: [F.jsx("div", { className: "absolute -inset-1 bg-gradient-to-r from-tesla-red to-purple-600 rounded-2xl blur opacity-20" }), F.jsxs("div", { className: "relative bg-slate-900 p-10 rounded-2xl border border-slate-700 shadow-xl", children: [F.jsx("span", { className: "text-slate-400 uppercase tracking-widest text-sm font-bold mb-2 block", children: "Now Performing" }), F.jsx("h3", { className: "text-5xl md:text-6xl font-bold text-white mb-2 leading-tight", children: o?.performer || "Open Stage" }), F.jsx("p", { className: "text-xl text-slate-500 font-mono mt-4", children: o ? `${o.time} Slot` : "Waiting for next slot..." })] })] }), c && F.jsxs("div", { className: "bg-slate-900/50 p-8 rounded-2xl border border-slate-800 opacity-60", children: [F.jsx("span", { className: "text-slate-500 uppercase tracking-widest text-xs font-bold mb-2 block", children: "Up Next" }), F.jsx("h4", { className: "text-3xl font-bold text-slate-300", children: c.performer || "Open Slot" }), F.jsx("p", { className: "text-sm text-slate-600 font-mono mt-2", children: c.time })] })] })] })] }) } function pP() { const [e, t] = J.useState(!1); return F.jsxs("div", { className: "relative z-50", children: [F.jsx("button", { onClick: () => t(!0), className: "p-2 text-slate-300 hover:text-white transition-colors", children: F.jsx(UM, { size: 24 }) }), F.jsx(k4, { children: e && F.jsxs(F.Fragment, { children: [F.jsx(dr.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, onClick: () => t(!1), className: "fixed inset-0 bg-black/50 backdrop-blur-sm" }), F.jsxs(dr.div, { initial: { x: "100%" }, animate: { x: 0 }, exit: { x: "100%" }, transition: { type: "spring", damping: 20 }, className: "fixed top-0 right-0 h-full w-80 bg-slate-900 border-l border-slate-800 shadow-2xl p-6 flex flex-col", children: [F.jsxs("div", { className: "flex justify-between items-center mb-8 border-b border-slate-800 pb-4", children: [F.jsx("span", { className: "text-lg font-bold text-tesla-red uppercase tracking-widest", children: "Menu" }), F.jsx("button", { onClick: () => t(!1), className: "text-slate-400 hover:text-white", children: F.jsx(rf, { size: 20 }) })] }), F.jsxs("div", { className: "space-y-2 flex-1", children: [F.jsxs("button", { className: "w-full flex items-center gap-4 p-4 rounded-lg hover:bg-slate-800 transition-colors text-left text-slate-300 hover:text-white group", children: [F.jsx(qM, { className: "group-hover:text-tesla-red transition-colors" }), F.jsx("span", { children: "Previous Weeks" })] }), F.jsxs("button", { className: "w-full flex items-center gap-4 p-4 rounded-lg hover:bg-slate-800 transition-colors text-left text-slate-300 hover:text-white group", children: [F.jsx(GM, { className: "group-hover:text-tesla-red transition-colors" }), F.jsx("span", { children: "Venue Info / Rules" })] }), F.jsxs("button", { className: "w-full flex items-center gap-4 p-4 rounded-lg hover:bg-slate-800 transition-colors text-left text-slate-300 hover:text-white group", children: [F.jsx(FM, { className: "group-hover:text-tesla-red transition-colors" }), F.jsx("span", { children: "Contact Host" })] })] }), F.jsxs("div", { className: "mt-auto pt-6 border-t border-slate-800 text-xs text-slate-500 text-center", children: [F.jsx("p", { children: "Open Mic Manager v1.0" }), F.jsx("p", { children: " 2026" })] })] })] }) })] }) } const uE = () => { const e = []; let t = new Date; t.setHours(20, 0, 0, 0); for (let i = 0; i < 12; i++)e.push({ id: `slot-${i}`, time: lf(t, "h:mm aa"), rawTime: new Date(t).toISOString(), performer: null }), t.setMinutes(t.getMinutes() + 15); return e }; function gP() { const [e, t] = J.useState([]), [i, r] = J.useState(!0); return J.useEffect(() => { if (!Fi) { const d = localStorage.getItem("openmic_slots"); if (d) t(JSON.parse(d)); else { const p = uE(); t(p), localStorage.setItem("openmic_slots", JSON.stringify(p)) } r(!1); return } const u = _g(Fi, "slots"), c = o2(u, d => { if (d.empty) { uE().forEach(async v => { await aP(bg(Fi, "slots", v.id), v) }); return } const p = d.docs.map(g => ({ id: g.id, ...g.data() })).sort((g, v) => g.id.localeCompare(v.id, void 0, { numeric: !0 })); t(p), r(!1) }, d => { console.error("Firestore error:", d), me.error("Live data connection failed. Using offline mode."), r(!1) }); return () => c() }, []), { slots: e, loading: i, updateSlot: async (u, c) => { if (!Fi) { const p = e.map(g => g.id === u ? { ...g, ...c } : g); t(p), localStorage.setItem("openmic_slots", JSON.stringify(p)); return } const d = bg(Fi, "slots", u); try { await oP(d, c) } catch (p) { throw console.error("Update failed", p), me.error("Failed to update slot"), p } } } } function yP() { const [e, t] = fr.useState("landing"), { slots: i, updateSlot: r, loading: o } = gP(); return o && e !== "landing" ? F.jsx("div", { className: "min-h-screen bg-slate-950 flex items-center justify-center text-white", children: "Loading schedule..." }) : F.jsxs("div", { className: "min-h-screen bg-slate-950 text-white relative overflow-x-hidden selection:bg-tesla-red selection:text-white", children: [F.jsx(IM, { position: "top-right", toastOptions: { style: { background: "#334155", color: "#fff" } } }), e === "landing" && F.jsx(HV, { onEnter: () => t("signup") }), e === "signup" && F.jsxs("div", { className: "container mx-auto p-4 space-y-8 pb-20", children: [F.jsxs("header", { className: "flex justify-between items-center py-6 border-b border-slate-800", children: [F.jsx("h1", { className: "text-2xl font-bold tracking-wider uppercase text-slate-200", children: "Open Mic Night" }), F.jsxs("div", { className: "flex gap-4 items-center", children: [F.jsx("button", { onClick: () => t("performance"), className: "text-slate-400 hover:text-tesla-red transition-colors text-sm uppercase tracking-widest font-semibold mr-4 hidden md:block", children: "Performer Mode" }), F.jsx(pP, {})] })] }), F.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [F.jsx("div", { className: "lg:col-span-2", children: F.jsx(z6, { slots: i, updateSlot: r }) }), F.jsx("div", { className: "lg:col-span-1", children: F.jsx(dP, {}) })] })] }), e === "performance" && F.jsx(mP, { slots: i, onClose: () => t("signup") })] }) } Xx.createRoot(document.getElementById("root")).render(F.jsx(J.StrictMode, { children: F.jsx(yP, {}) }));
